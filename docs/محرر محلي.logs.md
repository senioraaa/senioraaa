(venv) PS C:\Users\pc\Downloads\senioraaa-main> python -m flake8 . --exclude=venv,docs,tests,venv/Lib/site-pac










                                                python -m flake8 . --exclude=venv,docs,tests,venv/Lib/site-packages
.\app.py:10:1: F401 'error_handlers.init_error_handlers' imported but unused
.\app.py:15:1: F401 'flask.g' imported but unused
.\app.py:33:1: F401 'models.AppSetting' imported but unused
.\app.py:383:80: E501 line too long (108 > 79 characters)
.\app.py:521:80: E501 line too long (108 > 79 characters)
.\app.py:614:80: E501 line too long (80 > 79 characters)
.\fix_all_issues.py:23:80: E501 line too long (91 > 79 characters)
.\fix_all_issues.py:143:5: E722 do not use bare 'except'
.\fix_all_issues.py:152:5: E722 do not use bare 'except'
.\quick_start.py:34:5: F841 local variable 'e' is assigned to but never used
.\service_runner.py:61:9: F841 local variable 'e' is assigned to but never used
.\telegram_bot.py:235:13: F841 local variable 'e' is assigned to but never used
.\test_profile.py:34:80: E501 line too long (91 > 79 characters)
.\ultimate_auto_sync.py:54:1: E999 IndentationError: expected an indented block after 'try' statement on line 53
.\ultimate_flake8_fixer.py:11:1: F401 'pathlib.Path' imported but unused
.\ultimate_flake8_fixer.py:30:9: E722 do not use bare 'except'
.\ultimate_flake8_fixer.py:40:9: E722 do not use bare 'except'
.\ultimate_flake8_fixer.py:85:80: E501 line too long (226 > 79 characters)
.\ultimate_flake8_fixer.py:86:80: E501 line too long (223 > 79 characters)
.\ultimate_flake8_fixer.py:87:80: E501 line too long (201 > 79 characters)
.\ultimate_flake8_fixer.py:106:80: E501 line too long (184 > 79 characters)
.\ultimate_flake8_fixer.py:115:80: E501 line too long (141 > 79 characters)
.\ultimate_flake8_fixer.py:259:80: E501 line too long (81 > 79 characters)
(venv) PS C:\Users\pc\Downloads\senioraaa-main> 


#!/usr/bin/env python3
"""
نظام الأتمتة الشاملة للبرمجة
يقوم بتنسيق الكود وإصلاح الأخطاء ومزامنة GitHub تلقائياً
"""

import logging
import os
import subprocess
import time
from datetime import datetime
from pathlib import Path

import schedule
from watchdog.events import FileSystemEventHandler
from watchdog.observers import Observer


class UltimateAutoSync:
    def __init__(self, project_path=None):
        self.project_path = project_path or os.getcwd()
        self.setup_logging()
        self.is_syncing = False
        self.pending_changes = False
        self.last_sync = None
        self.sync_stats = {
            "total_syncs": 0,
            "successful_syncs": 0,
            "failed_syncs": 0,
            "code_formats": 0,
            "git_pushes": 0,
        }

    def setup_logging(self):
        """إعداد نظام التسجيل المتقدم"""
        logging.basicConfig(
            level=logging.INFO,
            format="%(asctime)s - %(levelname)s - %(message)s",
            handlers=[
                logging.FileHandler("auto_sync.log", encoding="utf-8"),
                logging.StreamHandler(),
            ],
        )
        self.logger = logging.getLogger(__name__)

    def check_dependencies(self):
        """التحقق من الأدوات المطلوبة"""
        required_tools = ["git", "python"]
        python_packages = ["black", "isort", "flake8", "autopep8"]

        # فحص الأدوات الأساسية
        for tool in required_tools:
            try:
subprocess.run([tool, "--version"], capture_output=capture_output, check=True) # type: ignoreself.logger.info(f"✅ {tool} موجود")
            except (subprocess.CalledProcessError, FileNotFoundError):
                self.logger.error(f"❌ {tool} غير موجود - يجب تثبيته")
                return False

        # فحص حزم Python
        for package in python_packages:
            try:
                subprocess.run(
                    ["python", "-m", package, "--version"],
                    capture_output=True,
                    check=True,
                )
                self.logger.info(f"✅ {package} موجود")
            except (subprocess.CalledProcessError, FileNotFoundError):
                self.logger.warning(f"⚠️  {package} غير موجود - سيتم التخطي")

        return True

    def format_code(self):
        """تنسيق وإصلاح الكود بشكل متقدم"""
        if self.is_syncing:
            return False

        try:
            self.logger.info("🔧 بدء تنسيق الكود...")

            # 1. Black formatter
            try:
                result = subprocess.run(
                    ["python", "-m", "black", ".", "--line-length=88"],
                    capture_output=True,
                    text=True,
                    timeout=120,
                )
                if result.returncode == 0:
                    self.logger.info("✅ تم تنسيق الكود بـ Black")
                    self.sync_stats["code_formats"] += 1
                else:
                    self.logger.warning(f"⚠️  Black warning: {result.stderr}")
            except (subprocess.TimeoutExpired, FileNotFoundError):
                self.logger.warning("⚠️  Black غير متاح")

            # 2. isort للاستيرادات
            try:
                result = subprocess.run(
                    ["python", "-m", "isort", ".", "--profile=black"],
                    capture_output=True,
                    text=True,
                    timeout=60,
                )
                if result.returncode == 0:
                    self.logger.info("✅ تم ترتيب الاستيرادات")
            except (subprocess.TimeoutExpired, FileNotFoundError):
                self.logger.warning("⚠️  isort غير متاح")

            # 3. autopep8 للإصلاحات
            try:
                result = subprocess.run(
                    ["python", "-m", "autopep8", "--in-place", "--recursive", "."],
                    capture_output=True,
                    text=True,
                    timeout=120,
                )
                if result.returncode == 0:
                    self.logger.info("✅ تم إصلاح الأخطاء")
            except (subprocess.TimeoutExpired, FileNotFoundError):
                self.logger.warning("⚠️  autopep8 غير متاح")

            # 4. flake8 للفحص
            try:
                result = subprocess.run(
                    ["python", "-m", "flake8", "."],
                    capture_output=True,
                    text=True,
                    timeout=60,
                )
                if result.returncode == 0:
                    self.logger.info("✅ لا توجد أخطاء في الكود")
                else:
                    self.logger.info(
                        f"📝 تم العثور على تحذيرات: {len(result.stdout.splitlines())} مشكلة"
                    )
            except (subprocess.TimeoutExpired, FileNotFoundError):
                self.logger.warning("⚠️  flake8 غير متاح")

            return True

        except Exception as e:
            self.logger.error(f"❌ خطأ في تنسيق الكود: {e}")
            return False

    def check_git_status(self):
        """فحص حالة Git"""
        try:
            result = subprocess.run(
                ["git", "status", "--porcelain"],
                capture_output=True,
                text=True,
                timeout=30,
            )
            return result.stdout.strip()
        except Exception:  # تم إزالة 'as e' لأن المتغير لم يستخدم
            return ""

    def get_git_info(self):
        """الحصول على معلومات Git"""
        try:
            # الحصول على اسم الفرع
            branch = subprocess.run(
                ["git", "rev-parse", "--abbrev-ref", "HEAD"],
                capture_output=True,
                text=True,
                timeout=10,
            )
            current_branch = branch.stdout.strip() if branch.returncode == 0 else "main"

            # الحصول على Remote URL
            remote = subprocess.run(
                ["git", "config", "--get", "remote.origin.url"],
                capture_output=True,
                text=True,
                timeout=10,
            )
            remote_url = remote.stdout.strip() if remote.returncode == 0 else "غير متاح"

            return current_branch, remote_url
        except Exception:  # تم إزالة 'as e' لأن المتغير لم يستخدم
            return "main", "غير متاح"

    def git_sync(self):
        """مزامنة كاملة مع Git"""
        if self.is_syncing:
            return False

        try:
            self.logger.info("🔄 بدء مزامنة Git...")
            current_branch, remote_url = self.get_git_info()

            # 1. جلب التحديثات
            try:
                subprocess.run(
                    ["git", "fetch", "origin"], check=True, timeout=60
                )  # تم إصلاح القوس الزائد
                self.logger.info("📥 تم جلب التحديثات من GitHub")
            except subprocess.CalledProcessError:
                self.logger.warning("⚠️  لم يتم جلب التحديثات")

            # 2. دمج التحديثات إذا كانت موجودة
            try:
                result = subprocess.run(
                    ["git", "rev-list", "--count", f"HEAD..origin/{current_branch}"],
                    capture_output=True,
                    text=True,
                    timeout=30,
                )
                if result.returncode == 0 and result.stdout.strip() != "0":
                    subprocess.run(
                        ["git", "pull", "origin", current_branch],
                        check=True,
                        timeout=60,
                    )
                    self.logger.info("📥 تم دمج التحديثات")
            except Exception:  # تم إزالة 'as e' لأن المتغير لم يستخدم
                pass

            # 3. إضافة التغييرات ورفعها
            if self.check_git_status():
                subprocess.run(["git", "add", "."], check=True, timeout=30)

                # إنشاء رسالة commit ذكية
                timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                commit_msg = f"🤖 Auto-sync: {timestamp}"

                # إضافة إحصائيات
                stats_msg = f" | Syncs: {self.sync_stats['total_syncs']}, Formats: {self.sync_stats['code_formats']}"
                full_msg = commit_msg + stats_msg

                subprocess.run(
                    ["git", "commit", "-m", full_msg], check=True, timeout=30
                )
                subprocess.run(
                    ["git", "push", "origin", current_branch], check=True, timeout=90
                )  # تم إصلاح القوس الزائد

                self.logger.info(f"✅ تم رفع التحديثات إلى {current_branch}")
                self.sync_stats["git_pushes"] += 1
                return True
            else:
                self.logger.debug("📝 لا توجد تغييرات للرفع")
                return False

        except subprocess.CalledProcessError as e:
            self.logger.error(f"❌ خطأ في مزامنة Git: {e}")
            self.sync_stats["failed_syncs"] += 1
            return False
        except Exception as e:
            self.logger.error(f"❌ خطأ عام في Git: {e}")
            return False

    def full_sync_cycle(self):
        """دورة المزامنة الكاملة"""
        if self.is_syncing:
            self.logger.debug("⏸️  المزامنة جارية بالفعل")
            return

        self.is_syncing = True
        self.sync_stats["total_syncs"] += 1

        try:
            self.logger.info("🚀 بدء دورة المزامنة الكاملة")
            start_time = time.time()

            # 1. تنسيق الكود
            code_formatted = self.format_code()

            # 2. مزامنة Git
            git_synced = self.git_sync()

            # 3. تحديث الإحصائيات
            if code_formatted or git_synced:
                self.sync_stats["successful_syncs"] += 1
                self.pending_changes = False
                self.last_sync = datetime.now()

            duration = time.time() - start_time
            self.logger.info(f"✨ انتهت دورة المزامنة في {duration:.2f} ثانية")

        except Exception as e:
            self.logger.error(f"❌ خطأ في دورة المزامنة: {e}")
            self.sync_stats["failed_syncs"] += 1
        finally:
            self.is_syncing = False

    def start_file_watcher(self):
        """مراقب تغييرات الملفات المتقدم"""

        class SmartFileHandler(FileSystemEventHandler):
            def __init__(self, sync_instance):
                self.sync_instance = sync_instance
                self.last_event_time = {}

            def on_modified(self, event):
                if event.is_directory:
                    return

                # تجاهل الملفات غير المهمة
                ignored_extensions = [
                    ".log",
                    ".tmp",
                    ".pyc",
                    ".pyo",
                    ".pyd",
                    "__pycache__",
                ]
                if any(event.src_path.endswith(ext) for ext in ignored_extensions):
                    return

                # تجاهل الأحداث المكررة
                now = time.time()
                if event.src_path in self.last_event_time:
                    if now - self.last_event_time[event.src_path] < 2:
                        return

                self.last_event_time[event.src_path] = now

                # فقط ملفات Python والملفات المهمة
                if event.src_path.endswith(
                    (".py", ".md", ".txt", ".yml", ".yaml", ".json")
                ):
                    self.sync_instance.pending_changes = True
                    self.sync_instance.logger.debug(
                        f"📝 تم تعديل: {os.path.basename(event.src_path)}"
                    )

        event_handler = SmartFileHandler(self)
        observer = Observer()
        observer.schedule(event_handler, self.project_path, recursive=True)
        observer.start()
        self.logger.info("👀 تم بدء مراقب الملفات الذكي")
        return observer

    def print_stats(self):
        """طباعة الإحصائيات"""
        stats_text = f"""
📊 إحصائيات الأتمتة:
├── إجمالي المزامنات: {self.sync_stats['total_syncs']}
├── مزامنات ناجحة: {self.sync_stats['successful_syncs']}
├── مزامنات فاشلة: {self.sync_stats['failed_syncs']}
├── تنسيقات الكود: {self.sync_stats['code_formats']}
├── رفع Git: {self.sync_stats['git_pushes']}
└── آخر مزامنة: {self.last_sync.strftime('%Y-%m-%d %H:%M:%S') if self.last_sync else 'لم تحدث بعد'}
"""
        self.logger.info(stats_text)

    def start_scheduler(self):
        """بدء جدولة المهام الذكية"""
        # مزامنة كل 45 ثانية
        schedule.every(45).seconds.do(self.full_sync_cycle)

        # مزامنة عند وجود تغييرات معلقة
        def sync_if_pending():
            if self.pending_changes and not self.is_syncing:
                self.full_sync_cycle()

        schedule.every(15).seconds.do(sync_if_pending)

        # طباعة الإحصائيات كل 5 دقائق
        schedule.every(5).minutes.do(self.print_stats)

        self.logger.info("⏰ تم بدء الجدولة الذكية")

    def run(self):
        """تشغيل النظام الكامل"""
        self.logger.info("🚀 بدء نظام الأتمتة الشاملة")

        # فحص المتطلبات
        if not self.check_dependencies():
            self.logger.error("❌ بعض المتطلبات غير متوفرة")
            return

        # معلومات النظام
        current_branch, remote_url = self.get_git_info()
        self.logger.info(f"📂 المشروع: {os.path.basename(self.project_path)}")
        self.logger.info(f"🌿 الفرع: {current_branch}")
        self.logger.info(f"🔗 المستودع: {remote_url}")

        # بدء مراقب الملفات
        observer = self.start_file_watcher()

        # بدء الجدولة
        self.start_scheduler()

        # تشغيل المزامنة الأولى
        self.full_sync_cycle()

        self.logger.info("🎯 النظام جاهز! اضغط Ctrl+C للإيقاف")

        try:
            while True:
                schedule.run_pending()
                time.sleep(1)
        except KeyboardInterrupt:
            self.logger.info("⏹️  تم إيقاف النظام بواسطة المستخدم")
            self.print_stats()
        finally:
            observer.stop()
            observer.join()
            self.logger.info("👋 وداعاً!")


# التشغيل الرئيسي
if __name__ == "__main__":
    # إنشاء النظام وتشغيله
    auto_sync = UltimateAutoSync()
    auto_sync.run()
