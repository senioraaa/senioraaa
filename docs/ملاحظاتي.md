
================================================================================
Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø´Ø±ÙˆØ¹
================================================================================
Ø§Ù„Ù…Ø³Ø§Ø±: C:\Users\pc\Downloads\senioraaa-main
Python: 3.10.11 (tags/v3.10.11:7d4cc5a, Apr  5 2023, 00:38:17) [MSC v.1929 64 bit (AMD64)]
================================================================================


Ø§Ù„ÙƒÙˆØ¯:
================================================================================

============================================================
ğŸ“„ Ù…Ù„Ù: .\analyze.py
============================================================
import os
import subprocess
import sys


def collect_all_info():
    """Ø¬Ù…Ø¹ ÙƒÙ„ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©"""

    print("ğŸ” Ø¬Ù…Ø¹ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ÙƒÙˆØ¯ ÙˆØ§Ù„Ø£Ø®Ø·Ø§Ø¡...")

    # Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø£Ø³Ø§Ø³ÙŠØ©
    info = f"""
{'='*80}
Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø´Ø±ÙˆØ¹
{'='*80}
Ø§Ù„Ù…Ø³Ø§Ø±: {os.getcwd()}
Python: {sys.version}
{'='*80}

"""

    # Ø¬Ù…Ø¹ Ø§Ù„ÙƒÙˆØ¯
    code_content = ""
    python_files = []

    # Ø§Ù„Ù…Ø¬Ù„Ø¯Ø§Øª Ø§Ù„ØªÙŠ Ø³ÙŠØªÙ… ØªØ¬Ø§Ù‡Ù„Ù‡Ø§
    ignored_dirs = [
        ".git",
        "__pycache__",
        "venv",
        "docs",
        "tests",
    ]  # ØªÙ… Ø¥Ø¶Ø§ÙØ© docs Ùˆ tests Ù‡Ù†Ø§

    for root, dirs, files in os.walk("."):
        # ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ø¬Ù„Ø¯Ø§Øª ØºÙŠØ± Ø§Ù„Ù…Ù‡Ù…Ø©
        dirs[:] = [d for d in dirs if not d.startswith(".") and d not in ignored_dirs]

        for file in files:
            if file.endswith(".py"):
                file_path = os.path.join(root, file)
                python_files.append(file_path)

    # Ù‚Ø±Ø§Ø¡Ø© ÙƒÙ„ Ù…Ù„Ù
    for file_path in python_files:
        code_content += f"\n{'='*60}\n"
        code_content += f"ğŸ“„ Ù…Ù„Ù: {file_path}\n"
        code_content += f"{'='*60}\n"

        try:
            with open(file_path, "r", encoding="utf-8") as f:
                code_content += f.read()
        except Exception as e:
            code_content += f"âŒ Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„Ù: {e}\n"

    # Ø¬Ù…Ø¹ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
    errors_content = ""

    # VS Code Problems (Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ØªØ§Ø­Ø§Ù‹)
    try:
        # Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ´ØºÙŠÙ„ Ø§Ù„Ø£Ø¯ÙˆØ§Øª
        tools = ["flake8", "pylint", "black", "isort"]

        for tool in tools:
            try:
                # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ø³Ø§Ø± Ù„Ù„ÙØ­Øµ Ù„ØªØ¬Ù†Ø¨ Ø§Ù„Ù…Ø¬Ù„Ø¯Ø§Øª Ø§Ù„Ù…Ø³ØªØ«Ù†Ø§Ø©
                # flake8 Ùˆ pylint ÙŠÙ…ÙƒÙ†Ù‡Ù…Ø§ ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ø¬Ù„Ø¯Ø§Øª Ù…Ø¨Ø§Ø´Ø±Ø©
                # black Ùˆ isort ÙŠØ­ØªØ§Ø¬Ø§Ù† Ù„ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ø³Ø§Ø±

                command_target = "."  # Ø§ÙØªØ±Ø§Ø¶ÙŠØ§Ù‹ØŒ Ø§Ù„ÙØ­Øµ Ø¹Ù„Ù‰ ÙƒÙ„ Ø§Ù„Ù…Ø¬Ù„Ø¯

                if tool == "flake8":
                    result = subprocess.run(
                        ["python", "-m", "flake8", ".", "--exclude=venv,docs,tests"],
                        capture_output=True,
                        text=True,
                        timeout=30,
                    )
                elif tool == "pylint":
                    # pylint ÙŠØ­ØªØ§Ø¬ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ù„ÙØ§Øª Ø¨Ø´ÙƒÙ„ ØµØ±ÙŠØ­ Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ø§Ù… .pylintrc
                    # Ù‡Ù†Ø§ Ù‡Ù†Ø®Ù„ÙŠÙ‡ ÙŠÙØ­Øµ ÙƒÙ„ Ù…Ù„ÙØ§Øª Ø§Ù„Ø¨Ø§ÙŠØ«ÙˆÙ† Ø§Ù„Ù„ÙŠ ØªÙ… Ø¬Ù…Ø¹Ù‡Ø§
                    # Ù„ÙƒÙ† Ø¯Ù‡ Ù…Ù…ÙƒÙ† ÙŠÙƒÙˆÙ† Ø¨Ø·ÙŠØ¡ Ù„Ùˆ Ø§Ù„Ø¹Ø¯Ø¯ ÙƒØ¨ÙŠØ± Ø¬Ø¯Ø§Ù‹
                    # Ø®Ù„ÙŠÙ†Ø§ Ù†Ø®Ù„ÙŠÙ‡ ÙŠÙØ­Øµ Ø§Ù„Ù…Ø¬Ù„Ø¯ Ø§Ù„Ø­Ø§Ù„ÙŠ ÙˆÙŠØ³ØªØ«Ù†ÙŠ Ø§Ù„Ù…Ø¬Ù„Ø¯Ø§Øª
                    result = subprocess.run(
                        ["python", "-m", "pylint", ".", "--ignore=venv,docs,tests"],
                        capture_output=True,
                        text=True,
                        timeout=60,
                    )
                elif tool == "black":
                    result = subprocess.run(
                        [
                            "python",
                            "-m",
                            "black",
                            ".",
                            "--check",
                            "--exclude=venv|docs|tests",
                        ],
                        capture_output=True,
                        text=True,
                        timeout=30,
                    )
                elif tool == "isort":
                    result = subprocess.run(
                        [
                            "python",
                            "-m",
                            "isort",
                            ".",
                            "--check-only",
                            "--skip-glob=venv/*,docs/*,tests/*",
                        ],
                        capture_output=True,
                        text=True,
                        timeout=30,
                    )

                if result.stdout or result.stderr:
                    errors_content += f"\n{'='*50}\n"
                    errors_content += f"ğŸ”§ Ø£Ø®Ø·Ø§Ø¡ {tool.upper()}\n"
                    errors_content += f"{'='*50}\n"
                    errors_content += result.stdout + "\n"
                    if result.stderr:
                        errors_content += "STDERR:\n" + result.stderr + "\n"

            except subprocess.TimeoutExpired:
                errors_content += f"â° Ø§Ù†ØªÙ‡Øª Ù…Ù‡Ù„Ø© {tool}\n"
            except Exception as e:
                errors_content += f"âŒ Ø®Ø·Ø£ ÙÙŠ {tool}: {e}\n"

    except Exception as e:
        errors_content += f"âŒ Ø®Ø·Ø£ Ø¹Ø§Ù… ÙÙŠ Ø¬Ù…Ø¹ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡: {e}\n"

    # ØªØ¬Ù…ÙŠØ¹ ÙƒÙ„ Ø´ÙŠØ¡
    final_content = info + "\n"
    final_content += "Ø§Ù„ÙƒÙˆØ¯:\n"
    final_content += "=" * 80 + "\n"
    final_content += code_content + "\n\n"
    final_content += "Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ ÙˆØ§Ù„ØªØ­Ø°ÙŠØ±Ø§Øª:\n"
    final_content += "=" * 80 + "\n"
    final_content += errors_content

    # Ø­ÙØ¸ ÙÙŠ Ù…Ù„Ù
    with open("complete_analysis.txt", "w", encoding="utf-8") as f:
        f.write(final_content)

    print("âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙƒØ§Ù…Ù„ ÙÙŠ complete_analysis.txt")
    print("ğŸ“‹ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† Ù†Ø³Ø® Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…Ù„Ù ÙˆØ¥Ø±Ø³Ø§Ù„Ù‡")

    # Ø·Ø¨Ø§Ø¹Ø© Ù…Ù„Ø®Øµ
    print(f"\nğŸ“Š Ù…Ù„Ø®Øµ:")
    print(f"- Ø¹Ø¯Ø¯ Ù…Ù„ÙØ§Øª Python: {len(python_files)}")
    print(f"- Ø­Ø¬Ù… Ø§Ù„ÙƒÙˆØ¯: {len(code_content)} Ø­Ø±Ù")
    print(f"- Ø­Ø¬Ù… Ø§Ù„Ø£Ø®Ø·Ø§Ø¡: {len(errors_content)} Ø­Ø±Ù")

    return final_content


if __name__ == "__main__":
    collect_all_info()

============================================================
ğŸ“„ Ù…Ù„Ù: .\app.py
============================================================
import atexit
import hashlib
import ipaddress
import json
import logging
import os
import random
import re
import string
import time
import uuid
from collections import defaultdict, deque
from datetime import datetime, timedelta
from functools import wraps
from logging.handlers import RotatingFileHandler
from threading import Lock

import requests
from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.triggers.interval import IntervalTrigger
from dotenv import load_dotenv
from flask import (
    Flask,
    flash,
    jsonify,
    redirect,
    render_template,
    request,
    session,
    url_for,
)
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
from flask_login import (
    LoginManager,
    UserMixin,
    current_user,
    login_required,
    login_user,
    logout_user,
)
from flask_mail import Mail, Message
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import (
    text,  # <--- Ù‡Ø°Ø§ Ù‡Ùˆ Ø§Ù„Ø³Ø·Ø± Ø§Ù„Ø°ÙŠ ØªÙ… Ø¥Ø¶Ø§ÙØªÙ‡ Ù„Ø¥ØµÙ„Ø§Ø­ Ù…Ø´ÙƒÙ„Ø© Textual SQL expression
)
from werkzeug.security import check_password_hash, generate_password_hash

# Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…
from telegram_bot import telegram_system

# Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ø¯ÙˆØ±ÙŠØ© Ù„Ù€ APScheduler
scheduler = BackgroundScheduler()

class SmartRateLimiter:
    """Ù†Ø¸Ø§Ù… Rate Limiting Ø°ÙƒÙŠ ÙˆÙ…ØªÙ‚Ø¯Ù… Ù…ØªØ¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª"""

    def __init__(self, app=None, redis_client=None):
        self.app = app
        self.redis_client = redis_client
        self.memory_store = defaultdict(lambda: defaultdict(deque))
        self.suspicious_ips = defaultdict(lambda: {"score": 0, "last_seen": 0})
        self.user_reputation = defaultdict(lambda: {"score": 100, "last_activity": 0})
        self.lock = Lock()

        # Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø´Ø¨ÙƒØ§Øª Ø§Ù„Ù…ÙˆØ«ÙˆÙ‚Ø©
        self.trusted_networks = [
            ipaddress.ip_network('127.0.0.0/8'),    # localhost
            ipaddress.ip_network('10.0.0.0/8'),     # private networks
            ipaddress.ip_network('172.16.0.0/12'),  # private networks
            ipaddress.ip_network('192.168.0.0/16'), # private networks
        ]

        # User Agents Ù„Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ù…ÙˆØ«ÙˆÙ‚Ø©
        self.trusted_user_agents = [
            'uptimerobot', 'pingdom', 'googlebot', 'bingbot', 'monitor',
            'health-check', 'render', 'nginx', 'apache', 'cloudflare'
        ]

        # Ù†Ù‚Ø§Ø· Ø§Ù„Ø³Ù„ÙˆÙƒ Ø§Ù„Ù…Ø´Ø¨ÙˆÙ‡
        self.suspicious_patterns = {
            'rapid_requests': -10,      # Ø·Ù„Ø¨Ø§Øª Ø³Ø±ÙŠØ¹Ø© Ø¬Ø¯Ø§Ù‹
            'failed_login': -15,        # ÙØ´Ù„ ÙÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„
            'invalid_form': -5,         # Ù†Ù…ÙˆØ°Ø¬ ØºÙŠØ± ØµØ§Ù„Ø­
            'honeypot_hit': -25,        # ÙˆÙ‚ÙˆØ¹ ÙÙŠ ÙØ® Ø§Ù„Ø¨ÙˆØªØ§Øª
            'successful_action': +5,     # Ø¹Ù…Ù„ Ù†Ø§Ø¬Ø­
            'normal_browsing': +2,       # ØªØµÙØ­ Ø·Ø¨ÙŠØ¹ÙŠ
            'account_verified': +20      # ØªÙØ¹ÙŠÙ„ Ø­Ø³Ø§Ø¨
        }

        if app:
            self.init_app(app)

    def init_app(self, app):
        """ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚"""
        self.app = app

        # Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù€ Redis
        try:
            import redis
            redis_url = app.config.get('REDIS_URL', os.environ.get('REDIS_URL'))
            if redis_url and redis_url != 'memory://':
                self.redis_client = redis.from_url(redis_url, decode_responses=True)
                # Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø§ØªØµØ§Ù„
                self.redis_client.ping()
                app.logger.info("Connected to Redis for advanced rate limiting")
            else:
                self.redis_client = None
                app.logger.info("Using memory storage for rate limiting")
        except Exception as e:
            app.logger.warning(f"Redis connection failed, using memory storage: {e}")
            self.redis_client = None

    def is_trusted_source(self, request):
        """ÙØ­Øµ Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…ØµØ¯Ø± Ù…ÙˆØ«ÙˆÙ‚Ø§Ù‹"""
        try:
            # ÙØ­Øµ IP
            client_ip = ipaddress.ip_address(get_remote_address())
            for network in self.trusted_networks:
                if client_ip in network:
                    return True
        except:
            pass

        # ÙØ­Øµ User-Agent
        user_agent = request.headers.get('User-Agent', '').lower()
        for trusted_agent in self.trusted_user_agents:
            if trusted_agent in user_agent:
                return True

        return False

    def get_client_fingerprint(self, request):
        """Ø¥Ù†Ø´Ø§Ø¡ Ø¨ØµÙ…Ø© ÙØ±ÙŠØ¯Ø© Ù„Ù„Ø¹Ù…ÙŠÙ„"""
        ip = get_remote_address()
        user_agent = request.headers.get('User-Agent', '')[:100]
        accept_language = request.headers.get('Accept-Language', '')[:50]
        accept_encoding = request.headers.get('Accept-Encoding', '')[:50]

        # Ø¥Ù†Ø´Ø§Ø¡ Ø¨ØµÙ…Ø© Ù…Ø±ÙƒØ¨Ø©
        fingerprint_data = f"{ip}:{user_agent}:{accept_language}:{accept_encoding}"
        return hashlib.sha256(fingerprint_data.encode()).hexdigest()[:16]

    def get_client_identifier(self, request):
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ø±Ù ÙØ±ÙŠØ¯ Ù„Ù„Ø¹Ù…ÙŠÙ„ (Ù„Ù„ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù‚Ø¯ÙŠÙ…)"""
        return self.get_client_fingerprint(request)

    def update_reputation(self, identifier, action, user_id=None):
        """ØªØ­Ø¯ÙŠØ« Ø³Ù…Ø¹Ø© Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø£Ùˆ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…"""
        current_time = int(time.time())
        score_change = self.suspicious_patterns.get(action, 0)

        # ØªØ­Ø¯ÙŠØ« Ø³Ù…Ø¹Ø© IP
        if identifier in self.suspicious_ips:
            self.suspicious_ips[identifier]["score"] = max(
                -100, min(100, self.suspicious_ips[identifier]["score"] + score_change)
            )
        else:
            self.suspicious_ips[identifier] = {
                "score": score_change,
                "last_seen": current_time
            }

        self.suspicious_ips[identifier]["last_seen"] = current_time

        # ØªØ­Ø¯ÙŠØ« Ø³Ù…Ø¹Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…Ø³Ø¬Ù„ Ø§Ù„Ø¯Ø®ÙˆÙ„
        if user_id:
            if user_id in self.user_reputation:
                self.user_reputation[user_id]["score"] = max(
                    0, min(200, self.user_reputation[user_id]["score"] + score_change)
                )
            else:
                self.user_reputation[user_id] = {
                    "score": 100 + score_change,
                    "last_activity": current_time
                }

            self.user_reputation[user_id]["last_activity"] = current_time

        # Ø­ÙØ¸ ÙÙŠ Redis Ø¥Ø°Ø§ Ù…ØªØ§Ø­
        if self.redis_client:
            try:
                self.redis_client.hset(
                    f"reputation:ip:{identifier}",
                    mapping={
                        "score": self.suspicious_ips[identifier]["score"],
                        "last_seen": current_time
                    }
                )
                self.redis_client.expire(f"reputation:ip:{identifier}", 86400)  # 24 Ø³Ø§Ø¹Ø©

                if user_id:
                    self.redis_client.hset(
                        f"reputation:user:{user_id}",
                        mapping={
                            "score": self.user_reputation[user_id]["score"],
                            "last_activity": current_time
                        }
                    )
                    self.redis_client.expire(f"reputation:user:{user_id}", 604800)  # 7 Ø£ÙŠØ§Ù…
            except:
                pass

    def get_dynamic_limits(self, identifier, base_per_minute, base_per_hour, user_id=None):
        """Ø­Ø³Ø§Ø¨ Ø­Ø¯ÙˆØ¯ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ù…Ø¹Ø©"""
        # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù†Ù‚Ø§Ø· Ø§Ù„Ø³Ù…Ø¹Ø©
        ip_score = self.suspicious_ips.get(identifier, {}).get("score", 0)
        user_score = 100  # Ø§ÙØªØ±Ø§Ø¶ÙŠ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ØºÙŠØ± Ù…Ø³Ø¬Ù„ÙŠ Ø§Ù„Ø¯Ø®ÙˆÙ„

        if user_id:
            user_score = self.user_reputation.get(user_id, {}).get("score", 100)

        # Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø¶Ø§Ø¹Ù Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ù…Ø¹Ø©
        if ip_score < -50 or user_score < 20:
            # Ø³Ù…Ø¹Ø© Ø³ÙŠØ¦Ø© Ø¬Ø¯Ø§Ù‹ - Ø­Ø¯ÙˆØ¯ ØµØ§Ø±Ù…Ø©
            multiplier = 0.2
        elif ip_score < -20 or user_score < 50:
            # Ø³Ù…Ø¹Ø© Ø³ÙŠØ¦Ø© - Ø­Ø¯ÙˆØ¯ Ù…Ù†Ø®ÙØ¶Ø©
            multiplier = 0.5
        elif ip_score > 20 and user_score > 150:
            # Ø³Ù…Ø¹Ø© Ù…Ù…ØªØ§Ø²Ø© - Ø­Ø¯ÙˆØ¯ Ù…Ø±ØªÙØ¹Ø©
            multiplier = 2.0
        elif ip_score > 10 and user_score > 120:
            # Ø³Ù…Ø¹Ø© Ø¬ÙŠØ¯Ø© - Ø­Ø¯ÙˆØ¯ Ø£Ø¹Ù„Ù‰ Ù‚Ù„ÙŠÙ„Ø§Ù‹
            multiplier = 1.5
        else:
            # Ø³Ù…Ø¹Ø© Ø·Ø¨ÙŠØ¹ÙŠØ© - Ø­Ø¯ÙˆØ¯ Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
            multiplier = 1.0

        return {
            'per_minute': max(1, int(base_per_minute * multiplier)),
            'per_hour': max(5, int(base_per_hour * multiplier)),
            'multiplier': multiplier
        }

    def check_rate_limit(self, identifier, limit_per_minute, limit_per_hour):
        """ÙØ­Øµ Rate Limit Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ (Ù„Ù„ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù‚Ø¯ÙŠÙ…)"""
        current_time = int(time.time())

        if self.redis_client:
            return self._check_rate_limit_redis(identifier, limit_per_minute, limit_per_hour, current_time)
        else:
            return self._check_rate_limit_memory(identifier, limit_per_minute, limit_per_hour, current_time)

    def _check_rate_limit_redis(self, identifier, limit_per_minute, limit_per_hour, current_time):
        """ÙØ­Øµ Rate Limit Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Redis"""
        try:
            pipe = self.redis_client.pipeline()

            # Ù…ÙØ§ØªÙŠØ­ Ù„Ù„Ø¯Ù‚ÙŠÙ‚Ø© ÙˆØ§Ù„Ø³Ø§Ø¹Ø©
            minute_key = f"rate_limit:{identifier}:minute:{current_time // 60}"
            hour_key = f"rate_limit:{identifier}:hour:{current_time // 3600}"

            # Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø¹Ø¯Ø§Ø¯Ø§Øª
            pipe.incr(minute_key)
            pipe.expire(minute_key, 120)  # Ø§Ù†ØªÙ‡Ø§Ø¡ ØµÙ„Ø§Ø­ÙŠØ© Ø¨Ø¹Ø¯ Ø¯Ù‚ÙŠÙ‚ØªÙŠÙ†
            pipe.incr(hour_key)
            pipe.expire(hour_key, 7200)  # Ø§Ù†ØªÙ‡Ø§Ø¡ ØµÙ„Ø§Ø­ÙŠØ© Ø¨Ø¹Ø¯ Ø³Ø§Ø¹ØªÙŠÙ†

            results = pipe.execute()
            minute_count = results[0]
            hour_count = results[2]

            # ÙØ­Øµ Ø§Ù„Ø­Ø¯ÙˆØ¯
            if minute_count > limit_per_minute:
                return False, f"Rate limit exceeded: {minute_count}/{limit_per_minute} per minute"

            if hour_count > limit_per_hour:
                return False, f"Rate limit exceeded: {hour_count}/{limit_per_hour} per hour"

            return True, None

        except Exception as e:
            self.app.logger.error(f"Redis rate limit error: {e}")
            # Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø°Ø§ÙƒØ±Ø© ÙƒØ¨Ø¯ÙŠÙ„
            return self._check_rate_limit_memory(identifier, limit_per_minute, limit_per_hour, current_time)

    def _check_rate_limit_memory(self, identifier, limit_per_minute, limit_per_hour, current_time):
        """ÙØ­Øµ Rate Limit Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø°Ø§ÙƒØ±Ø©"""
        with self.lock:
            minute_window = current_time // 60
            hour_window = current_time // 3600

            # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
            self._cleanup_old_data(current_time)

            # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø·Ù„Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠ
            self.memory_store[identifier]['minute'].append(minute_window)
            self.memory_store[identifier]['hour'].append(hour_window)

            # Ø¹Ø¯ Ø§Ù„Ø·Ù„Ø¨Ø§Øª ÙÙŠ Ø§Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
            minute_count = sum(1 for t in self.memory_store[identifier]['minute'] if t == minute_window)
            hour_count = sum(1 for t in self.memory_store[identifier]['hour'] if t == hour_window)

            # ÙØ­Øµ Ø§Ù„Ø­Ø¯ÙˆØ¯
            if minute_count > limit_per_minute:
                return False, f"Rate limit exceeded: {minute_count}/{limit_per_minute} per minute"

            if hour_count > limit_per_hour:
                return False, f"Rate limit exceeded: {hour_count}/{limit_per_hour} per hour"

            return True, None

    def check_advanced_rate_limit(self, identifier, base_per_minute, base_per_hour,
                                  endpoint, user_id=None):
        """ÙØ­Øµ Ù…Ø¹Ø¯Ù„ Ù…ØªÙ‚Ø¯Ù… Ù…Ø¹ ØªØ­Ù„ÙŠÙ„ Ø³Ù„ÙˆÙƒÙŠ"""
        current_time = int(time.time())

        # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø­Ø¯ÙˆØ¯ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ©
        limits = self.get_dynamic_limits(identifier, base_per_minute, base_per_hour, user_id)

        # ÙØ­Øµ Ø§Ù„ØªØ±Ø¯Ø¯ Ø§Ù„Ø³Ø±ÙŠØ¹ (Ø£Ù‚Ù„ Ù…Ù† Ø«Ø§Ù†ÙŠØ© ÙˆØ§Ø­Ø¯Ø©)
        if self.redis_client:
            last_request_key = f"last_request:{identifier}"
            last_request = self.redis_client.get(last_request_key)
            if last_request and (current_time - int(last_request)) < 1:
                self.update_reputation(identifier, 'rapid_requests', user_id)
                return False, "Requests too frequent", limits['multiplier']

            self.redis_client.setex(last_request_key, 5, current_time)

        # ÙØ­Øµ Rate Limit Ø§Ù„Ø¹Ø§Ø¯ÙŠ
        if self.redis_client:
            allowed, error_msg = self._check_rate_limit_redis_advanced(
                identifier, limits['per_minute'], limits['per_hour'], current_time, endpoint
            )
        else:
            allowed, error_msg = self._check_rate_limit_memory_advanced(
                identifier, limits['per_minute'], limits['per_hour'], current_time, endpoint
            )

        if not allowed:
            self.update_reputation(identifier, 'rapid_requests', user_id)
        else:
            self.update_reputation(identifier, 'normal_browsing', user_id)

        return allowed, error_msg, limits['multiplier']

    def _check_rate_limit_redis_advanced(self, identifier, limit_per_minute,
                                        limit_per_hour, current_time, endpoint):
        """ÙØ­Øµ Rate Limit Ù…ØªÙ‚Ø¯Ù… Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Redis"""
        try:
            pipe = self.redis_client.pipeline()

            # Ù…ÙØ§ØªÙŠØ­ Ù…Ø®ØªÙ„ÙØ© Ù„Ù„Ù€ endpoints Ø§Ù„Ù…Ø®ØªÙ„ÙØ©
            minute_key = f"rate_limit:{identifier}:{endpoint}:minute:{current_time // 60}"
            hour_key = f"rate_limit:{identifier}:{endpoint}:hour:{current_time // 3600}"
            global_minute_key = f"rate_limit:{identifier}:global:minute:{current_time // 60}"
            global_hour_key = f"rate_limit:{identifier}:global:hour:{current_time // 3600}"

            # Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø¹Ø¯Ø§Ø¯Ø§Øª
            pipe.incr(minute_key)
            pipe.expire(minute_key, 120)
            pipe.incr(hour_key)
            pipe.expire(hour_key, 7200)
            pipe.incr(global_minute_key)
            pipe.expire(global_minute_key, 120)
            pipe.incr(global_hour_key)
            pipe.expire(global_hour_key, 7200)

            results = pipe.execute()
            endpoint_minute_count = results[0]
            endpoint_hour_count = results[2]
            global_minute_count = results[4]
            global_hour_count = results[6]

            # ÙØ­Øµ Ø­Ø¯ÙˆØ¯ Ø§Ù„Ù€ endpoint Ø§Ù„Ù…Ø­Ø¯Ø¯
            if endpoint_minute_count > limit_per_minute:
                return False, f"Endpoint rate limit exceeded: {endpoint_minute_count}/{limit_per_minute} per minute"

            if endpoint_hour_count > limit_per_hour:
                return False, f"Endpoint rate limit exceeded: {endpoint_hour_count}/{limit_per_hour} per hour"

            # ÙØ­Øµ Ø§Ù„Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø¹Ø§Ù…Ø© (Ù„Ù…Ù†Ø¹ Ø¥Ø³Ø§Ø¡Ø© Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¹Ø§Ù…)
            if global_minute_count > limit_per_minute * 3:
                return False, f"Global rate limit exceeded: {global_minute_count} per minute"

            if global_hour_count > limit_per_hour * 3:
                return False, f"Global rate limit exceeded: {global_hour_count} per hour"

            return True, None

        except Exception as e:
            self.app.logger.error(f"Redis advanced rate limit error: {e}")
            return self._check_rate_limit_memory_advanced(
                identifier, limit_per_minute, limit_per_hour, current_time, endpoint
            )

    def _check_rate_limit_memory_advanced(self, identifier, limit_per_minute,
                                         limit_per_hour, current_time, endpoint):
        """ÙØ­Øµ Rate Limit Ù…ØªÙ‚Ø¯Ù… Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø°Ø§ÙƒØ±Ø©"""
        with self.lock:
            minute_window = current_time // 60
            hour_window = current_time // 3600

            # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
            self._cleanup_old_data(current_time)

            # Ù…ÙØ§ØªÙŠØ­ Ù…Ø®ØªÙ„ÙØ© Ù„Ù„Ù€ endpoints
            endpoint_key = f"{identifier}:{endpoint}"

            # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø·Ù„Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠ
            if endpoint_key not in self.memory_store:
                self.memory_store[endpoint_key] = defaultdict(deque)

            self.memory_store[endpoint_key]['minute'].append(minute_window)
            self.memory_store[endpoint_key]['hour'].append(hour_window)

            # Ø¹Ø¯ Ø§Ù„Ø·Ù„Ø¨Ø§Øª ÙÙŠ Ø§Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
            minute_count = sum(1 for t in self.memory_store[endpoint_key]['minute']
                             if t == minute_window)
            hour_count = sum(1 for t in self.memory_store[endpoint_key]['hour']
                           if t == hour_window)

            # ÙØ­Øµ Ø§Ù„Ø­Ø¯ÙˆØ¯
            if minute_count > limit_per_minute:
                return False, f"Rate limit exceeded: {minute_count}/{limit_per_minute} per minute"

            if hour_count > limit_per_hour:
                return False, f"Rate limit exceeded: {hour_count}/{limit_per_hour} per hour"

            return True, None

    def _cleanup_old_data(self, current_time):
        """ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ù…Ù† Ø§Ù„Ø°Ø§ÙƒØ±Ø©"""
        minute_threshold = (current_time // 60) - 2
        hour_threshold = (current_time // 3600) - 2
        reputation_threshold = current_time - 86400  # 24 Ø³Ø§Ø¹Ø©

        # ØªÙ†Ø¸ÙŠÙ Ø¨ÙŠØ§Ù†Ø§Øª Rate Limiting
        for key in list(self.memory_store.keys()):
            minute_queue = self.memory_store[key]['minute']
            while minute_queue and minute_queue[0] < minute_threshold:
                minute_queue.popleft()

            hour_queue = self.memory_store[key]['hour']
            while hour_queue and hour_queue[0] < hour_threshold:
                hour_queue.popleft()

            if not minute_queue and not hour_queue:
                del self.memory_store[key]

        # ØªÙ†Ø¸ÙŠÙ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø³Ù…Ø¹Ø© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
        for ip in list(self.suspicious_ips.keys()):
            if self.suspicious_ips[ip]["last_seen"] < reputation_threshold:
                del self.suspicious_ips[ip]

        for user_id in list(self.user_reputation.keys()):
            if self.user_reputation[user_id]["last_activity"] < reputation_threshold:
                del self.user_reputation[user_id]

    def is_temporarily_blocked(self, identifier):
        """ÙØ­Øµ Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† IP Ù…Ø­Ø¸ÙˆØ± Ù…Ø¤Ù‚ØªØ§Ù‹"""
        if self.redis_client:
            block_key = f"temp_block:{identifier}"
            return self.redis_client.exists(block_key)
        else:
            # ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø©ØŒ Ù†Ø¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ù†Ù‚Ø§Ø· ÙÙ‚Ø·
            return self.suspicious_ips.get(identifier, {}).get("score", 0) < -75

    def temporary_block(self, identifier, duration_minutes=15):
        """Ø­Ø¸Ø± Ù…Ø¤Ù‚Øª Ù„Ù„Ù€ IP"""
        if self.redis_client:
            block_key = f"temp_block:{identifier}"
            self.redis_client.setex(block_key, duration_minutes * 60, "blocked")
            self.app.logger.warning(f"Temporarily blocked IP {identifier} for {duration_minutes} minutes")


# Ø¥Ù†Ø´Ø§Ø¡ instance Ù…Ù† SmartRateLimiter
smart_limiter = SmartRateLimiter()

def advanced_rate_limit(per_minute=10, per_hour=100, skip_trusted=True, block_on_abuse=True):
    """Ø¯ÙŠÙƒÙˆØ±ÙŠØªØ± Ù„Ù„Ù€ Rate Limiting Ø§Ù„Ù…ØªÙ‚Ø¯Ù… Ù…Ø¹ ØªØ­Ù„ÙŠÙ„ Ø³Ù„ÙˆÙƒÙŠ"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            # ÙØ­Øµ Ø§Ù„Ù…ØµØ§Ø¯Ø± Ø§Ù„Ù…ÙˆØ«ÙˆÙ‚Ø©
            if skip_trusted and smart_limiter.is_trusted_source(request):
                return f(*args, **kwargs)

            # ÙØ­Øµ Ø§Ù„Ù€ endpoints Ø§Ù„Ù…Ø³ØªØ«Ù†Ø§Ø©
            if any(request.path.startswith(endpoint) for endpoint in EXEMPT_ENDPOINTS):
                return f(*args, **kwargs)

            # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ø±Ù Ø§Ù„Ø¹Ù…ÙŠÙ„ ÙˆÙ…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
            client_fingerprint = smart_limiter.get_client_fingerprint(request)
            user_id = current_user.id if current_user.is_authenticated else None
            endpoint = request.endpoint or request.path.split('/')[-1]

            # ÙØ­Øµ Ø§Ù„Ø­Ø¸Ø± Ø§Ù„Ù…Ø¤Ù‚Øª
            if smart_limiter.is_temporarily_blocked(client_fingerprint):
                app.logger.warning(f"Access denied for temporarily blocked client: {get_remote_address()}")

                if request.path.startswith('/api/') or request.is_json:
                    return jsonify({
                        'error': 'Temporarily blocked',
                        'message': 'Your access has been temporarily restricted due to suspicious activity.',
                        'retry_after': 900  # 15 Ø¯Ù‚ÙŠÙ‚Ø©
                    }), 429

                flash('ØªÙ… Ø­Ø¸Ø± ÙˆØµÙˆÙ„Ùƒ Ù…Ø¤Ù‚ØªØ§Ù‹ Ø¨Ø³Ø¨Ø¨ Ù†Ø´Ø§Ø· Ù…Ø´Ø¨ÙˆÙ‡. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨Ø¹Ø¯ 15 Ø¯Ù‚ÙŠÙ‚Ø©.', 'error')
                return render_template('429.html'), 429

            # ÙØ­Øµ Rate Limit Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
            allowed, error_msg, reputation_multiplier = smart_limiter.check_advanced_rate_limit(
                client_fingerprint, per_minute, per_hour, endpoint, user_id
            )

            if not allowed:
                app.logger.warning(f"Rate limit exceeded for {get_remote_address()}: {error_msg}")

                # ÙÙŠ Ø­Ø§Ù„Ø© ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¯ Ø¹Ø¯Ø© Ù…Ø±Ø§ØªØŒ ØªØ·Ø¨ÙŠÙ‚ Ø­Ø¸Ø± Ù…Ø¤Ù‚Øª
                if block_on_abuse and reputation_multiplier < 0.5:
                    smart_limiter.temporary_block(client_fingerprint, 15)

                # ØªØ­Ø¯ÙŠØ¯ Ù…Ø¯Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø³Ù…Ø¹Ø©
                retry_after = int(60 / max(0.1, reputation_multiplier))

                if request.path.startswith('/api/') or request.is_json:
                    return jsonify({
                        'error': 'Rate limit exceeded',
                        'message': 'Too many requests. Please try again later.',
                        'retry_after': retry_after,
                        'reputation': f"{reputation_multiplier:.1f}x"
                    }), 429

                flash(f'ØªÙ… ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¯ Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ù…Ù† Ø§Ù„Ø·Ù„Ø¨Ø§Øª. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨Ø¹Ø¯ {retry_after} Ø«Ø§Ù†ÙŠØ©.', 'error')
                return render_template('429.html'), 429

            return f(*args, **kwargs)
        return decorated_function
    return decorator

def smart_rate_limit(per_minute=10, per_hour=100, skip_trusted=True):
    """Ø¯ÙŠÙƒÙˆØ±ÙŠØªØ± Ù„Ù„Ù€ Rate Limiting Ø§Ù„Ø°ÙƒÙŠ"""
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            # ÙØ­Øµ Ø§Ù„Ù…ØµØ§Ø¯Ø± Ø§Ù„Ù…ÙˆØ«ÙˆÙ‚Ø©
            if skip_trusted and smart_limiter.is_trusted_source(request):
                return f(*args, **kwargs)

            # ÙØ­Øµ Ø§Ù„Ù€ endpoints Ø§Ù„Ù…Ø³ØªØ«Ù†Ø§Ø©
            if any(request.path.startswith(endpoint) for endpoint in EXEMPT_ENDPOINTS):
                return f(*args, **kwargs)

            # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ø±Ù Ø§Ù„Ø¹Ù…ÙŠÙ„
            client_id = smart_limiter.get_client_identifier(request)

            # ÙØ­Øµ Rate Limit
            allowed, error_msg = smart_limiter.check_rate_limit(
                client_id, per_minute, per_hour
            )

            if not allowed:
                app.logger.warning(f"Rate limit exceeded for {get_remote_address()}: {error_msg}")

                # Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ø³ØªØ¬Ø§Ø¨Ø© JSON Ù„Ù„Ù€ API endpoints
                if request.path.startswith('/api/') or request.is_json:
                    return jsonify({
                        'error': 'Rate limit exceeded',
                        'message': 'Too many requests. Please try again later.',
                        'retry_after': 60
                    }), 429

                # Ø¥Ø±Ø¬Ø§Ø¹ ØµÙØ­Ø© HTML Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ø¹Ø§Ø¯ÙŠÙŠÙ†
                flash('ØªÙ… ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¯ Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ù…Ù† Ø§Ù„Ø·Ù„Ø¨Ø§Øª. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨Ø¹Ø¯ Ù‚Ù„ÙŠÙ„.', 'error')
                return render_template('429.html'), 429

            return f(*args, **kwargs)
        return decorated_function
    return decorator

def get_adaptive_limits(endpoint):
    """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø­Ø¯ÙˆØ¯ ØªÙƒÙŠÙÙŠØ© Ø­Ø³Ø¨ Ø§Ù„Ù€ endpoint"""
    limits = {
        'login': {'per_minute': 5, 'per_hour': 20},
        'register': {'per_minute': 3, 'per_hour': 10},
        'verify-email': {'per_minute': 10, 'per_hour': 30},
        'resend-verification': {'per_minute': 2, 'per_hour': 5},
        'setup-admin': {'per_minute': 2, 'per_hour': 5},
        'reset-admin-password': {'per_minute': 3, 'per_hour': 10},
        'new-order': {'per_minute': 5, 'per_hour': 50},
        'default': {'per_minute': 30, 'per_hour': 200}
    }

    for key, limit in limits.items():
        if key in endpoint:
            return limit

    return limits['default']

def scheduled_cleanup():
    """Ù…Ù‡Ù…Ø© Ø¯ÙˆØ±ÙŠØ© Ù„ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
    with app.app_context():
        cleanup_old_verification_codes()
        app.logger.info("Scheduled cleanup completed")

# ØªØ´ØºÙŠÙ„ Ø§Ù„ØªÙ†Ø¸ÙŠÙ ÙƒÙ„ 6 Ø³Ø§Ø¹Ø§Øª
scheduler.add_job(
    func=scheduled_cleanup,
    trigger=IntervalTrigger(hours=6),
    id='cleanup_job',
    name='Clean up expired verification codes',
    replace_existing=True
)

# Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ø¬Ø¯ÙˆÙ„
scheduler.start()

# Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…Ø¬Ø¯ÙˆÙ„ Ø¹Ù†Ø¯ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
atexit.register(lambda: scheduler.shutdown())

# Load environment variables (ÙÙ‚Ø· ÙÙŠ Ø§Ù„ØªØ·ÙˆÙŠØ± Ø§Ù„Ù…Ø­Ù„ÙŠ)
if os.path.exists('.env'):
    load_dotenv()

# Initialize Flask app
app = Flask(__name__)

# Configuration - Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø© Ù…Ø¹ Ù‚ÙŠÙ… Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ø¢Ù…Ù†Ø©
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY')
if not app.config['SECRET_KEY']:
    raise ValueError("SECRET_KEY environment variable is required")

# Database configuration - handle both development and production
if os.environ.get('DATABASE_URL'):
    # Production (Render) - fix postgres:// to postgresql://
    database_url = os.environ.get('DATABASE_URL')
    if database_url.startswith('postgres://'):
        database_url = database_url.replace('postgres://', 'postgresql://', 1)
    app.config['SQLALCHEMY_DATABASE_URI'] = database_url
else:
    # Development
    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///freelancer.db'

app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.config['SQLALCHEMY_ENGINE_OPTIONS'] = {
    'pool_pre_ping': True,
    'pool_recycle': 300,
    'pool_timeout': 20,
    'max_overflow': 0
}

# Mail configuration - Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
app.config['MAIL_SERVER'] = os.environ.get('MAIL_SERVER', 'smtp.gmail.com')
app.config['MAIL_PORT'] = int(os.environ.get('MAIL_PORT', 587))
app.config['MAIL_USE_TLS'] = True
app.config['MAIL_USERNAME'] = os.environ.get('MAIL_USERNAME')
app.config['MAIL_PASSWORD'] = os.environ.get('MAIL_PASSWORD')
app.config['MAIL_DEFAULT_SENDER'] = os.environ.get('MAIL_USERNAME')

# Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ
if not app.config['MAIL_USERNAME'] or not app.config['MAIL_PASSWORD']:
    print("ØªØ­Ø°ÙŠØ±: Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ØºÙŠØ± Ù…ÙƒØªÙ…Ù„Ø©")

# Initialize extensions
db = SQLAlchemy(app)
mail = Mail(app)

# Ø¥Ø¹Ø¯Ø§Ø¯ Rate Limiter Ø§Ù„ØªÙ‚Ù„ÙŠØ¯ÙŠ (ÙƒØ¨Ø¯ÙŠÙ„)
limiter = Limiter(
    key_func=get_remote_address,
    app=app,
    default_limits=["1000 per day", "200 per hour"],
    storage_uri=os.environ.get('REDIS_URL', 'memory://'),
    strategy="moving-window"
)

# ØªÙ‡ÙŠØ¦Ø© Smart Rate Limiter
smart_limiter.init_app(app)

# ØªÙ‡ÙŠØ¦Ø© Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…
telegram_system.init_app(app)

# Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª reCAPTCHA
app.config['RECAPTCHA_SITE_KEY'] = os.environ.get('RECAPTCHA_SITE_KEY', '')
app.config['RECAPTCHA_SECRET_KEY'] = os.environ.get('RECAPTCHA_SECRET_KEY', '')
app.config['CAPTCHA_SECRET'] = os.environ.get('CAPTCHA_SECRET', 'default-secret-key-change-this')

# Ù†Ø¸Ø§Ù… ØªØªØ¨Ø¹ Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ø§Ù„Ù…Ø´Ø¨ÙˆÙ‡Ø©
suspicious_sessions = defaultdict(lambda: {
    'attempts': 0,
    'last_attempt': 0,
    'suspicious_score': 0,
    'blocked_until': 0
})

def track_suspicious_session(client_ip, action_type, severity=1):
    current_time = int(time.time())

    # ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…ØµØ§Ø¯Ø± Ø§Ù„Ù…ÙˆØ«ÙˆÙ‚Ø© Ù…Ù† Ø§Ù„ØªØªØ¨Ø¹ Ø§Ù„Ù‚Ø§Ø³ÙŠ
    try:
        ip_obj = ipaddress.ip_address(client_ip)
        if ip_obj.is_private or ip_obj.is_loopback:
            app.logger.info(f"Ignoring suspicious activity from trusted IP {client_ip}: {action_type}")
            return
    except:
        pass

    session_data = suspicious_sessions[client_ip]

    # Ø²ÙŠØ§Ø¯Ø© Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª
    session_data['attempts'] += 1
    session_data['last_attempt'] = current_time
    session_data['suspicious_score'] += (severity * 0.7)  # ØªØ®ÙÙŠÙ Ø´Ø¯Ø© Ø§Ù„Ø¹Ù‚ÙˆØ¨Ø©

    # ØªØ·Ø¨ÙŠÙ‚ Ø­Ø¸Ø± ØªØ¯Ø±ÙŠØ¬ÙŠ Ø£ÙƒØ«Ø± ØªØ³Ø§Ù‡Ù„Ø§Ù‹
    if session_data['suspicious_score'] >= 25:  # Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø¹ØªØ¨Ø© Ù…Ù† 15 Ø¥Ù„Ù‰ 25
        session_data['blocked_until'] = current_time + 1800  # 30 Ø¯Ù‚ÙŠÙ‚Ø©
        app.logger.warning(f"IP {client_ip} blocked for 30 minutes due to suspicious activity")
    elif session_data['suspicious_score'] >= 15:  # Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø¹ØªØ¨Ø© Ù…Ù† 8 Ø¥Ù„Ù‰ 15
        session_data['blocked_until'] = current_time + 300  # 5 Ø¯Ù‚Ø§Ø¦Ù‚
        app.logger.warning(f"IP {client_ip} blocked for 5 minutes due to suspicious activity")

    # ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ù†Ù‚Ø§Ø· ØªØ¯Ø±ÙŠØ¬ÙŠØ§Ù‹
    time_since_last = current_time - session_data.get('last_decay', current_time)
    if time_since_last > 300:  # ÙƒÙ„ 5 Ø¯Ù‚Ø§Ø¦Ù‚
        session_data['suspicious_score'] = max(0, session_data['suspicious_score'] - 2)
        session_data['last_decay'] = current_time

    app.logger.info(f"Suspicious activity tracked for {client_ip}: {action_type} (Score: {session_data['suspicious_score']:.1f})")

def is_session_blocked(client_ip):
    """ÙØ­Øµ Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø¬Ù„Ø³Ø© Ù…Ø­Ø¸ÙˆØ±Ø© Ù…Ø¹ Ø§Ø³ØªØ«Ù†Ø§Ø¡Ø§Øª Ù„Ù„Ù…ØµØ§Ø¯Ø± Ø§Ù„Ù…ÙˆØ«ÙˆÙ‚Ø©"""
    current_time = int(time.time())
    session_data = suspicious_sessions[client_ip]

    # Ø§Ø³ØªØ«Ù†Ø§Ø¡ Ù„Ù„Ù€ localhost ÙˆØ§Ù„Ø´Ø¨ÙƒØ§Øª Ø§Ù„Ø®Ø§ØµØ©
    try:
        ip_obj = ipaddress.ip_address(client_ip)
        if ip_obj.is_private or ip_obj.is_loopback:
            return False, 0
    except:
        pass

    if session_data['blocked_until'] > current_time:
        return True, session_data['blocked_until'] - current_time

    return False, 0

# Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù€ endpoints Ø§Ù„Ù…Ø³ØªØ«Ù†Ø§Ø© Ù…Ù† Captcha
EXEMPT_ENDPOINTS = ['/ping', '/health', '/static']

login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'login'
login_manager.login_message = 'Ù…Ù† ÙØ¶Ù„Ùƒ Ø³Ø¬Ù„ Ø¯Ø®ÙˆÙ„Ùƒ Ø£ÙˆÙ„Ø§Ù‹'

# Ø¥Ø¹Ø¯Ø§Ø¯ Ù†Ø¸Ø§Ù… Ø§Ù„Ø³Ø¬Ù„Ø§Øª
if not app.debug:
    if not os.path.exists('logs'):
        os.mkdir('logs')
    file_handler = RotatingFileHandler('logs/app.log', maxBytes=10240, backupCount=10)
    file_handler.setFormatter(logging.Formatter(
        '%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'
    ))
    file_handler.setLevel(logging.INFO)
    app.logger.addHandler(file_handler)
    app.logger.setLevel(logging.INFO)
    app.logger.info('Application startup')

# Models
class User(UserMixin, db.Model):
    __tablename__ = 'users'  # Explicit table name

    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(100), unique=True, nullable=False)
    password_hash = db.Column(db.String(200), nullable=False)
    is_verified = db.Column(db.Boolean, default=False)
    is_admin = db.Column(db.Boolean, default=False)
    verification_code = db.Column(db.String(6))
    code_expiry = db.Column(db.DateTime)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

    # Define relationship
    orders = db.relationship('Order', backref='user', lazy=True)

    # Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ù…Ø¹ default values Ø¢Ù…Ù†Ø©
    whatsapp = db.Column(db.String(20), default='')
    preferred_platform = db.Column(db.String(10), default='')
    preferred_payment = db.Column(db.String(50), default='')
    ea_email = db.Column(db.String(100), default='')
    telegram_id = db.Column(db.String(50), default='')
    telegram_username = db.Column(db.String(50), default='')
    last_profile_update = db.Column(db.DateTime)

    # Ø®Ø§ØµÙŠØ© Ù…Ø­Ø³ÙˆØ¨Ø© Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† column Ù„ØªØ¬Ù†Ø¨ Ù…Ø´Ø§ÙƒÙ„ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    @property
    def profile_completed(self):
        """Ø­Ø³Ø§Ø¨ Ø­Ø§Ù„Ø© Ø§ÙƒØªÙ…Ø§Ù„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ§Ù‹"""
        required_fields = [self.whatsapp, self.preferred_platform, self.preferred_payment]
        return all(field and field.strip() for field in required_fields)

    def get_profile_completion_data(self):
        """Ø¥Ø±Ø¬Ø§Ø¹ Ø¨ÙŠØ§Ù†Ø§Øª ØªÙØµÙŠÙ„ÙŠØ© Ø¹Ù† Ø§ÙƒØªÙ…Ø§Ù„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ"""
        steps = {
            'whatsapp': bool(self.whatsapp and self.whatsapp.strip()),
            'platform': bool(self.preferred_platform and self.preferred_platform.strip()),
            'payment': bool(self.preferred_payment and self.preferred_payment.strip()),
            'ea_email': bool(self.ea_email and self.ea_email.strip()),
            'telegram': bool(self.telegram_id and self.telegram_id.strip()),
        }

        completed_count = sum(1 for completed in steps.values() if completed)
        total_count = len(steps)
        percentage = round((completed_count / total_count) * 100)

        return {
            'steps': steps,
            'completed_count': completed_count,
            'total_count': total_count,
            'percentage': percentage,
            'is_completed': self.profile_completed
        }

class Order(db.Model):
    __tablename__ = 'orders'  # Explicit table name

    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    platform = db.Column(db.String(20), nullable=False)
    payment_method = db.Column(db.String(50), nullable=False)
    coins_amount = db.Column(db.Integer, nullable=False)
    status = db.Column(db.String(20), default='pending')
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

    # Ø­Ù‚ÙˆÙ„ Ø¥Ø¶Ø§ÙÙŠØ© Ù„Ù„Ø·Ù„Ø¨Ø§Øª Ù…Ø¹ default values Ø¢Ù…Ù†Ø©
    ea_email = db.Column(db.String(100), default='')
    ea_password = db.Column(db.String(200), default='')  # Ù…Ø´ÙØ±Ø©
    backup_codes = db.Column(db.Text, default='')  # Ù…Ø´ÙØ±Ø© Ø£ÙŠØ¶Ø§Ù‹
    transfer_type = db.Column(db.String(20), default='normal')  # normal, instant
    notes = db.Column(db.Text, default='')
    price = db.Column(db.Float, default=0.0)
    phone_number = db.Column(db.String(20), default='')
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

@app.context_processor
def inject_datetime():
    """Ø¥Ø¶Ø§ÙØ© Ø¯ÙˆØ§Ù„ Ø§Ù„ØªØ§Ø±ÙŠØ® Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨"""
    return {
        'moment': lambda: datetime,
        'now': datetime.now(),
        'datetime': datetime
    }

@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))

def is_valid_email(email):
    """Check if email is from trusted domains"""
    trusted_domains = ['gmail.com', 'hotmail.com', 'outlook.com', 'icloud.com', 'yahoo.com']
    try:
        domain = email.split('@')[1].lower()
        return domain in trusted_domains
    except:
        return False

def generate_verification_code():
    """Generate 6-digit verification code"""
    return ''.join(random.choices(string.digits, k=6))

def send_verification_email(email, code):
    """Send verification email with OTP"""
    try:
        if not app.config['MAIL_USERNAME']:
            print("Mail not configured, skipping email send")
            return True  # For development without mail config

        msg = Message(
            subject='ÙƒÙˆØ¯ Ø§Ù„ØªÙØ¹ÙŠÙ„ Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„ÙØ±ÙŠÙ„Ø§Ù†Ø³Ø±',
            recipients=[email],
            body=f'''
Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù…ÙˆÙ‚Ø¹ Ø§Ù„ÙØ±ÙŠÙ„Ø§Ù†Ø³Ø±!

ÙƒÙˆØ¯ Ø§Ù„ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ù‡Ùˆ: {code}

Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ ØµØ§Ù„Ø­ Ù„Ù…Ø¯Ø© 10 Ø¯Ù‚Ø§Ø¦Ù‚ ÙÙ‚Ø·.

Ø´ÙƒØ±Ø§Ù‹ Ù„Ùƒ!
            '''
        )
        mail.send(msg)
        return True
    except Exception as e:
        print(f"Error sending email: {e}")
# Ø§Ù„Ø³Ø·Ø± Ø§Ù„Ø°ÙŠ ÙŠØ³Ø¨Ù‚ Ø§Ù„ÙƒØªÙ„Ø© Ù…Ø¨Ø§Ø´Ø±Ø©:
        return True  # Don't block registration if email fails

#  ØªØ­Ø¯ÙŠØ« Ø¯Ø§Ù„Ø© verify_recaptcha_advanced
def verify_recaptcha_advanced(token, request):
    if not app.config['RECAPTCHA_SECRET_KEY']:
        app.logger.warning("reCAPTCHA not configured - allowing request to pass")
        return {'success': True, 'penalty': 0}

    if not token:
        app.logger.warning("No reCAPTCHA token provided")
        return {'success': False, 'penalty': 4}

    try:
        response = requests.post(
            'https://www.google.com/recaptcha/api/siteverify',
            data={
                'secret': app.config['RECAPTCHA_SECRET_KEY'],
                'response': token,
                'remoteip': get_remote_address()
            },
            timeout=10
        )
        result = response.json()

        success = result.get('success', False)
        score = result.get('score', 0)
        action = result.get('action', 'unknown')
        hostname = result.get('hostname', '')
        challenge_ts = result.get('challenge_ts', '')

        app.logger.info(f"reCAPTCHA result - Success: {success}, Score: {score}, Action: {action}")

        penalty_score = 0

        if not success:
            penalty_score = 5
            app.logger.warning(f"reCAPTCHA failed - Errors: {result.get('error-codes', [])}")
            return {'success': False, 'penalty': penalty_score}

        # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù†Ù‚Ø§Ø· Ù…Ø¹ Ù…Ø¹Ø§ÙŠÙŠØ± Ù…ØªÙˆØ§Ø²Ù†Ø©
        if score < 0.1:
            penalty_score = 5  # Ù…Ø´Ø¨ÙˆÙ‡ Ø¬Ø¯Ø§Ù‹
        elif score < 0.3:
            penalty_score = 3  # Ù…Ø´Ø¨ÙˆÙ‡
        elif score < 0.5:
            penalty_score = 2  # Ø­Ø°Ø±
        elif score < 0.7:
            penalty_score = 1  # Ø­Ø°Ø± Ù‚Ù„ÙŠÙ„
        else:
            penalty_score = 0  # Ø¢Ù…Ù†

        # ÙØ­Øµ Action consistency Ù…Ø®ÙÙ
        expected_actions = ['login', 'register', 'submit']
        if action not in expected_actions and action != 'unknown':
            penalty_score += 1
            app.logger.warning(f"Unexpected reCAPTCHA action: {action}")

        # ÙØ­Øµ Ø§Ù„Ù€ hostname Ù…Ø®ÙÙ
        expected_hostnames = ['senioraa.onrender.com', 'localhost', '127.0.0.1']
        if hostname and not any(host in hostname for host in expected_hostnames):
            penalty_score += 1
            app.logger.warning(f"Unexpected hostname in reCAPTCHA: {hostname}")

        # ÙØ­Øµ Ø§Ù„ØªÙˆÙ‚ÙŠØª Ù…Ø®ÙÙ
        if challenge_ts:
            try:
                from datetime import datetime

                import dateutil.parser
                challenge_time = dateutil.parser.parse(challenge_ts)
                current_time = datetime.utcnow()
                time_diff = (current_time - challenge_time).total_seconds()

                if time_diff > 600:  # Ø£ÙƒØ«Ø± Ù…Ù† 10 Ø¯Ù‚Ø§Ø¦Ù‚
                    penalty_score += 1
                    app.logger.warning(f"Old reCAPTCHA token used: {time_diff}s old")
            except:
                penalty_score += 0  # ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡

        # Ø§Ù„Ø¹ØªØ¨Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ø§Ù„Ù…ØªÙˆØ§Ø²Ù†Ø©
        final_success = penalty_score < 4

        app.logger.info(f"reCAPTCHA advanced verification - Final: {final_success}, Penalty: {penalty_score}")

        return {'success': final_success, 'penalty': penalty_score}

    except Exception as e:
        app.logger.error(f"reCAPTCHA verification error: {e}")
        return {'success': True, 'penalty': 0}

# Ø§Ù„Ø³Ø·Ø± Ø§Ù„Ø°ÙŠ ÙŠÙ„ÙŠ Ø§Ù„ÙƒØªÙ„Ø© Ù…Ø¨Ø§Ø´Ø±Ø©:
def check_honeypot(form_data):
    """ÙØ­Øµ Honeypot fields (ÙØ®Ø§Ø® Ø§Ù„Ø¨ÙˆØªØ§Øª)"""
    honeypot_fields = ['website', 'url', 'homepage', 'company']

    for field in honeypot_fields:
        if form_data.get(field, '').strip():
            app.logger.warning(f"Honeypot field '{field}' was filled")
            return False

    return True

def generate_time_token():
    """Ø¥Ù†Ø´Ø§Ø¡ Ø±Ù…Ø² Ù…Ø¤Ù‚Øª Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙˆÙ‚Øª"""
    timestamp = str(int(time.time()))
    secret = app.config['CAPTCHA_SECRET']
# Ø§Ù„Ø³Ø·Ø± Ø§Ù„Ø°ÙŠ ÙŠØ³Ø¨Ù‚ Ø§Ù„ÙƒØªÙ„Ø© Ù…Ø¨Ø§Ø´Ø±Ø©:
    return hashlib.md5((timestamp + secret).encode()).hexdigest(), timestamp

# ØªØ­Ø¯ÙŠØ« Ø¯Ø§Ù„Ø© verify_time_token
def verify_time_token_advanced(token, timestamp, form_data):
    """Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ù…ØªÙ‚Ø¯Ù… Ù…Ù† Ø§Ù„Ø±Ù…Ø² Ø§Ù„Ù…Ø¤Ù‚Øª Ù…Ø¹ ØªØ­Ù„ÙŠÙ„ Ø³Ù„ÙˆÙƒÙŠ"""
    try:
        current_time = int(time.time())
        form_time = int(timestamp)
        time_diff = current_time - form_time

        # ØªØ­Ù„ÙŠÙ„ ÙˆÙ‚Øª Ù…Ù„Ø¡ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬
        if time_diff < 2:  # Ø£Ù‚Ù„ Ù…Ù† Ø«Ø§Ù†ÙŠØªÙŠÙ† = Ù…Ø´Ø¨ÙˆÙ‡ Ø¬Ø¯Ø§Ù‹
            app.logger.warning(f"Form submitted too quickly: {time_diff}s")
            return False

        if time_diff > 3600:  # Ø£ÙƒØ«Ø± Ù…Ù† Ø³Ø§Ø¹Ø© = Ù…Ù†ØªÙ‡ÙŠ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©
            app.logger.warning(f"Form token expired: {time_diff}s old")
            return False

        # ÙØ­Øµ Ø§Ù„ØªÙˆÙ‚ÙŠØª Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ÙØ¯Ø®Ù„Ø©
        email = form_data.get('email', '')
        password = form_data.get('password', '')

        # ØªÙ‚Ø¯ÙŠØ± Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ù„Ù…Ù„Ø¡ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬
        estimated_time = 0
        if email:
            estimated_time += len(email) * 0.1  # 100ms Ù„ÙƒÙ„ Ø­Ø±Ù
        if password:
            estimated_time += len(password) * 0.15  # 150ms Ù„ÙƒÙ„ Ø­Ø±Ù

        estimated_time += 3  # ÙˆÙ‚Øª Ø¥Ø¶Ø§ÙÙŠ Ù„Ù„Ù‚Ø±Ø§Ø¡Ø© ÙˆØ§Ù„ØªÙÙƒÙŠØ±

        if time_diff < estimated_time:
            app.logger.warning(f"Form filled faster than humanly possible: {time_diff}s vs estimated {estimated_time}s")
            return False

        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø±Ù…Ø²
        secret = app.config['CAPTCHA_SECRET']
        expected_token = hashlib.md5((timestamp + secret).encode()).hexdigest()

        if token != expected_token:
            app.logger.warning("Invalid time token signature")
            return False

        return True

    except Exception as e:
        app.logger.error(f"Time token verification error: {e}")
        return False

# Ø§Ù„Ø³Ø·Ø± Ø§Ù„Ø°ÙŠ ÙŠÙ„ÙŠ Ø§Ù„ÙƒØªÙ„Ø© Ù…Ø¨Ø§Ø´Ø±Ø©:
def is_bot_behavior(request):
    """ÙØ­Øµ Ø³Ù„ÙˆÙƒ Ø§Ù„Ø¨ÙˆØª"""
    # ÙØ­Øµ User-Agent
    user_agent = request.headers.get('User-Agent', '').lower()
    bot_indicators = ['bot', 'crawler', 'spider', 'scraper', 'automated']

    if any(indicator in user_agent for indicator in bot_indicators):
        return True

    # ÙØ­Øµ Ø§Ù„Ù€ headers Ø§Ù„Ù…Ø´Ø¨ÙˆÙ‡Ø©
    if not request.headers.get('Accept'):
        return True

    if not request.headers.get('Accept-Language'):
        return True

# Ø§Ù„Ø³Ø·Ø± Ø§Ù„Ø°ÙŠ ÙŠØ³Ø¨Ù‚ Ø§Ù„ÙƒØªÙ„Ø© Ù…Ø¨Ø§Ø´Ø±Ø©:
    return False

# ØªØ­Ø¯ÙŠØ« Ø¯Ø§Ù„Ø© comprehensive_captcha_check
def comprehensive_captcha_check(request, form_data):
    client_ip = get_remote_address()

    # ÙØ­Øµ Ø§Ù„Ù€ endpoints Ø§Ù„Ù…Ø³ØªØ«Ù†Ø§Ø©
    if any(request.path.startswith(endpoint) for endpoint in EXEMPT_ENDPOINTS):
        return True

    # ØªØ­Ø¯ÙŠØ¯ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø«Ù‚Ø©
    trust_level = get_trust_level(request)

    # Ø§Ù„Ù…ØµØ§Ø¯Ø± Ø¹Ø§Ù„ÙŠØ© Ø§Ù„Ø«Ù‚Ø© ØªÙ…Ø± Ø¨ÙØ­ÙˆØµØ§Øª Ù…Ø®ÙÙØ©
    if trust_level == 'high':
        app.logger.info(f"High trust request from {client_ip} - applying relaxed checks")

        # ÙØ­Øµ Honeypot ÙÙ‚Ø· Ù„Ù„Ù…ØµØ§Ø¯Ø± Ø¹Ø§Ù„ÙŠØ© Ø§Ù„Ø«Ù‚Ø©
        if not check_honeypot(form_data):
            track_suspicious_session(client_ip, 'honeypot_hit', 3)  # Ø¹Ù‚ÙˆØ¨Ø© Ù…Ø®ÙÙØ©
            app.logger.warning(f"Honeypot check failed for trusted IP: {client_ip}")
            return False

        # ÙØ­Øµ reCAPTCHA Ù…Ø®ÙÙ Ù„Ù„Ù…ØµØ§Ø¯Ø± Ø§Ù„Ù…ÙˆØ«ÙˆÙ‚Ø©
        recaptcha_token = form_data.get('g-recaptcha-response', '')
        if recaptcha_token:
            recaptcha_result = verify_recaptcha_advanced(recaptcha_token, request)
            if not recaptcha_result['success'] and recaptcha_result['penalty'] > 4:
                app.logger.warning(f"reCAPTCHA failed for trusted IP {client_ip} with high penalty: {recaptcha_result['penalty']}")
                return False

        return True

    # Ø§Ù„Ù…ØµØ§Ø¯Ø± Ù…ØªÙˆØ³Ø·Ø© Ø§Ù„Ø«Ù‚Ø©
    elif trust_level == 'medium':
        app.logger.info(f"Medium trust request from {client_ip} - applying moderate checks")

        # ÙØ­Øµ Ø§Ù„Ø­Ø¸Ø± Ø§Ù„Ù…Ø¤Ù‚Øª
        is_blocked, remaining_time = is_session_blocked(client_ip)
        if is_blocked:
            app.logger.warning(f"Request from blocked session {client_ip}")
            return False

        # ÙØ­Øµ Honeypot
        if not check_honeypot(form_data):
            track_suspicious_session(client_ip, 'honeypot_hit', 5)
            app.logger.warning(f"Honeypot check failed for IP: {client_ip}")
            return False

        # ÙØ­Øµ Time Token Ù…Ø®ÙÙ
        time_token = form_data.get('time_token', '')
        timestamp = form_data.get('timestamp', '')

        if not verify_time_token(time_token, timestamp):
            track_suspicious_session(client_ip, 'invalid_time_token', 2)
            app.logger.warning(f"Time token verification failed for IP: {client_ip}")
            return False

        # ÙØ­Øµ reCAPTCHA
        recaptcha_token = form_data.get('g-recaptcha-response', '')
        if recaptcha_token:
            recaptcha_result = verify_recaptcha_advanced(recaptcha_token, request)
            if not recaptcha_result['success']:
                track_suspicious_session(client_ip, 'recaptcha_failed', recaptcha_result['penalty'])
                app.logger.warning(f"reCAPTCHA verification failed for IP: {client_ip}")
                return False
        else:
            track_suspicious_session(client_ip, 'missing_recaptcha', 2)
            app.logger.warning(f"No reCAPTCHA token provided from {client_ip}")
            return False

        return True

    # Ø§Ù„Ù…ØµØ§Ø¯Ø± Ù…Ù†Ø®ÙØ¶Ø© Ø§Ù„Ø«Ù‚Ø© - ÙØ­Øµ ÙƒØ§Ù…Ù„
    else:
        app.logger.info(f"Low trust request from {client_ip} - applying full checks")

        # ÙØ­Øµ Ø§Ù„Ø­Ø¸Ø± Ø§Ù„Ù…Ø¤Ù‚Øª
        is_blocked, remaining_time = is_session_blocked(client_ip)
        if is_blocked:
            app.logger.warning(f"Request from blocked session {client_ip}")
            return False

        # ÙØ­Øµ VPN/Proxy Ù…Ø®ÙÙ
        if not detect_vpn_proxy(request):
            track_suspicious_session(client_ip, 'vpn_proxy_detected', 4)  # Ø¹Ù‚ÙˆØ¨Ø© Ù…Ø®ÙÙØ©
            app.logger.warning(f"VPN/Proxy detected from {client_ip}")
            return False

        # ÙØ­Øµ Browser Automation Ù…Ø®ÙÙ
        if not detect_automation(request):
            track_suspicious_session(client_ip, 'automation_detected', 5)  # Ø¹Ù‚ÙˆØ¨Ø© Ù…Ø®ÙÙØ©
            app.logger.warning(f"Browser automation detected from {client_ip}")
            return False

        # ÙØ­Øµ Ø³Ù„ÙˆÙƒ Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
        if is_bot_behavior(request):
            track_suspicious_session(client_ip, 'bot_behavior', 2)
            app.logger.warning(f"Bot behavior detected from {client_ip}")
            return False

        # ÙØ­Øµ Honeypot
        if not check_honeypot(form_data):
            track_suspicious_session(client_ip, 'honeypot_hit', 8)
            app.logger.warning(f"Honeypot check failed for IP: {client_ip}")
            return False

        # ÙØ­Øµ Time Token
        time_token = form_data.get('time_token', '')
        timestamp = form_data.get('timestamp', '')

        if not verify_time_token_advanced(time_token, timestamp, form_data):
            track_suspicious_session(client_ip, 'invalid_time_token', 3)
            app.logger.warning(f"Advanced time token verification failed for IP: {client_ip}")
            return False

        # ÙØ­Øµ reCAPTCHA
        recaptcha_token = form_data.get('g-recaptcha-response', '')
        if recaptcha_token:
            recaptcha_result = verify_recaptcha_advanced(recaptcha_token, request)
            if not recaptcha_result['success']:
                track_suspicious_session(client_ip, 'recaptcha_failed', recaptcha_result['penalty'])
                app.logger.warning(f"Advanced reCAPTCHA verification failed for IP: {client_ip}")
                return False
        else:
            track_suspicious_session(client_ip, 'missing_recaptcha', 3)
            app.logger.warning(f"No reCAPTCHA token provided from {client_ip}")
            return False

        # ÙØ­Øµ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø³Ù„ÙˆÙƒÙŠ Ù…Ø®ÙÙ
def advanced_behavioral_analysis(form_data, request):
    """ØªØ­Ù„ÙŠÙ„ Ø³Ù„ÙˆÙƒÙŠ Ù…ØªÙ‚Ø¯Ù… Ù„Ù„ÙƒØ´Ù Ø¹Ù† Ø§Ù„Ø¨ÙˆØªØ§Øª"""
    suspicious_score = 0

    try:
        # 1. ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ
        email = form_data.get('email', '').lower()
        if email:
            # ÙØ­Øµ Ø§Ù„Ù†Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ù…Ø¤Ù‚ØªØ©
            suspicious_domains = ['tempmail', '10minutemail', 'guerrillamail']
            if any(domain in email for domain in suspicious_domains):
                suspicious_score += 3

            # ÙØ­Øµ Ø£Ù†Ù…Ø§Ø· Ù…Ø´Ø¨ÙˆÙ‡Ø©
            if '+' in email.split('@')[0]:
                suspicious_score += 1

        # 2. ØªØ­Ù„ÙŠÙ„ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
        password = form_data.get('password', '')
        if password:
            common_passwords = ['123456', 'password', 'test123']
            if password in common_passwords:
                suspicious_score += 2

        # 3. ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªÙˆÙ‚ÙŠØª
        timestamp = form_data.get('timestamp', '')
        if timestamp:
            try:
                form_time = int(timestamp)
                current_time = int(time.time())
                filling_time = current_time - form_time

                if filling_time < 3:  # Ø£Ù‚Ù„ Ù…Ù† 3 Ø«ÙˆØ§Ù†
                    suspicious_score += 3
            except:
                suspicious_score += 1

        # 4. ÙØ­Øµ User-Agent
        user_agent = request.headers.get('User-Agent', '').lower()
        bot_indicators = ['bot', 'crawler', 'python', 'curl']
        if any(indicator in user_agent for indicator in bot_indicators):
            suspicious_score += 2

        return min(suspicious_score, 10)  # Ø­Ø¯ Ø£Ù‚ØµÙ‰ 10 Ù†Ù‚Ø§Ø·

    except Exception as e:
        app.logger.error(f"Behavioral analysis error: {e}")
        return 0

# Ø§Ù„Ø¢Ù† ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¯Ø§Ù„Ø©
behavioral_score = advanced_behavioral_analysis(form_data, request)
if behavioral_score > 7:  # Ø¹ØªØ¨Ø© Ø£Ø¹Ù„Ù‰
            track_suspicious_session(client_ip, 'suspicious_behavior', behavioral_score)
            app.logger.warning(f"Suspicious behavioral analysis for IP: {client_ip}, score: {behavioral_score}")
            return False

            return True

# Ø§Ù„Ø³Ø·Ø± Ø§Ù„Ø°ÙŠ ÙŠÙ„ÙŠ Ø§Ù„ÙƒØªÙ„Ø© Ù…Ø¨Ø§Ø´Ø±Ø©:
def generate_device_fingerprint_advanced(request):
    """Ø¥Ù†Ø´Ø§Ø¡ Ø¨ØµÙ…Ø© Ø¬Ù‡Ø§Ø² Ù…ØªÙ‚Ø¯Ù…Ø© Ù„Ù„ÙƒØ´Ù Ø¹Ù† Ø§Ù„ØªÙ„Ø§Ø¹Ø¨"""
    ip = get_remote_address()

    # Ø¬Ù…Ø¹ Ø¨ÙŠØ§Ù†Ø§Øª Ø£ÙƒØ«Ø± ØªÙØµÙŠÙ„Ø§Ù‹
    advanced_data = {
        'user_agent': request.headers.get('User-Agent', '')[:200],
        'accept': request.headers.get('Accept', '')[:100],
        'accept_language': request.headers.get('Accept-Language', '')[:50],
        'accept_encoding': request.headers.get('Accept-Encoding', '')[:50],
        'connection': request.headers.get('Connection', '')[:20],
        'upgrade_insecure_requests': request.headers.get('Upgrade-Insecure-Requests', ''),
        'sec_fetch_site': request.headers.get('Sec-Fetch-Site', ''),
        'sec_fetch_mode': request.headers.get('Sec-Fetch-Mode', ''),
        'sec_fetch_user': request.headers.get('Sec-Fetch-User', ''),
        'sec_fetch_dest': request.headers.get('Sec-Fetch-Dest', ''),
        'cache_control': request.headers.get('Cache-Control', '')[:50],
        'pragma': request.headers.get('Pragma', ''),
        'dnt': request.headers.get('DNT', ''),
        'te': request.headers.get('TE', ''),
        'sec_ch_ua': request.headers.get('Sec-CH-UA', '')[:100],
        'sec_ch_ua_mobile': request.headers.get('Sec-CH-UA-Mobile', ''),
        'sec_ch_ua_platform': request.headers.get('Sec-CH-UA-Platform', ''),
        'viewport': request.headers.get('Viewport-Width', '')
    }

    # ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªÙ†Ø§Ù‚Ø¶Ø§Øª ÙÙŠ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    inconsistency_score = 0

    # ÙØ­Øµ User-Agent vs Sec-CH-UA
    ua = advanced_data['user_agent'].lower()
    sec_ua = advanced_data['sec_ch_ua'].lower()

    if 'chrome' in ua and 'chrome' not in sec_ua and sec_ua:
        inconsistency_score += 3
    elif 'firefox' in ua and 'chrome' in sec_ua:
        inconsistency_score += 3

    # ÙØ­Øµ Mobile indicators
    is_mobile_ua = any(mobile in ua for mobile in ['mobile', 'android', 'iphone'])
    sec_mobile = advanced_data['sec_ch_ua_mobile'] == '?1'

    if is_mobile_ua != sec_mobile and advanced_data['sec_ch_ua_mobile']:
        inconsistency_score += 2

    # ÙØ­Øµ Platform consistency
    platform = advanced_data['sec_ch_ua_platform'].lower()
    if 'windows' in ua and 'android' in platform:
        inconsistency_score += 3
    elif 'mac' in ua and 'windows' in platform:
        inconsistency_score += 3

    # ÙØ­Øµ Headers Ø§Ù„Ù…ÙÙ‚ÙˆØ¯Ø© Ø§Ù„Ù…Ø´Ø¨ÙˆÙ‡Ø©
    modern_headers = ['sec_fetch_site', 'sec_fetch_mode', 'sec_ch_ua']
    missing_modern = sum(1 for h in modern_headers if not advanced_data[h])

    if missing_modern >= 2 and 'chrome' in ua:
        inconsistency_score += 2

    # Ø­Ø³Ø§Ø¨ hash Ø§Ù„Ø¨ØµÙ…Ø©
    fingerprint_string = '|'.join(str(v) for v in advanced_data.values())
    fingerprint_hash = hashlib.sha256(fingerprint_string.encode()).hexdigest()[:16]

    advanced_data['inconsistency_score'] = inconsistency_score

    return fingerprint_hash, advanced_data

##   Ø¥Ø¶Ø§ÙØ© Ø¯Ø§Ù„Ø© detect_automation
def detect_automation(request):
    """ÙƒØ´Ù Ø£Ø¯ÙˆØ§Øª Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¢Ù„ÙŠ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…"""
    automation_score = 0
    client_ip = get_remote_address()

    # ÙØ­Øµ WebDriver properties (ÙŠØªÙ… Ø¥Ø¶Ø§ÙØªÙ‡Ø§ ÙÙŠ JavaScript)
    automation_indicators = request.form.get('automation_check', '')
    if automation_indicators:
        indicators = json.loads(automation_indicators) if automation_indicators else {}

        # ÙØ­Øµ ÙˆØ¬ÙˆØ¯ WebDriver
        if indicators.get('webdriver', False):
            automation_score += 5
            app.logger.warning(f"WebDriver detected from {client_ip}")

        # ÙØ­Øµ Ø£Ø¯ÙˆØ§Øª Ø§Ù„ØªØ·ÙˆÙŠØ±
        if indicators.get('devtools', False):
            automation_score += 3

        # ÙØ­Øµ Ø§Ù„Ù€ plugins Ø§Ù„Ù…Ø´Ø¨ÙˆÙ‡Ø©
        if indicators.get('suspicious_plugins', 0) > 0:
            automation_score += 2

        # ÙØ­Øµ Ø³Ù„ÙˆÙƒ Ø§Ù„Ù…ØªØµÙØ­ ØºÙŠØ± Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠ
        if indicators.get('screen_inconsistency', False):
            automation_score += 4

        # ÙØ­Øµ Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ events Ø·Ø¨ÙŠØ¹ÙŠØ©
        if indicators.get('no_mouse_movement', False):
            automation_score += 3

    # ÙØ­Øµ headers Ù…Ø´Ø¨ÙˆÙ‡Ø© Ù„Ù„Ù€ automation
    user_agent = request.headers.get('User-Agent', '').lower()
    automation_keywords = [
        'headless', 'phantomjs', 'selenium', 'webdriver',
        'chrome-lighthouse', 'chromedriver', 'geckodriver',
        'puppeteer', 'playwright'
    ]

    for keyword in automation_keywords:
        if keyword in user_agent:
            automation_score += 4
            app.logger.warning(f"Automation keyword '{keyword}' in UA from {client_ip}")

    # ÙØ­Øµ Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ referrer Ø·Ø¨ÙŠØ¹ÙŠ
    referrer = request.headers.get('Referer', '')
    if not referrer and request.method == 'POST':
        automation_score += 2

    app.logger.info(f"Automation detection score for {client_ip}: {automation_score}")

# Ø§Ù„Ø³Ø·Ø± Ø§Ù„Ø³Ø§Ø¨Ù‚:
    return automation_score < 8  # Ø§Ù„Ø³Ù…Ø§Ø­ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø£Ù‚Ù„ Ù…Ù† 8 Ù†Ù‚Ø§Ø·

def is_trusted_request(request):
    client_ip = get_remote_address()
    user_agent = request.headers.get('User-Agent', '').lower()

    # IPs Ù…ÙˆØ«ÙˆÙ‚Ø©
    trusted_ips = ['127.0.0.1', 'localhost']
    if any(ip in client_ip for ip in trusted_ips):
        return True

    # User-Agents Ù…ÙˆØ«ÙˆÙ‚Ø© (Ù…ØªØµÙØ­Ø§Øª Ø­Ù‚ÙŠÙ‚ÙŠØ©)
    trusted_browsers = [
        'chrome/', 'firefox/', 'safari/', 'edge/', 'opera/',
        'miuibrowser/', 'samsungbrowser/', 'yabrowser/'
    ]

    if any(browser in user_agent for browser in trusted_browsers):
        # ÙØ­Øµ Ø¥Ø¶Ø§ÙÙŠ Ù„Ù„Ù…ØªØµÙØ­Ø§Øª Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ©
        required_headers = ['accept', 'accept-language', 'accept-encoding']
        missing_headers = sum(1 for h in required_headers if not request.headers.get(h.replace('-', '_').title()))

        if missing_headers == 0:
            return True

    return False

def get_trust_level(request):
    if is_trusted_request(request):
        return 'high'

    client_ip = get_remote_address()
    try:
        ip_obj = ipaddress.ip_address(client_ip)
        if ip_obj.is_private or ip_obj.is_loopback:
            return 'medium'
    except:
        pass

    return 'low'

#  Ø¥Ø¶Ø§ÙØ© Ø¯Ø§Ù„Ø© detect_vpn_proxy Ø¬Ø¯ÙŠØ¯Ø© ÙÙŠ Ù…Ù„Ù app.py
def detect_vpn_proxy(request):
    """ÙƒØ´Ù VPN ÙˆØ§Ù„Ù€ Proxy Ø§Ù„Ù…ØªÙ‚Ø¯Ù…"""
    client_ip = get_remote_address()
    vpn_score = 0

    # Ù‚Ø§Ø¦Ù…Ø© Ù…Ø¤Ø´Ø±Ø§Øª VPN/Proxy
    vpn_indicators = []

    # ÙØ­Øµ headers Ù…Ø´Ø¨ÙˆÙ‡Ø© Ù„Ù„Ù€ proxy
    proxy_headers = [
        'HTTP_X_FORWARDED_FOR', 'HTTP_X_REAL_IP', 'HTTP_X_CLUSTER_CLIENT_IP',
        'HTTP_CLIENT_IP', 'HTTP_FORWARDED_FOR', 'HTTP_FORWARDED',
        'HTTP_VIA', 'HTTP_X_FORWARDED_PROTO'
    ]

    for header in proxy_headers:
        if request.environ.get(header):
            vpn_score += 1
            vpn_indicators.append(f"proxy_header_{header}")

    # ÙØ­Øµ User-Agent patterns Ù„Ù„Ù€ VPN clients
    user_agent = request.headers.get('User-Agent', '').lower()
    vpn_patterns = [
        'openvpn', 'nordvpn', 'expressvpn', 'cyberghost', 'protonvpn',
        'surfshark', 'tunnelbear', 'hotspot shield', 'windscribe'
    ]

    for pattern in vpn_patterns:
        if pattern in user_agent:
            vpn_score += 3
            vpn_indicators.append(f"vpn_ua_{pattern}")

    # ÙØ­Øµ timezone inconsistency
    timezone_header = request.headers.get('X-Timezone', '')
    accept_language = request.headers.get('Accept-Language', '')

    if timezone_header and accept_language:
        # ØªØ­Ù„ÙŠÙ„ Ø¨Ø³ÙŠØ· Ù„Ù„ØªÙ†Ø§Ù‚Ø¶ Ø§Ù„Ø¬ØºØ±Ø§ÙÙŠ
        if ('us' in accept_language.lower() and 'europe' in timezone_header.lower()) or \
           ('gb' in accept_language.lower() and 'america' in timezone_header.lower()):
            vpn_score += 2
            vpn_indicators.append("timezone_mismatch")

    # ÙØ­Øµ DNS leaks (Ø¥Ø°Ø§ ØªÙˆÙØ±Øª Ù…Ø¹Ù„ÙˆÙ…Ø§Øª)
    x_real_ip = request.headers.get('X-Real-IP', '')
    x_forwarded_for = request.headers.get('X-Forwarded-For', '')

    if x_real_ip and x_forwarded_for and x_real_ip != x_forwarded_for:
        vpn_score += 2
        vpn_indicators.append("ip_mismatch")

    # ÙØ­Øµ connection patterns
    connection = request.headers.get('Connection', '').lower()
    if 'keep-alive' not in connection and connection:
        vpn_score += 1
        vpn_indicators.append("unusual_connection")

    app.logger.info(f"VPN/Proxy detection for {client_ip}: score = {vpn_score}, indicators = {vpn_indicators}")

    return vpn_score < 6  # Ø§Ù„Ø³Ù…Ø§Ø­ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø£Ù‚Ù„ Ù…Ù† 6 Ù†Ù‚Ø§Ø·

# Ø§Ù„Ø³Ø·Ø± Ø§Ù„ØªØ§Ù„ÙŠ:
def is_suspicious_fingerprint(fingerprint_data):
    """ÙØ­Øµ Ø¨ØµÙ…Ø© Ø§Ù„Ø¬Ù‡Ø§Ø² Ù„Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„Ù…Ø´Ø¨ÙˆÙ‡Ø©"""
    suspicious_indicators = 0

    # ÙØ­Øµ User-Agent
    ua = fingerprint_data.get('user_agent', '').lower()
    if not ua or len(ua) < 20:
        suspicious_indicators += 1

    # ÙØ­Øµ Accept headers
    accept = fingerprint_data.get('accept', '')
    if not accept or 'text/html' not in accept:
        suspicious_indicators += 1

    # ÙØ­Øµ Accept-Language
    accept_lang = fingerprint_data.get('accept_language', '')
    if not accept_lang:
        suspicious_indicators += 1

    # ÙØ­Øµ Sec-Fetch headers (Ø¹Ù„Ø§Ù…Ø© Ø¹Ù„Ù‰ Ù…ØªØµÙØ­ Ø­Ø¯ÙŠØ«)
    sec_fetch_site = fingerprint_data.get('sec_fetch_site', '')
    sec_fetch_mode = fingerprint_data.get('sec_fetch_mode', '')
    if not sec_fetch_site and not sec_fetch_mode:
        suspicious_indicators += 1

    # Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ 3 Ø£Ùˆ Ø£ÙƒØ«Ø± Ù…Ù† Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„Ù…Ø´Ø¨ÙˆÙ‡Ø©
    return suspicious_indicators >= 3

# Routes
@app.route('/')
def home():
    return render_template('home.html')

@app.route('/ping', methods=['GET'])
def ping():
    """Endpoint Ù„Ù„Ù€ ping Ù„Ù…Ù†Ø¹ Cold Start"""
    try:
        # ÙØ­Øµ Ø¨Ø³ÙŠØ· Ù„Ø­Ø§Ù„Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… text()
        db.session.execute(text('SELECT 1'))

        return jsonify({
            'status': 'alive',
            'timestamp': datetime.utcnow().isoformat(),
            'message': 'Application is running'
        }), 200
    except Exception as e:
        return jsonify({
            'status': 'error',
            'timestamp': datetime.utcnow().isoformat(),
            'error': str(e)
        }), 500

@app.route('/health', methods=['GET'])
def health_check():
    """Endpoint Ù„Ù„ÙØ­Øµ Ø§Ù„ØµØ­ÙŠ Ø§Ù„Ù…ÙØµÙ„"""
    try:
        # ÙØ­Øµ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… text()
        db.session.execute(text('SELECT 1'))
        db_status = "healthy"

        # ÙØ­Øµ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† (ÙƒÙ…Ø«Ø§Ù„ Ø¹Ù„Ù‰ Ø£Ù† Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ÙŠØ¹Ù…Ù„)
        user_count = User.query.count()

        return jsonify({
            'status': 'healthy',
            'timestamp': datetime.utcnow().isoformat(),
            'database': db_status,
            'user_count': user_count,
            'uptime': 'running'
        }), 200
    except Exception as e:
        return jsonify({
            'status': 'unhealthy',
            'timestamp': datetime.utcnow().isoformat(),
            'error': str(e)
        }), 500

@app.route('/stats')
@login_required
def stats():
    """Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ù„Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©"""
    if not current_user.is_admin:
        return jsonify({'error': 'Unauthorized'}), 403

    try:
        total_users = User.query.count()
        verified_users = User.query.filter_by(is_verified=True).count()
        total_orders = Order.query.count()
        pending_orders = Order.query.filter_by(status='pending').count()
        completed_orders = Order.query.filter_by(status='completed').count()

        # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ù…Ø§Ø¶ÙŠ
        week_ago = datetime.utcnow() - timedelta(days=7)
        new_users_week = User.query.filter(User.created_at >= week_ago).count()
        new_orders_week = Order.query.filter(Order.created_at >= week_ago).count()

        return jsonify({
            'total_users': total_users,
            'verified_users': verified_users,
            'total_orders': total_orders,
            'pending_orders': pending_orders,
            'completed_orders': completed_orders,
            'new_users_this_week': new_users_week,
            'new_orders_this_week': new_orders_week,
            'timestamp': datetime.utcnow().isoformat()
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/admin/security-stats')
@login_required
@advanced_rate_limit(per_minute=10, per_hour=50)
def security_stats():
    """Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø£Ù…Ø§Ù† Ù„Ù„Ù…Ø¯ÙŠØ±"""
    if not current_user.is_admin:
        return jsonify({'error': 'Unauthorized'}), 403

    try:
        # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Rate Limiting
        total_ips = len(smart_limiter.suspicious_ips)
        blocked_ips = sum(1 for ip_data in smart_limiter.suspicious_ips.values()
                         if ip_data['score'] < -50)
        trusted_ips = sum(1 for ip_data in smart_limiter.suspicious_ips.values()
                         if ip_data['score'] > 50)

        # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
        total_users = User.query.count()
        verified_users = User.query.filter_by(is_verified=True).count()

        # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø£Ø®ÙŠØ±Ø©
        recent_time = datetime.utcnow() - timedelta(hours=1)
        recent_registrations = User.query.filter(User.created_at >= recent_time).count()

        return jsonify({
            'rate_limiting': {
                'total_tracked_ips': total_ips,
                'blocked_ips': blocked_ips,
                'trusted_ips': trusted_ips,
                'suspicious_ratio': round(blocked_ips / max(1, total_ips) * 100, 2)
            },
            'users': {
                'total_users': total_users,
                'verified_users': verified_users,
                'verification_rate': round(verified_users / max(1, total_users) * 100, 2),
                'recent_registrations': recent_registrations
            },
            'system': {
                'redis_connected': smart_limiter.redis_client is not None,
                'timestamp': datetime.utcnow().isoformat()
            }
        })

    except Exception as e:
        app.logger.error(f"Security stats error: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/admin/advanced-security-stats')
@login_required
@advanced_rate_limit(per_minute=5, per_hour=20)
def advanced_security_stats():
    """ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø£Ù…Ø§Ù† Ù…ØªÙ‚Ø¯Ù…Ø© Ù„Ù„Ù…Ø¯ÙŠØ±"""
    if not current_user.is_admin:
        return jsonify({'error': 'Unauthorized'}), 403

    try:
        current_time = int(time.time())

        # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù…Ø­Ø§ÙˆÙ„Ø§Øª ØªØºÙŠÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
        recent_time = datetime.utcnow() - timedelta(hours=24)

        # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ù†Ø´Ø·Ø© Ø§Ù„Ù…Ø´Ø¨ÙˆÙ‡Ø©
        high_risk_activities = {
            'honeypot_hits': sum(1 for data in suspicious_sessions.values()
                               if 'honeypot' in str(data)),
            'automation_detected': sum(1 for data in suspicious_sessions.values()
                                     if data.get('suspicious_score', 0) > 10),
            'failed_password_attempts': sum(1 for data in suspicious_sessions.values()
                                          if 'password' in str(data)),
            'vpn_proxy_detected': sum(1 for data in suspicious_sessions.values()
                                    if 'vpn' in str(data))
        }

        # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
        user_stats = {
            'total_users': User.query.count(),
            'verified_users': User.query.filter_by(is_verified=True).count(),
            'admin_users': User.query.filter_by(is_admin=True).count(),
            'recent_registrations': User.query.filter(User.created_at >= recent_time).count()
        }

        # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø·Ù„Ø¨Ø§Øª
        order_stats = {
            'total_orders': Order.query.count(),
            'pending_orders': Order.query.filter_by(status='pending').count(),
            'completed_orders': Order.query.filter_by(status='completed').count(),
            'recent_orders': Order.query.filter(Order.created_at >= recent_time).count()
        }

        # ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ù…Ø§Ù† Ø§Ù„Ø¹Ø§Ù…
        security_score = calculate_security_score(high_risk_activities, user_stats)

        return jsonify({
            'security_activities': high_risk_activities,
            'user_statistics': user_stats,
            'order_statistics': order_stats,
            'security_score': security_score,
            'recommendations': generate_security_recommendations(high_risk_activities),
            'timestamp': datetime.utcnow().isoformat()
        })

    except Exception as e:
        app.logger.error(f"Advanced security stats error: {e}")
        return jsonify({'error': str(e)}), 500

def calculate_security_score(activities, user_stats):
    """Ø­Ø³Ø§Ø¨ Ù†Ù‚Ø§Ø· Ø§Ù„Ø£Ù…Ø§Ù† Ø§Ù„Ø¹Ø§Ù…Ø©"""
    base_score = 100

    # Ø®ØµÙ… Ø§Ù„Ù†Ù‚Ø§Ø· Ø­Ø³Ø¨ Ø§Ù„Ø£Ù†Ø´Ø·Ø© Ø§Ù„Ù…Ø´Ø¨ÙˆÙ‡Ø©
    base_score -= activities.get('honeypot_hits', 0) * 5
    base_score -= activities.get('automation_detected', 0) * 10
    base_score -= activities.get('failed_password_attempts', 0) * 3
    base_score -= activities.get('vpn_proxy_detected', 0) * 2

    # Ù…ÙƒØ§ÙØ¢Øª Ù„Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ø¥ÙŠØ¬Ø§Ø¨ÙŠØ©
    verification_rate = user_stats.get('verified_users', 0) / max(1, user_stats.get('total_users', 1))
    if verification_rate > 0.8:
        base_score += 10

    return max(0, min(100, base_score))

def generate_security_recommendations(activities):
    """ØªÙˆÙ„ÙŠØ¯ ØªÙˆØµÙŠØ§Øª Ø£Ù…Ù†ÙŠØ©"""
    recommendations = []

    if activities.get('honeypot_hits', 0) > 5:
        recommendations.append(" ØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø¹Ø¯Ø¯ Ø¹Ø§Ù„ÙŠ Ù…Ù† Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ø¨ÙˆØªØ§Øª - ÙÙƒØ± ÙÙŠ ØªØ´Ø¯ÙŠØ¯ Ø§Ù„Ø­Ù…Ø§ÙŠØ©")

    if activities.get('automation_detected', 0) > 3:
        recommendations.append(" ØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø£Ø¯ÙˆØ§Øª Ø£ØªÙ…ØªØ© - Ø±Ø§Ø¬Ø¹ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª reCAPTCHA")

    if activities.get('failed_password_attempts', 0) > 10:
        recommendations.append(" Ù…Ø­Ø§ÙˆÙ„Ø§Øª ÙƒÙ„Ù…Ø© Ù…Ø±ÙˆØ± Ù…Ø´Ø¨ÙˆÙ‡Ø© - ÙØ¹Ù„ Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡Ø§Øª")

    if not recommendations:
        recommendations.append(" Ø§Ù„Ù†Ø¸Ø§Ù… Ø¢Ù…Ù† Ø­Ø§Ù„ÙŠØ§Ù‹ - Ø§Ø³ØªÙ…Ø± ÙÙŠ Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©")

    return recommendations

@app.route('/admin/quick-stats')
@login_required
def quick_security_stats():
    """Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø£Ù…Ø§Ù† Ø³Ø±ÙŠØ¹Ø©"""
    if not current_user.is_admin:
        return jsonify({'error': 'Unauthorized'}), 403

    try:
        # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø­Ø¸Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ
        current_time = int(time.time())
        active_blocks = sum(1 for data in suspicious_sessions.values()
                          if data['blocked_until'] > current_time)

        # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù†Ø´Ø§Ø· Ø§Ù„Ù…Ø´Ø¨ÙˆÙ‡
        high_risk_ips = sum(1 for data in suspicious_sessions.values()
                          if data['suspicious_score'] >= 5)

        return jsonify({
            'active_blocks': active_blocks,
            'high_risk_ips': high_risk_ips,
            'total_tracked_sessions': len(suspicious_sessions),
            'timestamp': datetime.utcnow().isoformat()
        })

    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/admin/security-actions', methods=['POST'])
@login_required
@advanced_rate_limit(per_minute=5, per_hour=20)
def security_actions():
    """Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø£Ù…Ù†ÙŠØ© Ù„Ù„Ù…Ø¯ÙŠØ±"""
    if not current_user.is_admin:
        return jsonify({'error': 'Unauthorized'}), 403

    try:
        action = request.json.get('action')
        target = request.json.get('target')

        if action == 'unblock_ip':
            if smart_limiter.redis_client:
                smart_limiter.redis_client.delete(f"temp_block:{target}")
            if target in smart_limiter.suspicious_ips:
                smart_limiter.suspicious_ips[target]['score'] = 0
            app.logger.info(f"Admin {current_user.email} unblocked IP {target}")
            return jsonify({'success': True, 'message': 'IP unblocked successfully'})

        elif action == 'reset_reputation':
            if target in smart_limiter.suspicious_ips:
                smart_limiter.suspicious_ips[target]['score'] = 0
            if smart_limiter.redis_client:
                smart_limiter.redis_client.delete(f"reputation:ip:{target}")
            app.logger.info(f"Admin {current_user.email} reset reputation for {target}")
            return jsonify({'success': True, 'message': 'Reputation reset successfully'})

        elif action == 'cleanup_old_data':
            smart_limiter._cleanup_old_data(int(time.time()))
            app.logger.info(f"Admin {current_user.email} triggered data cleanup")
            return jsonify({'success': True, 'message': 'Old data cleaned successfully'})

        else:
            return jsonify({'error': 'Invalid action'}), 400

    except Exception as e:
        app.logger.error(f"Security action error: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/admin/order/<int:order_id>/details')
@login_required
@advanced_rate_limit(per_minute=30, per_hour=200)
def get_order_details(order_id):
    """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ØªÙØ§ØµÙŠÙ„ Ø·Ù„Ø¨ Ù…Ø­Ø¯Ø¯"""
    if not current_user.is_admin:
        return jsonify({'error': 'Unauthorized'}), 403

    try:
        order = Order.query.get_or_404(order_id)

        order_details = {
            'id': order.id,
            'platform': order.platform,
            'coins_amount': order.coins_amount,
            'price': order.price,
            'transfer_type': order.transfer_type or 'normal',
            'payment_method': order.payment_method,
            'phone_number': order.phone_number,
            'ea_email': order.ea_email,
            'notes': order.notes,
            'status': order.status,
            'created_at': order.created_at.isoformat(),
            'updated_at': order.updated_at.isoformat() if order.updated_at else None,
            'user_email': order.user.email,
            'user_telegram_linked': bool(order.user.telegram_id)
        }

        return jsonify({
            'success': True,
            'order': order_details
        })

    except Exception as e:
        app.logger.error(f"Error fetching order details: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/admin/export/orders')
@login_required
@advanced_rate_limit(per_minute=2, per_hour=10)
def export_orders():
    """ØªØµØ¯ÙŠØ± Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø¥Ù„Ù‰ CSV"""
    if not current_user.is_admin:
        return jsonify({'error': 'Unauthorized'}), 403

    try:
        import csv
        import io

        from flask import make_response

        output = io.StringIO()
        writer = csv.writer(output)

        # Ø±Ø¤ÙˆØ³ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø©
        writer.writerow([
            'Ø±Ù‚Ù… Ø§Ù„Ø·Ù„Ø¨', 'Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ', 'Ø§Ù„Ù…Ù†ØµØ©', 'ÙƒÙ…ÙŠØ© Ø§Ù„ÙƒÙˆÙŠÙ†Ø²',
            'Ø§Ù„Ø³Ø¹Ø±', 'Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹', 'Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„', 'Ø§Ù„Ø­Ø§Ù„Ø©',
            'Ø±Ù‚Ù… Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨', 'ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡'
        ])

        # Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø¨Ø§Øª
        orders = Order.query.join(User).all()
        for order in orders:
            writer.writerow([
                order.id,
                order.user.email,
                order.platform,
                order.coins_amount,
                order.price or 0,
                order.payment_method,
                order.transfer_type or 'normal',
                order.status,
                order.phone_number or '',
                order.created_at.strftime('%Y-%m-%d %H:%M:%S')
            ])

        # Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©
        output.seek(0)
        response = make_response(output.getvalue())
        response.headers['Content-Type'] = 'text/csv; charset=utf-8'
        response.headers['Content-Disposition'] = f'attachment; filename=orders_{datetime.now().strftime("%Y%m%d_%H%M%S")}.csv'

        app.logger.info(f"Orders exported by admin: {current_user.email}")
        return response

    except Exception as e:
        app.logger.error(f"Error exporting orders: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/admin/export/all')
@login_required
@advanced_rate_limit(per_minute=1, per_hour=5)
def export_all_data():
    """ØªØµØ¯ÙŠØ± Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ ZIP"""
    if not current_user.is_admin:
        return jsonify({'error': 'Unauthorized'}), 403

    try:
        import csv
        import io
        import zipfile

        from flask import make_response

        # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù ZIP ÙÙŠ Ø§Ù„Ø°Ø§ÙƒØ±Ø©
        zip_buffer = io.BytesIO()

        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            # ØªØµØ¯ÙŠØ± Ø§Ù„Ø·Ù„Ø¨Ø§Øª
            orders_csv = io.StringIO()
            orders_writer = csv.writer(orders_csv)
            orders_writer.writerow([
                'Ø±Ù‚Ù… Ø§Ù„Ø·Ù„Ø¨', 'Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ', 'Ø§Ù„Ù…Ù†ØµØ©', 'ÙƒÙ…ÙŠØ© Ø§Ù„ÙƒÙˆÙŠÙ†Ø²',
                'Ø§Ù„Ø³Ø¹Ø±', 'Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹', 'Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„', 'Ø§Ù„Ø­Ø§Ù„Ø©',
                'Ø±Ù‚Ù… Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨', 'ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡'
            ])

            orders = Order.query.join(User).all()
            for order in orders:
                orders_writer.writerow([
                    order.id, order.user.email, order.platform,
                    order.coins_amount, order.price or 0, order.payment_method,
                    order.transfer_type or 'normal', order.status,
                    order.phone_number or '', order.created_at.strftime('%Y-%m-%d %H:%M:%S')
                ])

            zip_file.writestr('orders.csv', orders_csv.getvalue().encode('utf-8-sig'))

            # ØªØµØ¯ÙŠØ± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
            users_csv = io.StringIO()
            users_writer = csv.writer(users_csv)
            users_writer.writerow([
                'Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ', 'Ù…ÙØ¹Ù„', 'Ù…Ø¯ÙŠØ±', 'Ø±Ù‚Ù… Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨',
                'Ø§Ù„Ù…Ù†ØµØ© Ø§Ù„Ù…ÙØ¶Ù„Ø©', 'Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹ Ø§Ù„Ù…ÙØ¶Ù„Ø©', 'Ø¨Ø±ÙŠØ¯ EA',
                'Ù…Ø¹Ø±Ù Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…', 'ØªØ§Ø±ÙŠØ® Ø§Ù„ØªØ³Ø¬ÙŠÙ„'
            ])

            users = User.query.all()
            for user in users:
                users_writer.writerow([
                    user.email, user.is_verified, user.is_admin,
                    user.whatsapp or '', user.preferred_platform or '',
                    user.preferred_payment or '', user.ea_email or '',
                    user.telegram_id or '', user.created_at.strftime('%Y-%m-%d %H:%M:%S')
                ])

            zip_file.writestr('users.csv', users_csv.getvalue().encode('utf-8-sig'))

            # Ø¥Ø¶Ø§ÙØ© Ù…Ù„Ù Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
            stats = calculate_admin_statistics()
            stats_content = f"""ØªÙ‚Ø±ÙŠØ± Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù†Ø¸Ø§Ù…
ØªØ§Ø±ÙŠØ® Ø§Ù„ØªØµØ¯ÙŠØ±: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†:
- Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {stats.get('users', {}).get('total', 0)}
- Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…ÙØ¹Ù„ÙŠÙ†: {stats.get('users', {}).get('verified', 0)}
- Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªÙØ¹ÙŠÙ„: {stats.get('users', {}).get('verification_rate', 0):.1f}%
- Ù…Ø±Ø¨ÙˆØ·ÙŠÙ† Ø¨Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…: {stats.get('users', {}).get('telegram_linked', 0)}

Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø·Ù„Ø¨Ø§Øª:
- Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø·Ù„Ø¨Ø§Øª: {stats.get('orders', {}).get('total', 0)}
- Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø©: {stats.get('orders', {}).get('completed', 0)}
- Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø¥Ù†Ø¬Ø§Ø²: {stats.get('orders', {}).get('completion_rate', 0):.1f}%

Ø§Ù„Ø¥ÙŠØ±Ø§Ø¯Ø§Øª:
- Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø¥ÙŠØ±Ø§Ø¯Ø§Øª: {stats.get('revenue', {}).get('total', 0):,.2f} Ø¬Ù†ÙŠÙ‡
- Ù…ØªÙˆØ³Ø· Ù‚ÙŠÙ…Ø© Ø§Ù„Ø·Ù„Ø¨: {stats.get('revenue', {}).get('avg_order', 0):,.2f} Ø¬Ù†ÙŠÙ‡
"""
            zip_file.writestr('statistics.txt', stats_content.encode('utf-8'))

        zip_buffer.seek(0)

        response = make_response(zip_buffer.getvalue())
        response.headers['Content-Type'] = 'application/zip'
        response.headers['Content-Disposition'] = f'attachment; filename=complete_data_export_{datetime.now().strftime("%Y%m%d_%H%M%S")}.zip'

        app.logger.info(f"Complete data export by admin: {current_user.email}")
        return response

    except Exception as e:
        app.logger.error(f"Error exporting all data: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/admin/bulk-notification', methods=['POST'])
@login_required
@advanced_rate_limit(per_minute=1, per_hour=3)
def send_bulk_notification():
    """Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ø¬Ù…Ø§Ø¹ÙŠ Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø±Ø¨ÙˆØ·ÙŠÙ† Ø¨Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…"""
    if not current_user.is_admin:
        return jsonify({'error': 'Unauthorized'}), 403

    try:
        data = request.get_json()
        message = data.get('message', '').strip()

        if not message:
            return jsonify({'error': 'Message is required'}), 400

        if not telegram_system.is_configured():
            return jsonify({'error': 'Telegram system not configured'}), 503

        # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø±Ø¨ÙˆØ·ÙŠÙ† Ø¨Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…
        users_with_telegram = User.query.filter(User.telegram_id.isnot(None)).all()

        if not users_with_telegram:
            return jsonify({'error': 'No users with Telegram linked'}), 400

        # ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ø±Ø³Ø§Ù„Ø©
        formatted_message = f"""
ğŸ“¢ <b>Ø¥Ø´Ø¹Ø§Ø± Ù…Ù† Ø¥Ø¯Ø§Ø±Ø© Ø´Ù‡Ø¯ Ø§Ù„Ø³Ù†ÙŠÙˆØ±Ø©</b>

{message}

ğŸ•’ {datetime.now().strftime('%Y-%m-%d %H:%M')}

Ø´ÙƒØ±Ø§Ù‹ Ù„Ø§Ø®ØªÙŠØ§Ø±Ùƒ Ø´Ù‡Ø¯ Ø§Ù„Ø³Ù†ÙŠÙˆØ±Ø©! ğŸ®
        """

        # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
        sent_count = 0
        failed_count = 0

        for user in users_with_telegram:
            success = telegram_system.send_message(user.telegram_id, formatted_message.strip())
            if success:
                sent_count += 1
            else:
                failed_count += 1

        app.logger.info(f"Bulk notification sent by {current_user.email}: {sent_count} sent, {failed_count} failed")

        return jsonify({
            'success': True,
            'message': f'ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø± Ø¨Ù†Ø¬Ø§Ø­',
            'sent_count': sent_count,
            'failed_count': failed_count,
            'total_users': len(users_with_telegram)
        })

    except Exception as e:
        app.logger.error(f"Error sending bulk notification: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/admin/logs')
@login_required
@advanced_rate_limit(per_minute=10, per_hour=50)
def view_system_logs():
    """Ø¹Ø±Ø¶ Ø³Ø¬Ù„Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù…"""
    if not current_user.is_admin:
        return jsonify({'error': 'Unauthorized'}), 403

    try:
        import os

        logs_content = ""
        log_file_path = "logs/app.log"

        if os.path.exists(log_file_path):
            with open(log_file_path, 'r', encoding='utf-8') as f:
                # Ù‚Ø±Ø§Ø¡Ø© Ø¢Ø®Ø± 1000 Ø³Ø·Ø±
                lines = f.readlines()
                logs_content = ''.join(lines[-1000:])
        else:
            logs_content = "Ù…Ù„Ù Ø§Ù„Ø³Ø¬Ù„Ø§Øª ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯"

        # Ø¥Ù†Ø´Ø§Ø¡ ØµÙØ­Ø© HTML Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø³Ø¬Ù„Ø§Øª
        html_content = f"""
<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø³Ø¬Ù„Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù…</title>
    <style>
        body {{
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #f0f0f0;
            padding: 20px;
            margin: 0;
        }}
        .log-container {{
            background: #2d2d2d;
            border-radius: 10px;
            padding: 20px;
            white-space: pre-wrap;
            font-size: 12px;
            line-height: 1.4;
            max-height: 80vh;
            overflow-y: auto;
        }}
        .log-header {{
            background: #4a5568;
            color: white;
            padding: 15px;
            border-radius: 10px 10px 0 0;
            margin: -20px -20px 20px -20px;
        }}
        .error {{ color: #ff6b6b; }}
        .warning {{ color: #ffa500; }}
        .info {{ color: #4dabf7; }}
        .success {{ color: #51cf66; }}
    </style>
</head>
<body>
    <div class="log-header">
        <h2>Ø³Ø¬Ù„Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù… - Ø´Ù‡Ø¯ Ø§Ù„Ø³Ù†ÙŠÙˆØ±Ø©</h2>
        <p>Ø¢Ø®Ø± 1000 Ø³Ø·Ø± - ØªØ­Ø¯ÙŠØ«: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
    </div>
    <div class="log-container">{logs_content}</div>
    <script>
        // ØªÙ…Ø±ÙŠØ± ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ø£Ø³ÙÙ„
        document.querySelector('.log-container').scrollTop =
            document.querySelector('.log-container').scrollHeight;

        // ØªØ­Ø¯ÙŠØ« ØªÙ„Ù‚Ø§Ø¦ÙŠ ÙƒÙ„ 30 Ø«Ø§Ù†ÙŠØ©
        setTimeout(() => location.reload(), 30000);
    </script>
</body>
</html>
        """

        from flask import make_response
        response = make_response(html_content)
        response.headers['Content-Type'] = 'text/html; charset=utf-8'

        return response

    except Exception as e:
        app.logger.error(f"Error viewing system logs: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/admin/repair-database', methods=['POST'])
@login_required
@advanced_rate_limit(per_minute=1, per_hour=3)
def repair_database_endpoint():
    """Ø¥ØµÙ„Ø§Ø­ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (Ù„Ù„Ø·ÙˆØ§Ø±Ø¦ ÙÙ‚Ø·)"""
    if not current_user.is_admin:
        return jsonify({'error': 'Unauthorized'}), 403

    try:
        # Ø¥ØµÙ„Ø§Ø­ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        repair_success = force_database_repair()

        if repair_success:
            app.logger.info(f"Database repair initiated by admin: {current_user.email}")
            return jsonify({
                'success': True,
                'message': 'ØªÙ… Ø¥ØµÙ„Ø§Ø­ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­'
            })
        else:
            return jsonify({
                'success': False,
                'message': 'ÙØ´Ù„ ÙÙŠ Ø¥ØµÙ„Ø§Ø­ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª'
            }), 500

    except Exception as e:
        app.logger.error(f"Database repair error: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/admin/backup', methods=['POST'])
@login_required
@advanced_rate_limit(per_minute=1, per_hour=2)
def create_database_backup():
    """Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
    if not current_user.is_admin:
        return jsonify({'error': 'Unauthorized'}), 403

    try:
        import json
        import os

        backup_data = {
            'backup_info': {
                'created_at': datetime.now().isoformat(),
                'created_by': current_user.email,
                'version': '1.0'
            },
            'users': [],
            'orders': []
        }

        # Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† (Ø¨Ø¯ÙˆÙ† ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø±ÙˆØ±)
        users = User.query.all()
        for user in users:
            backup_data['users'].append({
                'id': user.id,
                'email': user.email,
                'is_verified': user.is_verified,
                'is_admin': user.is_admin,
                'whatsapp': user.whatsapp,
                'preferred_platform': user.preferred_platform,
                'preferred_payment': user.preferred_payment,
                'ea_email': user.ea_email,
                'telegram_id': user.telegram_id,
                'telegram_username': user.telegram_username,
                'profile_completed': user.profile_completed,
                'created_at': user.created_at.isoformat() if user.created_at else None,
                'last_profile_update': user.last_profile_update.isoformat() if user.last_profile_update else None
            })

        # Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ù„Ù„Ø·Ù„Ø¨Ø§Øª
        orders = Order.query.all()
        for order in orders:
            backup_data['orders'].append({
                'id': order.id,
                'user_id': order.user_id,
                'platform': order.platform,
                'payment_method': order.payment_method,
                'coins_amount': order.coins_amount,
                'status': order.status,
                'ea_email': order.ea_email,
                'transfer_type': order.transfer_type,
                'notes': order.notes,
                'price': order.price,
                'phone_number': order.phone_number,
                'created_at': order.created_at.isoformat() if order.created_at else None,
                'updated_at': order.updated_at.isoformat() if order.updated_at else None
            })

        # Ø­ÙØ¸ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©
        backup_filename = f"backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        backup_dir = "backups"

        if not os.path.exists(backup_dir):
            os.makedirs(backup_dir)

        backup_path = os.path.join(backup_dir, backup_filename)

        with open(backup_path, 'w', encoding='utf-8') as f:
            json.dump(backup_data, f, ensure_ascii=False, indent=2)

        app.logger.info(f"Database backup created by {current_user.email}: {backup_filename}")

        return jsonify({
            'success': True,
            'message': 'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­',
            'filename': backup_filename,
            'users_count': len(backup_data['users']),
            'orders_count': len(backup_data['orders'])
        })

    except Exception as e:
        app.logger.error(f"Error creating database backup: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/admin/telegram-test', methods=['POST'])
@login_required
@advanced_rate_limit(per_minute=2, per_hour=10)
def test_telegram_system():
    """Ø§Ø®ØªØ¨Ø§Ø± Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù… (Ù„Ù„Ù…Ø·ÙˆØ±ÙŠÙ†)"""
    if not current_user.is_admin:
        return jsonify({'error': 'Unauthorized'}), 403

    try:
        test_type = request.json.get('test_type', 'config')

        if test_type == 'config':
            # ÙØ­Øµ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…
            return jsonify({
                'success': True,
                'telegram_configured': telegram_system.is_configured(),
                'bot_token_exists': bool(telegram_system.bot_token),
                'bot_username': telegram_system.bot_username,
                'webhook_url': telegram_system.webhook_url
            })

        elif test_type == 'webhook':
            # Ø¥Ø¹Ø¯Ø§Ø¯ webhook
            if telegram_system.is_configured():
                result = telegram_system.setup_webhook()
                return jsonify({
                    'success': result,
                    'message': 'Webhook setup successfully' if result else 'Failed to setup webhook'
                })
            else:
                return jsonify({
                    'success': False,
                    'message': 'Telegram not configured'
                })

        elif test_type == 'notification':
            # Ø§Ø®ØªØ¨Ø§Ø± Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø±
            if current_user.telegram_id:
                test_message = f"""
ğŸ§ª <b>Ø±Ø³Ø§Ù„Ø© Ø§Ø®ØªØ¨Ø§Ø±</b>

âœ… Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù… ÙŠØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­!

ğŸ•’ Ø§Ù„ÙˆÙ‚Øª: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
ğŸ‘¤ Ø§Ù„Ù…Ø±Ø³Ù„: {current_user.email}

ğŸ® Ø´Ù‡Ø¯ Ø§Ù„Ø³Ù†ÙŠÙˆØ±Ø© - Ù†Ø¸Ø§Ù… Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª
                """

                result = telegram_system.send_message(current_user.telegram_id, test_message.strip())
                return jsonify({
                    'success': result,
                    'message': 'Test notification sent' if result else 'Failed to send notification'
                })
            else:
                return jsonify({
                    'success': False,
                    'message': 'Admin Telegram not linked'
                })

        else:
            return jsonify({'error': 'Invalid test type'}), 400

    except Exception as e:
        app.logger.error(f"Telegram test error: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/admin/reset-blocks', methods=['POST'])
@login_required
def reset_all_blocks():
    """Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø¬Ù…ÙŠØ¹ Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ø­Ø¸Ø± - Ù„Ù„Ø·ÙˆØ§Ø±Ø¦"""
    if not current_user.is_admin:
        return jsonify({'error': 'Unauthorized'}), 403

    try:
        # Ù…Ø³Ø­ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø¸ÙˆØ±ÙŠØ§Øª
        suspicious_sessions.clear()
        smart_limiter.suspicious_ips.clear()

        # Ù…Ø³Ø­ Ù…Ù† Redis Ø¥Ø°Ø§ Ù…ØªØ§Ø­
        if smart_limiter.redis_client:
            for key in smart_limiter.redis_client.scan_iter("temp_block:*"):
                smart_limiter.redis_client.delete(key)

        app.logger.info(f"Admin {current_user.email} reset all blocks")
        return jsonify({'success': True, 'message': 'All blocks cleared successfully'})

    except Exception as e:
        app.logger.error(f"Reset blocks error: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/setup-admin', methods=['GET', 'POST'])
def setup_admin():
    """ØµÙØ­Ø© Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø¥Ø¯Ø§Ø±ÙŠ Ø§Ù„Ø£ÙˆÙ„ÙŠ"""

    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù…Ø³ØªØ®Ø¯Ù… Ø¥Ø¯Ø§Ø±ÙŠ
    admin_email = os.environ.get('ADMIN_EMAIL', 'admin@example.com')
    existing_admin = User.query.filter_by(email=admin_email).first()

    if existing_admin:
        return render_template('admin_exists.html')

    if request.method == 'POST':
        try:
            email = request.form.get('email', '').strip().lower()
            password = request.form.get('password', '')
            confirm_password = request.form.get('confirm_password', '')
            setup_key = request.form.get('setup_key', '')

            # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù…ÙØªØ§Ø­ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯ (Ø§Ø®ØªÙŠØ§Ø±ÙŠ Ù„Ù„Ø£Ù…Ø§Ù† Ø§Ù„Ø¥Ø¶Ø§ÙÙŠ)
            expected_setup_key = os.environ.get('SETUP_KEY', '')
            if expected_setup_key and setup_key != expected_setup_key:
                flash('Ù…ÙØªØ§Ø­ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯ ØºÙŠØ± ØµØ­ÙŠØ­', 'error')
                return render_template('setup_admin.html')

            # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            if not email or not password:
                flash('Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ÙˆÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù…Ø·Ù„ÙˆØ¨Ø§Ù†', 'error')
                return render_template('setup_admin.html')

            if password != confirm_password:
                flash('ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± Ù…ØªØ·Ø§Ø¨Ù‚Ø©', 'error')
                return render_template('setup_admin.html')

            if len(password) < 8:
                flash('ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† 8 Ø£Ø­Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„', 'error')
                return render_template('setup_admin.html')

            # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø¥Ø¯Ø§Ø±ÙŠ
            admin = User(
                email=email,
                password_hash=generate_password_hash(password),
                is_verified=True,
                is_admin=True
            )

            db.session.add(admin)
            db.session.commit()

            app.logger.info(f"Admin user created: {email}")
            flash('ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø¥Ø¯Ø§Ø±ÙŠ Ø¨Ù†Ø¬Ø§Ø­!', 'success')
            return redirect(url_for('login'))

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error creating admin user: {e}")
            flash('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø¥Ø¯Ø§Ø±ÙŠ', 'error')

    return render_template('setup_admin.html')

def log_password_change_attempt(user_email, ip_address, success=True, reason=""):
    """ğŸ“Œ ØªØ³Ø¬ÙŠÙ„ Ù…Ø­Ø§ÙˆÙ„Ø§Øª ØªØºÙŠÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù„Ù„Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ø£Ù…Ù†ÙŠØ©"""
    status = "Ù†Ø¬Ø­" if success else "ÙØ´Ù„"
    log_message = f"Ù…Ø­Ø§ÙˆÙ„Ø© ØªØºÙŠÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± - Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: {user_email}, IP: {ip_address}, Ø§Ù„Ø­Ø§Ù„Ø©: {status}"

    if reason:
        log_message += f", Ø§Ù„Ø³Ø¨Ø¨: {reason}"

    if success:
        app.logger.info(log_message)
    else:
        app.logger.warning(log_message)

        # Ø¥Ø¶Ø§ÙØ© ØªØªØ¨Ø¹ Ù„Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ù…Ø´Ø¨ÙˆÙ‡Ø©
        track_suspicious_session(ip_address, 'failed_password_change', 2)

@app.route('/reset-admin-password', methods=['GET', 'POST'])
@login_required
def validate_password_strength(password):
    """ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‚ÙˆØ© ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù…Ø¹ Ù…Ø¹Ø§ÙŠÙŠØ± Ù…ØªÙ‚Ø¯Ù…Ø©"""
    errors = []
    score = 0

    # Ø§Ù„Ø·ÙˆÙ„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
    if len(password) < 8:
        errors.append("ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† 8 Ø£Ø­Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„")
        return False, errors, 0
    elif len(password) >= 12:
        score += 2
    else:
        score += 1

    # ÙØ­Øµ Ø§Ù„Ø£Ø­Ø±Ù Ø§Ù„ÙƒØ¨ÙŠØ±Ø©
    if any(c.isupper() for c in password):
        score += 1
    else:
        errors.append("ÙŠØ¬Ø¨ Ø£Ù† ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø­Ø±Ù ÙƒØ¨ÙŠØ± ÙˆØ§Ø­Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„")

    # ÙØ­Øµ Ø§Ù„Ø£Ø­Ø±Ù Ø§Ù„ØµØºÙŠØ±Ø©
    if any(c.islower() for c in password):
        score += 1
    else:
        errors.append("ÙŠØ¬Ø¨ Ø£Ù† ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø­Ø±Ù ØµØºÙŠØ± ÙˆØ§Ø­Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„")

    # ÙØ­Øµ Ø§Ù„Ø£Ø±Ù‚Ø§Ù…
    if any(c.isdigit() for c in password):
        score += 1
    else:
        errors.append("ÙŠØ¬Ø¨ Ø£Ù† ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø±Ù‚Ù… ÙˆØ§Ø­Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„")

    # ÙØ­Øµ Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø®Ø§ØµØ©
    special_chars = "!@#$%^&*()_+-=[]{}|;:,.<>?"
    if any(c in special_chars for c in password):
        score += 2
    else:
        errors.append("ÙŠÙÙ†ØµØ­ Ø¨Ø¥Ø¶Ø§ÙØ© Ø±Ù…Ø² Ø®Ø§Øµ (!@#$%^&*)")

    # ÙØ­Øµ Ø§Ù„ØªÙƒØ±Ø§Ø±
    if len(set(password)) < len(password) * 0.7:
        errors.append("ØªØ¬Ù†Ø¨ ØªÙƒØ±Ø§Ø± Ø§Ù„Ø£Ø­Ø±Ù ÙƒØ«ÙŠØ±Ø§Ù‹")
        score -= 1

    # ÙƒÙ„Ù…Ø§Øª Ù…Ø±ÙˆØ± Ø´Ø§Ø¦Ø¹Ø©
    common_passwords = [
        "password", "123456", "admin123", "qwerty",
        "password123", "admin", "administrator"
    ]
    if password.lower() in common_passwords:
        errors.append("ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø´Ø§Ø¦Ø¹Ø© Ø¬Ø¯Ø§Ù‹ØŒ Ø§Ø®ØªØ± ÙƒÙ„Ù…Ø© Ø£Ù‚ÙˆÙ‰")
        return False, errors, 0

    # ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©
    is_strong = score >= 5 and len(errors) <= 1

    return is_strong, errors, min(100, score * 15)

@app.route('/reset-admin-password', methods=['GET', 'POST'])
@login_required
def reset_admin_password():

    """ØµÙØ­Ø© Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† ÙƒÙ„Ù…Ø© Ù…Ø±ÙˆØ± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø¥Ø¯Ø§Ø±ÙŠ"""

    if not current_user.is_admin:
        flash('Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„Ù„ÙˆØµÙˆÙ„ Ù„Ù‡Ø°Ù‡ Ø§Ù„ØµÙØ­Ø©', 'error')
        return redirect(url_for('dashboard'))

    if request.method == 'POST':
        try:
            current_password = request.form.get('current_password', '')
            new_password = request.form.get('new_password', '')
            confirm_password = request.form.get('confirm_password', '')

            # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù…Ø¹ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª
            client_ip = get_remote_address()

            if not check_password_hash(current_user.password_hash, current_password):
                log_password_change_attempt(current_user.email, client_ip, False, "ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ø®Ø§Ø·Ø¦Ø©")
                flash('ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ø­Ø§Ù„ÙŠØ© ØºÙŠØ± ØµØ­ÙŠØ­Ø©', 'error')
                return render_template('reset_admin_password.html')

            # Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ù…ØªÙ‚Ø¯Ù… Ù…Ù† Ù‚ÙˆØ© ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
            is_strong, password_errors, strength_score = validate_password_strength(new_password)

            if not is_strong:
                flash(f'ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø¶Ø¹ÙŠÙØ© (Ø§Ù„Ù†Ù‚Ø§Ø·: {strength_score}/100). Ø§Ù„Ù…Ø´Ø§ÙƒÙ„: {", ".join(password_errors)}', 'error')
                return render_template('reset_admin_password.html')

            # ØªØ­Ø°ÙŠØ± Ø¥Ø°Ø§ ÙƒØ§Ù†Øª ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù…ØªÙˆØ³Ø·Ø© Ø§Ù„Ù‚ÙˆØ©
            if strength_score < 80:
                flash(f'ØªØ­Ø°ÙŠØ±: Ù‚ÙˆØ© ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù…ØªÙˆØ³Ø·Ø© ({strength_score}/100). ÙŠÙÙ†ØµØ­ Ø¨ØªØ­Ø³ÙŠÙ†Ù‡Ø§.', 'warning')

            if new_password != confirm_password:
                flash('ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± Ù…ØªØ·Ø§Ø¨Ù‚Ø©', 'error')
                return render_template('reset_admin_password.html')

            # ØªØ­Ø¯ÙŠØ« ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
            current_user.password_hash = generate_password_hash(new_password)
            db.session.commit()

            # ØªØ³Ø¬ÙŠÙ„ ØªÙØµÙŠÙ„ÙŠ Ø£ÙƒØ«Ø± Ù„Ù„Ø£Ù…Ø§Ù†
            app.logger.info(f"Admin password reset for user: {current_user.email} from IP: {get_remote_address()}")

            # ØªØ­Ø¯ÙŠØ« timestamp Ø¢Ø®Ø± ØªØ¹Ø¯ÙŠÙ„ Ù„Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ
            current_user.last_profile_update = datetime.utcnow()

            # Ø¥Ø¶Ø§ÙØ© ØªØ­Ø¯ÙŠØ« Ø³Ù…Ø¹Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¥ÙŠØ¬Ø§Ø¨ÙŠØ§Ù‹
            client_fingerprint = smart_limiter.get_client_fingerprint(request)
            smart_limiter.update_reputation(client_fingerprint, 'successful_action', current_user.id)
            flash('ØªÙ… ØªØºÙŠÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø¨Ù†Ø¬Ø§Ø­!', 'success')
            return redirect(url_for('admin_dashboard'))

        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error resetting admin password: {e}")
            flash('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØºÙŠÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±', 'error')

    return render_template('reset_admin_password.html')

@app.route('/register', methods=['GET', 'POST'])
@advanced_rate_limit(per_minute=5, per_hour=15, block_on_abuse=True)
def register():
    if request.method == 'GET':
        # Ø¥Ù†Ø´Ø§Ø¡ time token Ù„Ù„Ù†Ù…ÙˆØ°Ø¬
        time_token, timestamp = generate_time_token()
        return render_template('register.html', time_token=time_token, timestamp=timestamp)

    if request.method == 'POST':
        client_fingerprint = smart_limiter.get_client_fingerprint(request)

        try:
            # ÙØ­Øµ Captcha Ø§Ù„Ø´Ø§Ù…Ù„
            if not comprehensive_captcha_check(request, request.form):
                smart_limiter.update_reputation(client_fingerprint, 'honeypot_hit')
                flash('ÙØ´Ù„ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø£Ù…Ø§Ù†. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.', 'error')
                time_token, timestamp = generate_time_token()
                return render_template('register.html', time_token=time_token, timestamp=timestamp)

            email = request.form['email'].lower().strip()
            password = request.form['password']

            # Validate email format
            if not re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', email):
                smart_limiter.update_reputation(client_fingerprint, 'invalid_form')
                flash('Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ØºÙŠØ± ØµØ§Ù„Ø­', 'error')
                time_token, timestamp = generate_time_token()
                return render_template('register.html', time_token=time_token, timestamp=timestamp)

            # Check if email is from trusted domain
            if not is_valid_email(email):
                smart_limiter.update_reputation(client_fingerprint, 'invalid_form')
                flash('ÙŠØ¬Ø¨ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¨Ø±ÙŠØ¯ Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ù…Ù† Gmail Ø£Ùˆ Hotmail Ø£Ùˆ iCloud Ø£Ùˆ Yahoo', 'error')
                time_token, timestamp = generate_time_token()
                return render_template('register.html', time_token=time_token, timestamp=timestamp)

            # Check password length
            if len(password) < 6:
                smart_limiter.update_reputation(client_fingerprint, 'invalid_form')
                flash('ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† 6 Ø£Ø­Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„', 'error')
                time_token, timestamp = generate_time_token()
                return render_template('register.html', time_token=time_token, timestamp=timestamp)

            # Check if user already exists
            existing_user = User.query.filter_by(email=email).first()
            if existing_user:
                smart_limiter.update_reputation(client_fingerprint, 'invalid_form')
                flash('Ù‡Ø°Ø§ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„', 'error')
                time_token, timestamp = generate_time_token()
                return render_template('register.html', time_token=time_token, timestamp=timestamp)

            # Generate verification code
            verification_code = generate_verification_code()
            code_expiry = datetime.utcnow() + timedelta(minutes=10)

            # Create new user
            user = User(
                email=email,
                password_hash=generate_password_hash(password),
                verification_code=verification_code,
                code_expiry=code_expiry
            )

            # Send verification email
            if send_verification_email(email, verification_code):
                db.session.add(user)
                db.session.commit()
                session['user_email'] = email

                # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³Ù…Ø¹Ø© Ø¥ÙŠØ¬Ø§Ø¨ÙŠØ§Ù‹ Ù„Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù†Ø§Ø¬Ø­
                smart_limiter.update_reputation(client_fingerprint, 'successful_action')

                flash('ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªÙØ¹ÙŠÙ„ Ø¥Ù„Ù‰ Ø¨Ø±ÙŠØ¯Ùƒ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ', 'success')
                return redirect(url_for('verify_email'))
            else:
                flash('Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠØŒ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰', 'error')

        except Exception as e:
            app.logger.error(f"Registration error: {e}")
            smart_limiter.update_reputation(client_fingerprint, 'invalid_form')
            flash('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ØŒ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰', 'error')

        # ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ø®Ø·Ø£ØŒ Ø¥Ù†Ø´Ø§Ø¡ tokens Ø¬Ø¯ÙŠØ¯Ø©
        time_token, timestamp = generate_time_token()
        return render_template('register.html', time_token=time_token, timestamp=timestamp)

def advanced_form_analysis(form_data, client_ip):
    """ØªØ­Ù„ÙŠÙ„ Ù…ØªÙ‚Ø¯Ù… Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ù„Ù„ÙƒØ´Ù Ø¹Ù† Ø§Ù„Ø³Ù„ÙˆÙƒ Ø§Ù„Ù…Ø´Ø¨ÙˆÙ‡"""
    suspicious_score = 0

    # 1. ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ
    email = form_data.get('email', '').lower()
    if email:
        # ÙØ­Øµ Ø§Ù„Ù†Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ù…Ø´Ø¨ÙˆÙ‡Ø©
        suspicious_domains = [
            'tempmail', '10minutemail', 'guerrillamail', 'mailinator',
            'yopmail', 'temp-mail', 'throwaway', 'dispostable'
        ]

        if any(domain in email for domain in suspicious_domains):
            suspicious_score += 3
            app.logger.warning(f"Suspicious email domain from {client_ip}: {email}")

        # ÙØ­Øµ Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ù…Ø´Ø¨ÙˆÙ‡Ø©
        if '+' in email.split('@')[0]:  # plus addressing
            suspicious_score += 1

        if email.count('.') > 3:  # Ù†Ù‚Ø§Ø· ÙƒØ«ÙŠØ±Ø©
            suspicious_score += 1

        if any(char.isdigit() for char in email) and email.count('1') > 3:
            suspicious_score += 1  # Ø£Ø±Ù‚Ø§Ù… ÙƒØ«ÙŠØ±Ø© Ù…ØªÙƒØ±Ø±Ø©

    # 2. ØªØ­Ù„ÙŠÙ„ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
    password = form_data.get('password', '')
    if password:
        # ÙƒÙ„Ù…Ø§Øª Ù…Ø±ÙˆØ± Ø´Ø§Ø¦Ø¹Ø© Ù„Ù„Ø¨ÙˆØªØ§Øª
        common_bot_passwords = [
            '123456', 'password', 'test123', 'admin123', 'qwerty',
            '111111', '000000', 'test', 'admin', 'user123'
        ]

        if password in common_bot_passwords:
            suspicious_score += 2

        # Ø£Ù†Ù…Ø§Ø· Ù…Ø´Ø¨ÙˆÙ‡Ø©
        if password.isdigit() and len(password) == 6:  # Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·
            suspicious_score += 1

        if password == password.lower() and len(password) < 8:  # Ø£Ø­Ø±Ù ØµØºÙŠØ±Ø© ÙÙ‚Ø· ÙˆÙ‚ØµÙŠØ±Ø©
            suspicious_score += 1

    # 3. ØªØ­Ù„ÙŠÙ„ ØªÙˆÙ‚ÙŠØª Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„
    timestamp = form_data.get('timestamp', '')
    if timestamp:
        try:
            form_time = int(timestamp)
            current_time = int(time.time())
            filling_time = current_time - form_time

            # ÙˆÙ‚Øª Ù‚ØµÙŠØ± Ø¬Ø¯Ø§Ù‹ (Ø£Ù‚Ù„ Ù…Ù† 5 Ø«ÙˆØ§Ù†) = Ø¨ÙˆØª Ù…Ø­ØªÙ…Ù„
            if filling_time < 5:
                suspicious_score += 2
            # ÙˆÙ‚Øª Ø·ÙˆÙŠÙ„ Ø¬Ø¯Ø§Ù‹ (Ø£ÙƒØ«Ø± Ù…Ù† 30 Ø¯Ù‚ÙŠÙ‚Ø©) = Ù…Ø´Ø¨ÙˆÙ‡
            elif filling_time > 1800:
                suspicious_score += 1
        except:
            suspicious_score += 1

    # 4. ÙØ­Øµ ØªØ³Ù„Ø³Ù„ Ø§Ù„Ø­Ù‚ÙˆÙ„
    # Ø¥Ø°Ø§ ØªÙ… Ù…Ù„Ø¡ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø¨Ù†ÙØ³ Ø§Ù„ØªØ±ØªÙŠØ¨ Ø¯Ø§Ø¦Ù…Ø§Ù‹ = Ù…Ø´Ø¨ÙˆÙ‡
    fields_order = list(form_data.keys())
    expected_order = ['email', 'password', 'time_token', 'timestamp']

    if fields_order[:4] == expected_order:
        suspicious_score += 1  # ØªØ±ØªÙŠØ¨ Ù…Ø«Ø§Ù„ÙŠ = Ù…Ø´Ø¨ÙˆÙ‡

    app.logger.info(f"Form analysis for {client_ip}: suspicious_score = {suspicious_score}")

# Ø§Ù„Ø³Ø·Ø± Ø§Ù„Ø°ÙŠ ÙŠØ³Ø¨Ù‚ Ø§Ù„ÙƒØªÙ„Ø© Ù…Ø¨Ø§Ø´Ø±Ø©:
    return suspicious_score < 5  # Ø§Ù„Ø³Ù…Ø§Ø­ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø£Ù‚Ù„ Ù…Ù† 5 Ù†Ù‚Ø§Ø· Ù…Ø´Ø¨ÙˆÙ‡Ø©

#  Ø¥Ø¶Ø§ÙØ© Ù†Ø¸Ø§Ù… IP Reputation ÙÙŠ Ù…Ù„Ù app.py
class IPReputationSystem:
    def __init__(self):
        self.ip_history = defaultdict(lambda: {
            'attempts': 0,
            'successful_logins': 0,
            'failed_logins': 0,
            'registrations': 0,
            'last_activity': 0,
            'reputation_score': 100,
            'countries': set(),
            'user_agents': set()
        })
        self.lock = Lock()

    def update_ip_activity(self, ip, activity_type, success=True):
        """ØªØ­Ø¯ÙŠØ« Ù†Ø´Ø§Ø· IP"""
        with self.lock:
            current_time = int(time.time())
            data = self.ip_history[ip]

            data['attempts'] += 1
            data['last_activity'] = current_time

            if activity_type == 'login':
                if success:
                    data['successful_logins'] += 1
                    data['reputation_score'] = min(150, data['reputation_score'] + 5)
                else:
                    data['failed_logins'] += 1
                    data['reputation_score'] = max(0, data['reputation_score'] - 10)

            elif activity_type == 'register':
                data['registrations'] += 1
                if success:
                    data['reputation_score'] = min(150, data['reputation_score'] + 10)
                else:
                    data['reputation_score'] = max(0, data['reputation_score'] - 15)

            # ØªØ­Ù„ÙŠÙ„ patterns Ù…Ø´Ø¨ÙˆÙ‡Ø©
            if data['failed_logins'] > 5:
                data['reputation_score'] = max(0, data['reputation_score'] - 20)

            if data['registrations'] > 3:
                data['reputation_score'] = max(0, data['reputation_score'] - 15)

    def get_ip_reputation(self, ip):
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø³Ù…Ø¹Ø© IP"""
        return self.ip_history[ip]['reputation_score']

    def is_ip_suspicious(self, ip):
        """ÙØ­Øµ Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† IP Ù…Ø´Ø¨ÙˆÙ‡"""
        data = self.ip_history[ip]

        # IP Ø¬Ø¯ÙŠØ¯ ØªÙ…Ø§Ù…Ø§Ù‹
        if data['attempts'] == 0:
            return False

        # Ø³Ù…Ø¹Ø© Ù…Ù†Ø®ÙØ¶Ø©
        if data['reputation_score'] < 30:
            return True

        # Ù†Ø³Ø¨Ø© ÙØ´Ù„ Ø¹Ø§Ù„ÙŠØ©
        total_attempts = data['successful_logins'] + data['failed_logins']
        if total_attempts > 3 and (data['failed_logins'] / total_attempts) > 0.7:
            return True

        # ØªØ³Ø¬ÙŠÙ„Ø§Øª ÙƒØ«ÙŠØ±Ø©
        if data['registrations'] > 2:
            return True

        return False

    def cleanup_old_data(self):
        """ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©"""
        current_time = int(time.time())
        threshold = current_time - (7 * 24 * 3600)  # Ø£Ø³Ø¨ÙˆØ¹

        old_ips = [ip for ip, data in self.ip_history.items()
                  if data['last_activity'] < threshold]

        for ip in old_ips:
            del self.ip_history[ip]

# Ø¥Ù†Ø´Ø§Ø¡ instance Ù…Ù† Ù†Ø¸Ø§Ù… Ø§Ù„Ø³Ù…Ø¹Ø©
ip_reputation = IPReputationSystem()


# Ø§Ù„Ø³Ø·Ø± Ø§Ù„Ø°ÙŠ ÙŠÙ„ÙŠ Ø§Ù„ÙƒØªÙ„Ø© Ù…Ø¨Ø§Ø´Ø±Ø©:
@app.route('/verify-email', methods=['GET', 'POST'])
@advanced_rate_limit(per_minute=10, per_hour=30)
def verify_email():
    if 'user_email' not in session:
        flash('ÙŠØ¬Ø¨ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø£ÙˆÙ„Ø§Ù‹', 'error')
        return redirect(url_for('register'))

    if request.method == 'POST':
        client_fingerprint = smart_limiter.get_client_fingerprint(request)

        try:
            code = request.form['code'].strip()
            user = User.query.filter_by(email=session['user_email']).first()

            if not user:
                flash('Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯', 'error')
                return redirect(url_for('register'))

            if user.is_verified:
                flash('Ø­Ø³Ø§Ø¨Ùƒ Ù…ÙØ¹Ù„ Ø¨Ø§Ù„ÙØ¹Ù„', 'success')
                session.pop('user_email', None)
                return redirect(url_for('login'))

            if not user.verification_code:
                flash('Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙƒÙˆØ¯ ØªÙØ¹ÙŠÙ„ØŒ ÙŠØ±Ø¬Ù‰ Ø·Ù„Ø¨ ÙƒÙˆØ¯ Ø¬Ø¯ÙŠØ¯', 'error')
                return render_template('verify_email.html')

            if user.verification_code != code:
                smart_limiter.update_reputation(client_fingerprint, 'invalid_form')
                flash('ÙƒÙˆØ¯ Ø§Ù„ØªÙØ¹ÙŠÙ„ ØºÙŠØ± ØµØ­ÙŠØ­', 'error')
                return render_template('verify_email.html')

            if datetime.utcnow() > user.code_expiry:
                smart_limiter.update_reputation(client_fingerprint, 'invalid_form')
                flash('ÙƒÙˆØ¯ Ø§Ù„ØªÙØ¹ÙŠÙ„ Ù…Ù†ØªÙ‡ÙŠ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©ØŒ ÙŠØ±Ø¬Ù‰ Ø·Ù„Ø¨ ÙƒÙˆØ¯ Ø¬Ø¯ÙŠØ¯', 'error')
                return render_template('verify_email.html')

            # ØªÙØ¹ÙŠÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
            user.is_verified = True
            user.verification_code = None
            user.code_expiry = None
            db.session.commit()

            # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³Ù…Ø¹Ø© Ø¥ÙŠØ¬Ø§Ø¨ÙŠØ§Ù‹ Ù„ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø­Ø³Ø§Ø¨
            smart_limiter.update_reputation(client_fingerprint, 'account_verified')

            session.pop('user_email', None)
            flash('ØªÙ… ØªÙØ¹ÙŠÙ„ Ø­Ø³Ø§Ø¨Ùƒ Ø¨Ù†Ø¬Ø§Ø­! ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„', 'success')
            return redirect(url_for('login'))

        except Exception as e:
            app.logger.error(f"Verification error: {e}")
            smart_limiter.update_reputation(client_fingerprint, 'invalid_form')
            flash('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªÙØ¹ÙŠÙ„ØŒ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰', 'error')

    return render_template('verify_email.html')

@app.route('/login', methods=['GET', 'POST'])
@advanced_rate_limit(per_minute=8, per_hour=30, block_on_abuse=True)
def login():
    if request.method == 'GET':
        # Ø¥Ù†Ø´Ø§Ø¡ time token Ù„Ù„Ù†Ù…ÙˆØ°Ø¬
        time_token, timestamp = generate_time_token()
        return render_template('login.html', time_token=time_token, timestamp=timestamp)

    if request.method == 'POST':
        client_fingerprint = smart_limiter.get_client_fingerprint(request)

        try:
            # ÙØ­Øµ Captcha Ø§Ù„Ø´Ø§Ù…Ù„
            if not comprehensive_captcha_check(request, request.form):
                smart_limiter.update_reputation(client_fingerprint, 'honeypot_hit')
                flash('ÙØ´Ù„ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø£Ù…Ø§Ù†. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.', 'error')
                time_token, timestamp = generate_time_token()
                return render_template('login.html', time_token=time_token, timestamp=timestamp)

            email = request.form['email'].lower().strip()
            password = request.form['password']

            user = User.query.filter_by(email=email).first()

            if user and check_password_hash(user.password_hash, password):
                if user.is_verified:
                    login_user(user)

                    # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³Ù…Ø¹Ø© Ø¥ÙŠØ¬Ø§Ø¨ÙŠØ§Ù‹ Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø§Ù„Ù†Ø§Ø¬Ø­
                    smart_limiter.update_reputation(client_fingerprint, 'successful_action', user.id)

                    next_page = request.args.get('next')
                    return redirect(next_page) if next_page else redirect(url_for('dashboard'))
                else:
                    # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ ØºÙŠØ± Ù…ÙØ¹Ù„ØŒ Ù†ÙˆØ¬Ù‡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„ØµÙØ­Ø© Ø§Ù„ØªÙØ¹ÙŠÙ„
                    session['user_email'] = email
                    flash('Ø­Ø³Ø§Ø¨Ùƒ ØºÙŠØ± Ù…ÙØ¹Ù„. ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ÙƒÙˆØ¯ ØªÙØ¹ÙŠÙ„ Ø¬Ø¯ÙŠØ¯ Ø¥Ù„Ù‰ Ø¨Ø±ÙŠØ¯Ùƒ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ', 'error')

                    # Ø¥Ø±Ø³Ø§Ù„ ÙƒÙˆØ¯ ØªÙØ¹ÙŠÙ„ Ø¬Ø¯ÙŠØ¯
                    verification_code = generate_verification_code()
                    code_expiry = datetime.utcnow() + timedelta(minutes=10)

                    user.verification_code = verification_code
                    user.code_expiry = code_expiry
                    db.session.commit()

                    send_verification_email(email, verification_code)
                    return redirect(url_for('verify_email'))
            else:
                # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³Ù…Ø¹Ø© Ø³Ù„Ø¨ÙŠØ§Ù‹ Ù„ÙØ´Ù„ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„
                smart_limiter.update_reputation(client_fingerprint, 'failed_login')
                flash('Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø£Ùˆ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©', 'error')

        except Exception as e:
            app.logger.error(f"Login error: {e}")
            smart_limiter.update_reputation(client_fingerprint, 'failed_login')
            flash('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ØŒ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰', 'error')

        # ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ø®Ø·Ø£ØŒ Ø¥Ù†Ø´Ø§Ø¡ tokens Ø¬Ø¯ÙŠØ¯Ø©
        time_token, timestamp = generate_time_token()
        return render_template('login.html', time_token=time_token, timestamp=timestamp)

@app.route('/logout')
@login_required
def logout():
    logout_user()
    flash('ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬ Ø¨Ù†Ø¬Ø§Ø­', 'success')
    return redirect(url_for('home'))

@app.route('/dashboard')
@login_required
def dashboard():
    try:
        if current_user.is_admin:
            return redirect(url_for('admin_dashboard'))

        orders = Order.query.filter_by(user_id=current_user.id).order_by(Order.created_at.desc()).all()
        return render_template('dashboard.html', user=current_user, orders=orders)
    except Exception as e:
        print(f"Dashboard error: {e}")
        flash('Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª', 'error')
        return render_template('dashboard.html', user=current_user, orders=[])

@app.route('/new-order', methods=['GET', 'POST'])
@login_required
@advanced_rate_limit(per_minute=5, per_hour=30)
def new_order():
    # ÙØ­Øµ Ø§ÙƒØªÙ…Ø§Ù„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
    if not current_user.whatsapp or not current_user.preferred_platform or not current_user.preferred_payment:
        flash('ÙŠØ¬Ø¨ Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ Ø£ÙˆÙ„Ø§Ù‹ Ù‚Ø¨Ù„ ØªÙ‚Ø¯ÙŠÙ… Ø·Ù„Ø¨', 'warning')
        return redirect(url_for('profile'))

    if request.method == 'GET':
        platforms_data = [
            {
                'id': 'PS',
                'name': 'PlayStation',
                'icon': 'fab fa-playstation',
                'color': '#003087',
                'description': 'PlayStation 4 & 5'
            },
            {
                'id': 'Xbox',
                'name': 'Xbox',
                'icon': 'fab fa-xbox',
                'color': '#107C10',
                'description': 'Xbox One & Series X/S'
            },
            {
                'id': 'PC',
                'name': 'PC',
                'icon': 'fas fa-desktop',
                'color': '#FF6B00',
                'description': 'Origin & Steam'
            }
        ]

        payment_methods_data = [
            {
                'id': 'vodafone',
                'name': 'ÙÙˆØ¯Ø§ÙÙˆÙ† ÙƒØ§Ø´',
                'icon': 'fas fa-mobile-alt',
                'color': '#E60000',
                'description': 'ØªØ­ÙˆÙŠÙ„ ÙÙˆØ±ÙŠ'
            },
            {
                'id': 'etisalat',
                'name': 'Ø§ØªØµØ§Ù„Ø§Øª ÙƒØ§Ø´',
                'icon': 'fas fa-mobile-alt',
                'color': '#8CC63F',
                'description': 'ØªØ­ÙˆÙŠÙ„ ÙÙˆØ±ÙŠ'
            },
            {
                'id': 'orange',
                'name': 'Ø£ÙˆØ±Ù†Ø¬ ÙƒØ§Ø´',
                'icon': 'fas fa-mobile-alt',
                'color': '#FF7900',
                'description': 'ØªØ­ÙˆÙŠÙ„ ÙÙˆØ±ÙŠ'
            },
            {
                'id': 'instapay',
                'name': 'Ø¥Ù†Ø³ØªØ§ Ø¨Ø§ÙŠ',
                'icon': 'fas fa-university',
                'color': '#1E88E5',
                'description': 'Ø¨Ù†Ùƒ Ø¥Ù„Ù‰ Ø¨Ù†Ùƒ'
            },
            {
                'id': 'wallet',
                'name': 'Ù…Ø­ÙØ¸Ø© Ø¨Ù†ÙƒÙŠØ©',
                'icon': 'fas fa-wallet',
                'color': '#6B73FF',
                'description': 'Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨Ù†ÙˆÙƒ'
            }
        ]

        return render_template('new_order.html',
                             platforms=platforms_data,
                             payment_methods=payment_methods_data,
                             user=current_user)

    if request.method == 'POST':
        client_fingerprint = smart_limiter.get_client_fingerprint(request)

        try:
            # Ø¬Ù…Ø¹ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù†Ù…ÙˆØ°Ø¬
            platform = request.form.get('platform', '').strip()
            coins_amount = int(request.form.get('coins_amount', 0))
            payment_method = request.form.get('payment_method', '').strip()
            transfer_type = request.form.get('transfer_type', 'normal').strip()

            # Ø¨ÙŠØ§Ù†Ø§Øª EA (Ø§Ø®ØªÙŠØ§Ø±ÙŠØ©)
            ea_email = request.form.get('ea_email', '').strip()
            ea_password = request.form.get('ea_password', '').strip()
            backup_codes = request.form.get('backup_codes', '').strip()

            # Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©
            phone_number = request.form.get('phone_number', current_user.whatsapp or '').strip()
            notes = request.form.get('notes', '').strip()

            # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
            if not all([platform, coins_amount, payment_method]):
                flash('Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ù…Ø·Ù„ÙˆØ¨Ø©', 'error')
                return redirect(url_for('new_order'))

            if coins_amount < 300000:
                flash('Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„ÙƒÙˆÙŠÙ†Ø² Ù‡Ùˆ 300,000', 'error')
                return redirect(url_for('new_order'))

            # Ø­Ø³Ø§Ø¨ Ø§Ù„Ø³Ø¹Ø±
            price_info, price_error = calculate_price(platform, coins_amount, transfer_type)
            if price_error:
                flash(price_error, 'error')
                return redirect(url_for('new_order'))

            # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø·Ù„Ø¨
            order = Order(
                user_id=current_user.id,
                platform=platform,
                coins_amount=coins_amount,
                payment_method=payment_method,
                transfer_type=transfer_type,
                price=price_info['total_price'],
                phone_number=phone_number,
                notes=notes
            )

            # Ø¥Ø¶Ø§ÙØ© Ø¨ÙŠØ§Ù†Ø§Øª EA Ø¥Ø°Ø§ ØªÙˆÙØ±Øª (Ù…Ø¹ Ø§Ù„ØªØ´ÙÙŠØ±)
            if ea_email:
                order.ea_email = ea_email

            if ea_password:
                # ØªØ´ÙÙŠØ± ÙƒÙ„Ù…Ø© Ù…Ø±ÙˆØ± EA
                order.ea_password = generate_password_hash(ea_password)

            if backup_codes:
                # ØªØ´ÙÙŠØ± Ø£ÙƒÙˆØ§Ø¯ Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·
                order.backup_codes = generate_password_hash(backup_codes)

            db.session.add(order)
            db.session.commit()

            smart_limiter.update_reputation(client_fingerprint, 'successful_action', current_user.id)

            # Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± ØªÙ„ÙŠØ¬Ø±Ø§Ù… Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
            if current_user.telegram_id:
                order_data = {
                    'id': order.id,
                    'platform': platform,
                    'coins_amount': coins_amount,
                    'transfer_type': transfer_type,
                    'price': price_info['total_price'],
                    'payment_method': payment_method,
                    'phone_number': phone_number
                }

                telegram_system.send_order_notification(current_user.telegram_id, order_data)
                app.logger.info(f"Telegram notification sent for order {order.id}")

            flash(f'ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨Ùƒ Ø¨Ù†Ø¬Ø§Ø­! Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ù…ØªÙˆÙ‚Ø¹: {price_info["total_price"]} Ø¬Ù†ÙŠÙ‡', 'success')
            return redirect(url_for('dashboard'))

        except ValueError:
            flash('ÙƒÙ…ÙŠØ© Ø§Ù„ÙƒÙˆÙŠÙ†Ø² ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø±Ù‚Ù…Ø§Ù‹ ØµØ§Ù„Ø­Ø§Ù‹', 'error')
            return redirect(url_for('new_order'))
        except Exception as e:
            app.logger.error(f"New order error: {e}")
            smart_limiter.update_reputation(client_fingerprint, 'invalid_form', current_user.id)
            flash('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø·Ù„Ø¨ØŒ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰', 'error')
            return redirect(url_for('new_order'))


@app.route('/profile', methods=['GET', 'POST'])
@login_required
@advanced_rate_limit(per_minute=20, per_hour=100)
def profile():
    if request.method == 'GET':
        return render_template('profile.html', user=current_user)

    if request.method == 'POST':
        client_fingerprint = smart_limiter.get_client_fingerprint(request)

        try:
            # ÙØ­Øµ AJAX request
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                field = request.form.get('field')
                value = request.form.get(field, '').strip()

                # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ù‚Ù„ Ø§Ù„Ù…Ø­Ø¯Ø¯
                if hasattr(current_user, field):
                    setattr(current_user, field, value)
                    current_user.last_profile_update = datetime.utcnow()

                # Ù„Ø§ Ø­Ø§Ø¬Ø© Ù„Ø­ÙØ¸ profile_completed Ù„Ø£Ù†Ù‡ property Ù…Ø­Ø³ÙˆØ¨ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
                # current_user.profile_completed Ù…Ø­Ø³ÙˆØ¨ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ§Ù‹ Ø§Ù„Ø¢Ù†

                    db.session.commit()

                    smart_limiter.update_reputation(client_fingerprint, 'successful_action', current_user.id)

                    return jsonify({
                        'success': True,
                        'message': 'ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­',
                        'profile_completed': current_user.profile_completed
                    })
                else:
                    return jsonify({'success': False, 'message': 'Ø­Ù‚Ù„ ØºÙŠØ± ØµØ§Ù„Ø­'}), 400

            # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ø¹Ø§Ø¯ÙŠ
            else:
                current_user.whatsapp = request.form.get('whatsapp', '').strip()
                current_user.preferred_platform = request.form.get('preferred_platform', '').strip()
                current_user.preferred_payment = request.form.get('preferred_payment', '').strip()
                current_user.ea_email = request.form.get('ea_email', '').strip()
                current_user.last_profile_update = datetime.utcnow()

                # ÙØ­Øµ Ø§ÙƒØªÙ…Ø§Ù„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ
                current_user.profile_completed = check_profile_completion(current_user)

                db.session.commit()

                smart_limiter.update_reputation(client_fingerprint, 'successful_action', current_user.id)

                flash('ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ Ø¨Ù†Ø¬Ø§Ø­!', 'success')
                return redirect(url_for('profile'))

        except Exception as e:
            app.logger.error(f"Profile update error: {e}")
            smart_limiter.update_reputation(client_fingerprint, 'invalid_form', current_user.id)

            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return jsonify({'success': False, 'message': 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø­ÙØ¸'}), 500
            else:
                flash('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ­Ø¯ÙŠØ«ØŒ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰', 'error')
                return render_template('profile.html', user=current_user)

@app.route('/profile/telegram-link')
@login_required
@advanced_rate_limit(per_minute=5, per_hour=20)
def generate_telegram_link():
    """ØªÙˆÙ„ÙŠØ¯ Ø±Ø§Ø¨Ø· Ø±Ø¨Ø· Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…"""
    try:
        if not telegram_system.is_configured():
            return jsonify({
                'success': False,
                'message': 'Ø®Ø¯Ù…Ø© Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù… ØºÙŠØ± Ù…ØªØ§Ø­Ø© Ø­Ø§Ù„ÙŠØ§Ù‹'
            }), 503

        # ØªÙˆÙ„ÙŠØ¯ Ø±Ø§Ø¨Ø· Ù…Ø¹ Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø´ÙØ±
        import base64
        encoded_user_id = base64.b64encode(str(current_user.id).encode()).decode()

        telegram_link = f"https://t.me/{telegram_system.bot_username}?start={encoded_user_id}"

        return jsonify({
            'success': True,
            'telegram_link': telegram_link,
            'bot_username': telegram_system.bot_username,
            'is_linked': bool(current_user.telegram_id),
            'instructions': [
                'Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø±Ø§Ø¨Ø· Ø£Ø¯Ù†Ø§Ù‡',
                'Ø§Ø¶ØºØ· "Start" ÙÙŠ Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…',
                'Ø£Ø±Ø³Ù„ Ø£ÙŠ Ø±Ø³Ø§Ù„Ø© Ù„Ù„Ø¨ÙˆØª',
                'Ø³ÙŠØªÙ… Ø§Ù„Ø±Ø¨Ø· ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹'
            ]
        })

    except Exception as e:
        app.logger.error(f"Error generating Telegram link: {e}")
        return jsonify({
            'success': False,
            'message': 'Ø®Ø·Ø£ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ Ø±Ø§Ø¨Ø· Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…'
        }), 500

@app.route('/profile/completion-status')
@login_required
def profile_completion_status():
    """Ø¥Ø±Ø¬Ø§Ø¹ Ø­Ø§Ù„Ø© Ø§ÙƒØªÙ…Ø§Ù„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ"""
    try:
        steps = {
            'whatsapp': bool(current_user.whatsapp and current_user.whatsapp.strip()),
            'platform': bool(current_user.preferred_platform and current_user.preferred_platform.strip()),
            'payment': bool(current_user.preferred_payment and current_user.preferred_payment.strip()),
            'ea_email': bool(current_user.ea_email and current_user.ea_email.strip()),
            'telegram': bool(current_user.telegram_id and current_user.telegram_id.strip()),
            'profile': current_user.profile_completed or False
        }

        completed_count = sum(1 for completed in steps.values() if completed)
        total_count = len(steps)
        percentage = round((completed_count / total_count) * 100)

        return jsonify({
            'success': True,
            'steps': steps,
            'completed_count': completed_count,
            'total_count': total_count,
            'percentage': percentage,
            'profile_completed': current_user.profile_completed
        })

    except Exception as e:
        app.logger.error(f"Profile completion status error: {e}")
        return jsonify({'success': False, 'message': 'Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª'}), 500

@app.route('/resend-verification', methods=['POST'])
@advanced_rate_limit(per_minute=2, per_hour=5, block_on_abuse=True)
def resend_verification():
    if 'user_email' not in session:
        flash('ÙŠØ¬Ø¨ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø£ÙˆÙ„Ø§Ù‹', 'error')
        return redirect(url_for('register'))

    client_fingerprint = smart_limiter.get_client_fingerprint(request)

    try:
        user = User.query.filter_by(email=session['user_email']).first()

        if not user:
            smart_limiter.update_reputation(client_fingerprint, 'invalid_form')
            flash('Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯', 'error')
            return redirect(url_for('register'))

        if user.is_verified:
            flash('Ø­Ø³Ø§Ø¨Ùƒ Ù…ÙØ¹Ù„ Ø¨Ø§Ù„ÙØ¹Ù„', 'success')
            return redirect(url_for('login'))

        # Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙˆØ¯ Ø¬Ø¯ÙŠØ¯
        verification_code = generate_verification_code()
        code_expiry = datetime.utcnow() + timedelta(minutes=10)

        user.verification_code = verification_code
        user.code_expiry = code_expiry
        db.session.commit()

        # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯
        if send_verification_email(user.email, verification_code):
            smart_limiter.update_reputation(client_fingerprint, 'successful_action')
            flash('ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ÙƒÙˆØ¯ ØªÙØ¹ÙŠÙ„ Ø¬Ø¯ÙŠØ¯ Ø¥Ù„Ù‰ Ø¨Ø±ÙŠØ¯Ùƒ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ', 'success')
        else:
            smart_limiter.update_reputation(client_fingerprint, 'invalid_form')
            flash('Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ', 'error')

    except Exception as e:
        app.logger.error(f"Resend verification error: {e}")
        smart_limiter.update_reputation(client_fingerprint, 'invalid_form')
        flash('Ø­Ø¯Ø« Ø®Ø·Ø£ØŒ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰', 'error')

    return redirect(url_for('verify_email'))

def calculate_price(platform, coins_amount, transfer_type='normal'):
    """Ø­Ø³Ø§Ø¨ Ø³Ø¹Ø± Ø§Ù„Ø·Ù„Ø¨ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù†ØµØ© ÙˆØ§Ù„ÙƒÙ…ÙŠØ© ÙˆÙ†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„"""

    # Ø£Ø³Ø¹Ø§Ø± Ø§Ù„ÙƒÙˆÙŠÙ†Ø² Ù„ÙƒÙ„ Ù…Ù†ØµØ© (Ù„ÙƒÙ„ Ù…Ù„ÙŠÙˆÙ† ÙƒÙˆÙŠÙ†)
    base_prices = {
        'PS': 850,      # PlayStation
        'Xbox': 850,    # Xbox (Ù†ÙØ³ PlayStation)
        'PC': 950       # PC Ø£ØºÙ„Ù‰ Ù‚Ù„ÙŠÙ„Ø§Ù‹
    }

    # Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„
    transfer_multipliers = {
        'normal': 1.0,    # Ø¹Ø§Ø¯ÙŠ
        'instant': 1.15   # ÙÙˆØ±ÙŠ (Ø²ÙŠØ§Ø¯Ø© 15%)
    }

    # ØªØ®ÙÙŠØ¶Ø§Øª Ø§Ù„ÙƒÙ…ÙŠØ©
    quantity_discounts = [
        (10000000, 0.95),   # 10+ Ù…Ù„ÙŠÙˆÙ†: Ø®ØµÙ… 5%
        (25000000, 0.90),   # 25+ Ù…Ù„ÙŠÙˆÙ†: Ø®ØµÙ… 10%
        (50000000, 0.85),   # 50+ Ù…Ù„ÙŠÙˆÙ†: Ø®ØµÙ… 15%
        (100000000, 0.80)   # 100+ Ù…Ù„ÙŠÙˆÙ†: Ø®ØµÙ… 20%
    ]

    # Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰
    if coins_amount < 300000:
        return None, "Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ 300,000 ÙƒÙˆÙŠÙ†"

    # Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
    base_price = base_prices.get(platform, base_prices['PS'])
    millions = coins_amount / 1000000
    total_price = base_price * millions

    # ØªØ·Ø¨ÙŠÙ‚ ØªØ®ÙÙŠØ¶ Ø§Ù„ÙƒÙ…ÙŠØ©
    discount_rate = 1.0
    for threshold, rate in quantity_discounts:
        if coins_amount >= threshold:
            discount_rate = rate
            break

    total_price *= discount_rate

    # ØªØ·Ø¨ÙŠÙ‚ Ù…Ø¹Ø§Ù…Ù„ Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„
    transfer_rate = transfer_multipliers.get(transfer_type, 1.0)
    total_price *= transfer_rate

    # Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¥Ø¶Ø§ÙÙŠØ©
    price_info = {
        'total_price': round(total_price, 2),
        'base_price_per_million': base_price,
        'millions': round(millions, 2),
        'discount_rate': discount_rate,
        'discount_percent': round((1 - discount_rate) * 100, 1) if discount_rate < 1 else 0,
        'transfer_type': transfer_type,
        'transfer_fee': round(total_price * (transfer_rate - 1), 2) if transfer_rate > 1 else 0
    }

    return price_info, None

@app.route('/telegram-webhook', methods=['POST'])
@advanced_rate_limit(per_minute=100, per_hour=1000, skip_trusted=True)
def telegram_webhook():
    """Ù…Ø¹Ø§Ù„Ø¬ webhook Ù„Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…"""
    try:
        update_data = request.get_json()

        if not update_data:
            return jsonify({'status': 'error', 'message': 'No data received'}), 400

        # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØªØ­Ø¯ÙŠØ«
        result = telegram_system.process_telegram_update(update_data)

        if result:
            app.logger.info(f"Telegram update processed: {result.get('action', 'unknown')}")

            # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙŠØ±ÙŠØ¯ Ø±Ø¨Ø· Ø­Ø³Ø§Ø¨Ù‡
            if result.get('action') == 'start' and result.get('website_user_id'):
                # Ø±Ø¨Ø· Ø­Ø³Ø§Ø¨ Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù… Ù…Ø¹ Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…ÙˆÙ‚Ø¹
                link_telegram_account(result.get('website_user_id'), result.get('user_id'), result.get('username'))

            return jsonify({'status': 'ok'}), 200
        else:
            return jsonify({'status': 'ignored'}), 200

    except Exception as e:
        app.logger.error(f"Telegram webhook error: {e}")
        return jsonify({'status': 'error', 'message': str(e)}), 500

def link_telegram_account(website_user_id: str, telegram_user_id: str, telegram_username: str = None):
    """Ø±Ø¨Ø· Ø­Ø³Ø§Ø¨ Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù… Ù…Ø¹ Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…ÙˆÙ‚Ø¹"""
    try:
        user = User.query.get(int(website_user_id))

        if user:
            user.telegram_id = telegram_user_id
            user.telegram_username = telegram_username
            user.last_profile_update = datetime.utcnow()

            # ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§ÙƒØªÙ…Ø§Ù„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ
            user.profile_completed = check_profile_completion(user)

            db.session.commit()

            # Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© ØªØ£ÙƒÙŠØ¯
            success_message = f"""
âœ… <b>ØªÙ… Ø±Ø¨Ø· Ø­Ø³Ø§Ø¨Ùƒ Ø¨Ù†Ø¬Ø§Ø­!</b>

ğŸ‰ Ù…Ø±Ø­Ø¨Ø§Ù‹ {user.email}!

Ø³ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø±Ø§Øª ÙÙˆØ±ÙŠØ© Ø¹Ù†:
â€¢ Ø·Ù„Ø¨Ø§ØªÙƒ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© ğŸ“‹
â€¢ ØªØ­Ø¯ÙŠØ«Ø§Øª Ø§Ù„Ø­Ø§Ù„Ø© ğŸ”„
â€¢ Ø§Ù„Ø¹Ø±ÙˆØ¶ Ø§Ù„Ø®Ø§ØµØ© ğŸ

Ø´ÙƒØ±Ø§Ù‹ Ù„Ø§Ø®ØªÙŠØ§Ø±Ùƒ Ø´Ù‡Ø¯ Ø§Ù„Ø³Ù†ÙŠÙˆØ±Ø©! ğŸš€
            """

            telegram_system.send_message(telegram_user_id, success_message.strip())

            app.logger.info(f"Telegram account linked: User {website_user_id} -> Telegram {telegram_user_id}")
            return True
        else:
            app.logger.warning(f"User not found for linking: {website_user_id}")
            return False

    except Exception as e:
        app.logger.error(f"Error linking Telegram account: {e}")
        return False

@app.route('/api/calculate-price', methods=['POST'])
@login_required
@advanced_rate_limit(per_minute=30, per_hour=200)
def api_calculate_price():
    """API Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ø³Ø¹Ø± Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ§Ù‹"""
    try:
        data = request.get_json()

        platform = data.get('platform')
        coins_amount = int(data.get('coins_amount', 0))
        transfer_type = data.get('transfer_type', 'normal')

        if not platform or coins_amount <= 0:
            return jsonify({
                'success': False,
                'message': 'Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ§Ù„Ø­Ø©'
            }), 400

        price_info, error = calculate_price(platform, coins_amount, transfer_type)

        if error:
            return jsonify({
                'success': False,
                'message': error
            }), 400

        return jsonify({
            'success': True,
            'price_info': price_info
        })

    except Exception as e:
        app.logger.error(f"Price calculation error: {e}")
        return jsonify({
            'success': False,
            'message': 'Ø®Ø·Ø£ ÙÙŠ Ø­Ø³Ø§Ø¨ Ø§Ù„Ø³Ø¹Ø±'
        }), 500

@app.route('/admin')
@login_required
@advanced_rate_limit(per_minute=30, per_hour=200)
def admin_dashboard():
    try:
        if not current_user.is_admin:
            flash('Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„Ù„ÙˆØµÙˆÙ„ Ù„Ù‡Ø°Ù‡ Ø§Ù„ØµÙØ­Ø©', 'error')
            return redirect(url_for('dashboard'))

        # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª
        page = request.args.get('page', 1, type=int)
        per_page = 10
        status_filter = request.args.get('status', 'all')
        date_filter = request.args.get('date', 'all')
        search_query = request.args.get('search', '')

        # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø´Ø§Ù…Ù„Ø©
        stats = calculate_admin_statistics()

        # ÙÙ„ØªØ±Ø© Ø§Ù„Ø·Ù„Ø¨Ø§Øª
        orders_query = Order.query

        if status_filter != 'all':
            orders_query = orders_query.filter(Order.status == status_filter)

        if date_filter != 'all':
            if date_filter == 'today':
                today = datetime.utcnow().date()
                orders_query = orders_query.filter(
                    db.func.date(Order.created_at) == today
                )
            elif date_filter == 'week':
                week_ago = datetime.utcnow() - timedelta(days=7)
                orders_query = orders_query.filter(Order.created_at >= week_ago)
            elif date_filter == 'month':
                month_ago = datetime.utcnow() - timedelta(days=30)
                orders_query = orders_query.filter(Order.created_at >= month_ago)

        if search_query:
            orders_query = orders_query.join(User).filter(
                db.or_(
                    User.email.contains(search_query),
                    Order.platform.contains(search_query),
                    Order.payment_method.contains(search_query)
                )
            )

        # ØªØ±ØªÙŠØ¨ ÙˆØªÙ‚Ø³ÙŠÙ… Ø§Ù„ØµÙØ­Ø§Øª
        orders = orders_query.order_by(Order.created_at.desc()).paginate(
            page=page, per_page=per_page, error_out=False
        )

        # Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ø¹ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
        users = User.query.all()
        users_stats = calculate_users_statistics(users)

        # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø£Ù…Ø§Ù†
        security_stats = calculate_security_statistics()

        # Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø±Ø³ÙˆÙ… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠØ©
        charts_data = generate_charts_data()

        return render_template('admin_dashboard.html',
                             orders=orders,
                             users=users,
                             stats=stats,
                             users_stats=users_stats,
                             security_stats=security_stats,
                             charts_data=charts_data,
                             status_filter=status_filter,
                             date_filter=date_filter,
                             search_query=search_query)

    except Exception as e:
        app.logger.error(f"Admin dashboard error: {e}")
        flash('Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª', 'error')
        return render_template('admin_dashboard.html',
                             orders=[], users=[], stats={},
                             users_stats={}, security_stats={}, charts_data={})

def calculate_admin_statistics():
    """Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø´Ø§Ù…Ù„Ø© Ù„Ù„Ø¥Ø¯Ø§Ø±Ø©"""
    try:
        now = datetime.utcnow()
        today = now.date()
        week_ago = now - timedelta(days=7)
        month_ago = now - timedelta(days=30)

        # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
        total_users = User.query.count()
        verified_users = User.query.filter_by(is_verified=True).count()
        new_users_today = User.query.filter(
            db.func.date(User.created_at) == today
        ).count()
        new_users_week = User.query.filter(User.created_at >= week_ago).count()
        telegram_linked = User.query.filter(User.telegram_id.isnot(None)).count()

        # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø·Ù„Ø¨Ø§Øª
        total_orders = Order.query.count()
        pending_orders = Order.query.filter_by(status='pending').count()
        completed_orders = Order.query.filter_by(status='completed').count()
        cancelled_orders = Order.query.filter_by(status='cancelled').count()
        orders_today = Order.query.filter(
            db.func.date(Order.created_at) == today
        ).count()
        orders_week = Order.query.filter(Order.created_at >= week_ago).count()

        # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù…Ø§Ù„ÙŠØ©
        total_revenue = db.session.query(db.func.sum(Order.price)).filter(
            Order.status == 'completed'
        ).scalar() or 0
        revenue_week = db.session.query(db.func.sum(Order.price)).filter(
            Order.status == 'completed',
            Order.created_at >= week_ago
        ).scalar() or 0
        revenue_month = db.session.query(db.func.sum(Order.price)).filter(
            Order.status == 'completed',
            Order.created_at >= month_ago
        ).scalar() or 0

        # Ù…ØªÙˆØ³Ø· Ù‚ÙŠÙ…Ø© Ø§Ù„Ø·Ù„Ø¨
        avg_order_value = db.session.query(db.func.avg(Order.price)).filter(
            Order.status == 'completed'
        ).scalar() or 0

        # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ù†ØµØ§Øª
        platform_stats = db.session.query(
            Order.platform,
            db.func.count(Order.id).label('count')
        ).group_by(Order.platform).all()

        # Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ­ÙˆÙŠÙ„
        completion_rate = (completed_orders / max(1, total_orders)) * 100

        return {
            'users': {
                'total': total_users,
                'verified': verified_users,
                'verification_rate': (verified_users / max(1, total_users)) * 100,
                'new_today': new_users_today,
                'new_week': new_users_week,
                'telegram_linked': telegram_linked,
                'telegram_rate': (telegram_linked / max(1, total_users)) * 100
            },
            'orders': {
                'total': total_orders,
                'pending': pending_orders,
                'completed': completed_orders,
                'cancelled': cancelled_orders,
                'today': orders_today,
                'week': orders_week,
                'completion_rate': completion_rate
            },
            'revenue': {
                'total': round(total_revenue, 2),
                'week': round(revenue_week, 2),
                'month': round(revenue_month, 2),
                'avg_order': round(avg_order_value, 2)
            },
            'platforms': {p.platform: p.count for p in platform_stats}
        }

    except Exception as e:
        app.logger.error(f"Error calculating admin statistics: {e}")
        return {}

def calculate_users_statistics(users):
    """Ø­Ø³Ø§Ø¨ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„ØªÙØµÙŠÙ„ÙŠØ©"""
    try:
        now = datetime.utcnow()

        # ØªØµÙ†ÙŠÙ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø­Ø³Ø¨ Ø§Ù„Ù†Ø´Ø§Ø·
        active_users = []
        inactive_users = []

        for user in users:
            user_orders = Order.query.filter_by(user_id=user.id).count()
            last_order = Order.query.filter_by(user_id=user.id).order_by(
                Order.created_at.desc()
            ).first()

            days_since_last_order = None
            if last_order:
                days_since_last_order = (now - last_order.created_at).days

            user_data = {
                'user': user,
                'orders_count': user_orders,
                'last_order_date': last_order.created_at if last_order else None,
                'days_since_last_order': days_since_last_order
            }

            if user_orders > 0 and (not days_since_last_order or days_since_last_order <= 30):
                active_users.append(user_data)
            else:
                inactive_users.append(user_data)

        return {
            'active_users': active_users,
            'inactive_users': inactive_users,
            'activity_rate': (len(active_users) / max(1, len(users))) * 100
        }

    except Exception as e:
        app.logger.error(f"Error calculating users statistics: {e}")
        return {'active_users': [], 'inactive_users': [], 'activity_rate': 0}

def calculate_security_statistics():
    """Ø­Ø³Ø§Ø¨ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø£Ù…Ø§Ù†"""
    try:
        current_time = int(time.time())

        # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø­Ø¸Ø± ÙˆØ§Ù„Ø³Ù…Ø¹Ø©
        total_tracked_ips = len(smart_limiter.suspicious_ips)
        blocked_ips = sum(1 for data in smart_limiter.suspicious_ips.values()
                         if data.get('score', 0) < -50)
        trusted_ips = sum(1 for data in smart_limiter.suspicious_ips.values()
                         if data.get('score', 0) > 50)

        # Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¬Ù„Ø³Ø§Øª Ø§Ù„Ù…Ø´Ø¨ÙˆÙ‡Ø©
        active_blocks = sum(1 for data in suspicious_sessions.values()
                          if data.get('blocked_until', 0) > current_time)
        high_risk_sessions = sum(1 for data in suspicious_sessions.values()
                               if data.get('suspicious_score', 0) >= 10)

        # Ø­Ø³Ø§Ø¨ Ù†Ù‚Ø§Ø· Ø§Ù„Ø£Ù…Ø§Ù† Ø§Ù„Ø¹Ø§Ù…Ø©
        security_score = calculate_overall_security_score(
            total_tracked_ips, blocked_ips, active_blocks, high_risk_sessions
        )

        return {
            'tracked_ips': total_tracked_ips,
            'blocked_ips': blocked_ips,
            'trusted_ips': trusted_ips,
            'active_blocks': active_blocks,
            'high_risk_sessions': high_risk_sessions,
            'security_score': security_score,
            'threat_level': get_threat_level(security_score)
        }

    except Exception as e:
        app.logger.error(f"Error calculating security statistics: {e}")
        return {}

def calculate_overall_security_score(tracked_ips, blocked_ips, active_blocks, high_risk):
    """Ø­Ø³Ø§Ø¨ Ù†Ù‚Ø§Ø· Ø§Ù„Ø£Ù…Ø§Ù† Ø§Ù„Ø¹Ø§Ù…Ø©"""
    base_score = 100

    if tracked_ips > 0:
        blocked_ratio = (blocked_ips / tracked_ips) * 100
        if blocked_ratio > 20:
            base_score -= 30
        elif blocked_ratio > 10:
            base_score -= 15
        elif blocked_ratio > 5:
            base_score -= 5

    base_score -= min(30, active_blocks * 5)
    base_score -= min(20, high_risk * 3)

    return max(0, min(100, base_score))

def get_threat_level(security_score):
    """ØªØ­Ø¯ÙŠØ¯ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªÙ‡Ø¯ÙŠØ¯"""
    if security_score >= 90:
        return {'level': 'low', 'text': 'Ù…Ù†Ø®ÙØ¶', 'color': 'success'}
    elif security_score >= 70:
        return {'level': 'medium', 'text': 'Ù…ØªÙˆØ³Ø·', 'color': 'warning'}
    elif security_score >= 50:
        return {'level': 'high', 'text': 'Ø¹Ø§Ù„ÙŠ', 'color': 'danger'}
    else:
        return {'level': 'critical', 'text': 'Ø­Ø±Ø¬', 'color': 'danger'}

def generate_charts_data():
    """ØªÙˆÙ„ÙŠØ¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø±Ø³ÙˆÙ… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠØ©"""
    try:
        now = datetime.utcnow()

        # Ø¨ÙŠØ§Ù†Ø§Øª Ø¢Ø®Ø± 7 Ø£ÙŠØ§Ù…
        days_data = []
        for i in range(7):
            date = (now - timedelta(days=i)).date()
            orders_count = Order.query.filter(
                db.func.date(Order.created_at) == date
            ).count()
            users_count = User.query.filter(
                db.func.date(User.created_at) == date
            ).count()

            days_data.append({
                'date': date.strftime('%Y-%m-%d'),
                'orders': orders_count,
                'users': users_count
            })

        days_data.reverse()  # ØªØ±ØªÙŠØ¨ Ù…Ù† Ø§Ù„Ø£Ù‚Ø¯Ù… Ù„Ù„Ø£Ø­Ø¯Ø«

        # ØªÙˆØ²ÙŠØ¹ Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø·Ù„Ø¨Ø§Øª
        status_distribution = db.session.query(
            Order.status,
            db.func.count(Order.id).label('count')
        ).group_by(Order.status).all()

        # ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ù…Ù†ØµØ§Øª
        platform_distribution = db.session.query(
            Order.platform,
            db.func.count(Order.id).label('count')
        ).group_by(Order.platform).all()

        return {
            'daily_activity': days_data,
            'status_distribution': [{'status': s.status, 'count': s.count} for s in status_distribution],
            'platform_distribution': [{'platform': p.platform, 'count': p.count} for p in platform_distribution]
        }

    except Exception as e:
        app.logger.error(f"Error generating charts data: {e}")
        return {}

@app.route('/admin/order/<int:order_id>/update', methods=['POST'])
@login_required
def update_order_status(order_id):
    try:
        if not current_user.is_admin:
            return jsonify({'error': 'Unauthorized'}), 403

        new_status = request.json.get('status')

        order = Order.query.get_or_404(order_id)
        old_status = order.status
        order.status = new_status
        db.session.commit()

        # Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± ØªÙ„ÙŠØ¬Ø±Ø§Ù… Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¹Ù† ØªØºÙŠÙŠØ± Ø§Ù„Ø­Ø§Ù„Ø©
        if order.user.telegram_id and old_status != new_status:
            telegram_system.send_status_update(
                order.user.telegram_id,
                order_id,
                old_status,
                new_status
            )
            app.logger.info(f"Status update notification sent for order {order_id}")

        return jsonify({'success': True})
    except Exception as e:
        print(f"Update order error: {e}")
        return jsonify({'error': 'Server error'}), 500

def init_database():
    """Initialize database and create default admin user"""
    try:
        # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
        db.create_all()
        print("Database tables created successfully")

        # Ø¥ØµÙ„Ø§Ø­ Ø·Ø§Ø±Ø¦ Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        try:
            emergency_fix_success = emergency_fix_database()
            if not emergency_fix_success:
                print("âš ï¸ Emergency repair had issues, trying standard update...")
        except Exception as e:
            print(f"âš ï¸ Emergency repair failed: {e}")

        # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© Ø¨Ø·Ø±ÙŠÙ‚Ø© Ø¢Ù…Ù†Ø©
        try:
            if 'postgresql' in str(db.engine.url):
                update_existing_tables()  # PostgreSQL version
            else:
                update_existing_tables_sqlite()  # SQLite version
        except Exception as e:
            print(f"Warning: Table update failed: {e}")
            db.session.rollback()

        # ØªØ­Ø³ÙŠÙ† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        try:
            optimize_database()
        except Exception as e:
            print(f"Warning: Database optimization failed: {e}")
            db.session.rollback()

        # ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
        try:
            cleanup_old_verification_codes()
        except Exception as e:
            print(f"Warning: Cleanup failed: {e}")
            db.session.rollback()

        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù…Ø³ØªØ®Ø¯Ù… Ø¥Ø¯Ø§Ø±ÙŠ
        admin_email = os.environ.get('ADMIN_EMAIL', 'admin@example.com')
        admin = User.query.filter_by(email=admin_email).first()

        if not admin:
            print("=" * 60)
            print("Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø³ØªØ®Ø¯Ù… Ø¥Ø¯Ø§Ø±ÙŠ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª")
            print("ÙŠØ±Ø¬Ù‰ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø¥Ø¯Ø§Ø±ÙŠ Ø¹Ø¨Ø± Ø§Ù„Ø±Ø§Ø¨Ø·:")
            print(f"https://senioraa.onrender.com/setup-admin")
            print("=" * 60)
        else:
            print("Admin user already exists")

    except Exception as e:
        print(f"Database initialization error: {e}")

def update_existing_tables():
    """ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© Ù„Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© - PostgreSQL Compatible"""
    try:
        with app.app_context():
            # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø© - PostgreSQL compatible
            new_columns = [
                ('users', 'whatsapp', 'VARCHAR(20)'),
                ('users', 'preferred_platform', 'VARCHAR(10)'),
                ('users', 'preferred_payment', 'VARCHAR(50)'),
                ('users', 'ea_email', 'VARCHAR(100)'),
                ('users', 'telegram_id', 'VARCHAR(50)'),
                ('users', 'telegram_username', 'VARCHAR(50)'),
                ('users', 'profile_completed', 'BOOLEAN DEFAULT FALSE'),  # ØªØµØ­ÙŠØ­ PostgreSQL
                ('users', 'last_profile_update', 'TIMESTAMP'),
                ('orders', 'ea_email', 'VARCHAR(100)'),
                ('orders', 'ea_password', 'VARCHAR(200)'),
                ('orders', 'backup_codes', 'TEXT'),
                ('orders', 'transfer_type', "VARCHAR(20) DEFAULT 'normal'"),  # ØªØµØ­ÙŠØ­ PostgreSQL
                ('orders', 'notes', 'TEXT'),
                ('orders', 'price', 'DECIMAL(10,2)'),
                ('orders', 'phone_number', 'VARCHAR(20)'),
                ('orders', 'updated_at', 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP')
            ]

            for table, column, column_type in new_columns:
                try:
                    # ÙØ­Øµ ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø¹Ù…ÙˆØ¯ Ø£ÙˆÙ„Ø§Ù‹
                    check_query = text("""
                        SELECT column_name
                        FROM information_schema.columns
                        WHERE table_name = :table_name
                        AND column_name = :column_name
                    """)

                    result = db.session.execute(check_query, {
                        'table_name': table,
                        'column_name': column
                    }).fetchone()

                    if not result:
                        # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¹Ù…ÙˆØ¯ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
                        alter_query = text(f'ALTER TABLE {table} ADD COLUMN {column} {column_type}')
                        db.session.execute(alter_query)
                        db.session.commit()
                        print(f"Added column {column} to {table}")
                    else:
                        print(f"Column {column} already exists in {table}")

                except Exception as e:
                    db.session.rollback()
                    error_msg = str(e).lower()
                    if "already exists" in error_msg or "duplicate column" in error_msg:
                        print(f"Column {column} already exists in {table}")
                    else:
                        print(f"Error adding column {column} to {table}: {e}")
                        # Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¹Ù…ÙˆØ¯ Ø¨Ø·Ø±ÙŠÙ‚Ø© Ù…Ø®ØªÙ„ÙØ© Ù„Ù„Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ù…Ø¹Ø±ÙˆÙØ©
                        if "profile_completed" in column and "boolean" in error_msg:
                            try:
                                # Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø¶Ø§ÙØ© Ø¨Ø¯ÙˆÙ† default Ø£ÙˆÙ„Ø§Ù‹
                                alter_query_simple = text(f'ALTER TABLE {table} ADD COLUMN {column} BOOLEAN')
                                db.session.execute(alter_query_simple)
                                # Ø¥Ø¶Ø§ÙØ© default Ø¨Ø¹Ø¯ÙŠÙ†
                                default_query = text(f'ALTER TABLE {table} ALTER COLUMN {column} SET DEFAULT FALSE')
                                db.session.execute(default_query)
                                db.session.commit()
                                print(f"Added column {column} to {table} (fixed boolean issue)")
                            except Exception as fix_error:
                                print(f"Failed to fix {column}: {fix_error}")
                                db.session.rollback()
                        elif "transfer_type" in column and "cannot use column reference" in error_msg:
                            try:
                                # Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø¶Ø§ÙØ© Ø¨Ø¯ÙˆÙ† default Ø£ÙˆÙ„Ø§Ù‹
                                alter_query_simple = text(f'ALTER TABLE {table} ADD COLUMN {column} VARCHAR(20)')
                                db.session.execute(alter_query_simple)
                                # Ø¥Ø¶Ø§ÙØ© default Ø¨Ø¹Ø¯ÙŠÙ†
                                default_query = text(f"ALTER TABLE {table} ALTER COLUMN {column} SET DEFAULT 'normal'")
                                db.session.execute(default_query)
                                db.session.commit()
                                print(f"Added column {column} to {table} (fixed default issue)")
                            except Exception as fix_error:
                                print(f"Failed to fix {column}: {fix_error}")
                                db.session.rollback()

            print("Database tables updated successfully")

    except Exception as e:
        print(f"Database update error: {e}")
        db.session.rollback()

def safe_column_exists(table_name, column_name):
    """ÙØ­Øµ Ø¢Ù…Ù† Ù„ÙˆØ¬ÙˆØ¯ Ø¹Ù…ÙˆØ¯ ÙÙŠ Ø§Ù„Ø¬Ø¯ÙˆÙ„"""
    try:
        check_query = text("""
            SELECT column_name
            FROM information_schema.columns
            WHERE table_name = :table_name
            AND column_name = :column_name
        """)

        result = db.session.execute(check_query, {
            'table_name': table_name,
            'column_name': column_name
        }).fetchone()

        return result is not None

    except Exception as e:
        print(f"Error checking column existence: {e}")
        return False

def emergency_fix_database():
    """Ø¥ØµÙ„Ø§Ø­ Ø·Ø§Ø±Ø¦ Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ø­Ù„ Ø§Ù„Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ø­Ø±Ø¬Ø©"""
    try:
        print("ğŸš¨ Starting emergency database repair...")

        # Ø¥ØµÙ„Ø§Ø­ profile_completed column
        try:
            # ÙØ­Øµ Ø¥Ø°Ø§ Ø§Ù„Ø¹Ù…ÙˆØ¯ Ù…ÙˆØ¬ÙˆØ¯
            check_profile = text("""
                SELECT column_name
                FROM information_schema.columns
                WHERE table_name = 'users'
                AND column_name = 'profile_completed'
            """)
            result = db.session.execute(check_profile).fetchone()

            if not result:
                # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¹Ù…ÙˆØ¯ Ø¨Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©
                add_profile = text('ALTER TABLE users ADD COLUMN profile_completed BOOLEAN')
                db.session.execute(add_profile)

                set_default = text('ALTER TABLE users ALTER COLUMN profile_completed SET DEFAULT FALSE')
                db.session.execute(set_default)

                # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©
                update_existing = text('UPDATE users SET profile_completed = FALSE WHERE profile_completed IS NULL')
                db.session.execute(update_existing)

                db.session.commit()
                print("âœ… Fixed profile_completed column")
            else:
                print("âœ… profile_completed column already exists")

        except Exception as e:
            print(f"âŒ Error fixing profile_completed: {e}")
            db.session.rollback()

        # Ø¥ØµÙ„Ø§Ø­ transfer_type column
        try:
            check_transfer = text("""
                SELECT column_name
                FROM information_schema.columns
                WHERE table_name = 'orders'
                AND column_name = 'transfer_type'
            """)
            result = db.session.execute(check_transfer).fetchone()

            if not result:
                # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¹Ù…ÙˆØ¯ Ø¨Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©
                add_transfer = text('ALTER TABLE orders ADD COLUMN transfer_type VARCHAR(20)')
                db.session.execute(add_transfer)

                set_default = text("ALTER TABLE orders ALTER COLUMN transfer_type SET DEFAULT 'normal'")
                db.session.execute(set_default)

                # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©
                update_existing = text("UPDATE orders SET transfer_type = 'normal' WHERE transfer_type IS NULL")
                db.session.execute(update_existing)

                db.session.commit()
                print("âœ… Fixed transfer_type column")
            else:
                print("âœ… transfer_type column already exists")

        except Exception as e:
            print(f"âŒ Error fixing transfer_type: {e}")
            db.session.rollback()

        print("ğŸ‰ Emergency repair completed successfully!")
        return True

    except Exception as e:
        print(f"ğŸ’¥ Emergency repair failed: {e}")
        db.session.rollback()
        return False

def safe_migration():
    """Migration Ø¢Ù…Ù† ÙŠØªØ¬Ù†Ø¨ Ù…Ø´Ø§ÙƒÙ„ SQLAlchemy Ù…Ø¹ Ø§Ù„Ù€ columns Ø§Ù„Ù…ÙÙ‚ÙˆØ¯Ø©"""
    try:
        print("ğŸ”„ Starting safe database migration...")

        # ÙØ­Øµ Ø­Ø§Ù„Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø£ÙˆÙ„Ø§Ù‹
        try:
            # Ø§Ø³ØªØ®Ø¯Ø§Ù… raw SQL Ù„Ù„ÙØ­Øµ
            result = db.session.execute(text("SELECT table_name FROM information_schema.tables WHERE table_schema = 'public'")).fetchall()
            existing_tables = [row[0] for row in result]

            if 'users' not in existing_tables or 'orders' not in existing_tables:
                print("âŒ Core tables missing, creating basic structure...")
                db.create_all()
                print("âœ… Basic tables created")
        except Exception as e:
            print(f"âš ï¸ Table check failed: {e}")
            # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ÙƒÙ€ fallback
            try:
                db.create_all()
                print("âœ… Fallback table creation completed")
            except Exception as create_error:
                print(f"âŒ Failed to create tables: {create_error}")
                return False

        # Ø¥Ø¶Ø§ÙØ© columns Ù…ÙÙ‚ÙˆØ¯Ø© ÙˆØ§Ø­Ø¯ ÙˆØ§Ø­Ø¯ Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ø®Ø·Ø§Ø¡ PostgreSQL
        missing_columns = []

        # ÙØ­Øµ columns ÙÙŠ users table
        try:
            users_check = db.session.execute(text("""
                SELECT column_name
                FROM information_schema.columns
                WHERE table_name = 'users'
            """)).fetchall()
            users_columns = [row[0] for row in users_check]
        except Exception as e:
            print(f"âŒ Cannot check users columns: {e}")
            users_columns = []

        required_user_columns = {
            'whatsapp': 'VARCHAR(20)',
            'preferred_platform': 'VARCHAR(10)',
            'preferred_payment': 'VARCHAR(50)',
            'ea_email': 'VARCHAR(100)',
            'telegram_id': 'VARCHAR(50)',
            'telegram_username': 'VARCHAR(50)',
            'last_profile_update': 'TIMESTAMP'
        }

        for col_name, col_type in required_user_columns.items():
            if col_name not in users_columns:
                missing_columns.append(('users', col_name, col_type, ''))

        # ÙØ­Øµ columns ÙÙŠ orders table
        try:
            orders_check = db.session.execute(text("""
                SELECT column_name
                FROM information_schema.columns
                WHERE table_name = 'orders'
            """)).fetchall()
            orders_columns = [row[0] for row in orders_check]
        except Exception as e:
            print(f"âŒ Cannot check orders columns: {e}")
            orders_columns = []

        required_order_columns = {
            'ea_email': 'VARCHAR(100)',
            'ea_password': 'VARCHAR(200)',
            'backup_codes': 'TEXT',
            'transfer_type': 'VARCHAR(20)',
            'notes': 'TEXT',
            'price': 'DECIMAL(10,2)',
            'phone_number': 'VARCHAR(20)',
            'updated_at': 'TIMESTAMP'
        }

        for col_name, col_type in required_order_columns.items():
            if col_name not in orders_columns:
                default_val = "'normal'" if col_name == 'transfer_type' else "''" if 'VARCHAR' in col_type or col_type == 'TEXT' else '0.0' if 'DECIMAL' in col_type else 'NULL'
                missing_columns.append(('orders', col_name, col_type, default_val))

        # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù€ columns Ø§Ù„Ù…ÙÙ‚ÙˆØ¯Ø©
        for table, column, column_type, default_value in missing_columns:
            try:
                # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¹Ù…ÙˆØ¯ Ø¨Ø¯ÙˆÙ† DEFAULT Ø£ÙˆÙ„Ø§Ù‹
                add_query = text(f'ALTER TABLE {table} ADD COLUMN IF NOT EXISTS {column} {column_type}')
                db.session.execute(add_query)

                # Ø¥Ø¶Ø§ÙØ© DEFAULT value Ù…Ù†ÙØµÙ„ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
                if default_value and default_value != 'NULL':
                    if column == 'transfer_type':
                        update_query = text(f"UPDATE {table} SET {column} = 'normal' WHERE {column} IS NULL")
                    else:
                        update_query = text(f"UPDATE {table} SET {column} = {default_value} WHERE {column} IS NULL")
                    db.session.execute(update_query)

                db.session.commit()
                print(f"âœ… Added column {column} to {table}")

            except Exception as e:
                print(f"âš ï¸ Error adding {column} to {table}: {e}")
                db.session.rollback()

        print("ğŸ‰ Safe migration completed!")
        return True

    except Exception as e:
        print(f"ğŸ’¥ Migration failed: {e}")
        db.session.rollback()
        return False

def force_database_repair():
    """Ø¥ØµÙ„Ø§Ø­ Ø¥Ø¬Ø¨Ø§Ø±ÙŠ Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø­Ø±Ø¬Ø©"""
    try:
        print("Starting database repair...")

        # Ø¥Ù†Ù‡Ø§Ø¡ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù€ transactions Ø§Ù„Ù…Ø¹Ù„Ù‚Ø©
        db.session.rollback()
        db.session.close()

        # Ø¥Ø¹Ø§Ø¯Ø© Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø§ØªØµØ§Ù„
        db.session.remove()

        # ÙØ­Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© Ø§Ù„Ù…ÙÙ‚ÙˆØ¯Ø© ÙˆØ§Ø­Ø¯Ø§Ù‹ ØªÙ„Ùˆ Ø§Ù„Ø¢Ø®Ø±
        repair_columns = [
            ('users', 'whatsapp', 'VARCHAR(20)'),
            ('users', 'preferred_platform', 'VARCHAR(10)'),
            ('users', 'preferred_payment', 'VARCHAR(50)'),
            ('users', 'ea_email', 'VARCHAR(100)'),
            ('users', 'telegram_id', 'VARCHAR(50)'),
            ('users', 'telegram_username', 'VARCHAR(50)'),
            ('users', 'profile_completed', 'BOOLEAN DEFAULT FALSE'),
            ('users', 'last_profile_update', 'TIMESTAMP'),
            ('orders', 'ea_email', 'VARCHAR(100)'),
            ('orders', 'ea_password', 'VARCHAR(200)'),
            ('orders', 'backup_codes', 'TEXT'),
            ('orders', 'transfer_type', 'VARCHAR(20) DEFAULT \'normal\''),
            ('orders', 'notes', 'TEXT'),
            ('orders', 'price', 'DECIMAL(10,2)'),
            ('orders', 'phone_number', 'VARCHAR(20)'),
            ('orders', 'updated_at', 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP')
        ]

# Ù‡Ù†Ø§ Ù„Ø§Ø²Ù… ØªØ¹Ø±Ù repair_columns
# Ù…Ø«Ø§Ù„:
repair_columns = [
    ("users", "email", "VARCHAR(255)"),
    ("products", "price", "DECIMAL(10,2)"),
]
  
# Ø§Ù„Ø³Ø·Ø± 4167
for table, column, column_type in repair_columns:
    # Ù‡Ù†Ø§ Ù„Ø§Ø²Ù… ÙŠÙƒÙˆÙ† ÙÙŠÙ‡ ÙƒÙˆØ¯ Ù…Ø²Ø§Ø­ Ù„Ù„Ø¯Ø§Ø®Ù„ (4 Ù…Ø³Ø§ÙØ§Øª) ÙŠØ®Øµ Ø­Ù„Ù‚Ø© for
    # Ù„Ùˆ Ù…ÙÙŠØ´ ÙƒÙˆØ¯ØŒ Ø­Ø· pass
    pass

def safe_add_column(table, column, column_type):
    """Ø¥Ø¶Ø§ÙØ© Ø¢Ù…Ù†Ø© Ù„Ù„Ø£Ø¹Ù…Ø¯Ø© Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡"""
    try:
        # ÙØ­Øµ ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø¹Ù…ÙˆØ¯ Ø£ÙˆÙ„Ø§Ù‹
        check_query = text(f"""
            SELECT column_name
            FROM information_schema.columns
            WHERE table_name = '{table}'
            AND column_name = '{column}'
        """)

        result = db.session.execute(check_query).fetchone()

        if not result:
            # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¹Ù…ÙˆØ¯
            alter_query = text(f'ALTER TABLE {table} ADD COLUMN {column} {column_type}')
            db.session.execute(alter_query)
            db.session.commit()
            print(f"âœ… Added column {column} to {table}")
            return True
        else:
            print(f"â„¹ï¸ Column {column} already exists in {table}")
            return True

    except Exception as e:
        print(f"âŒ Error adding column {column} to {table}: {e}")
        db.session.rollback()
        return False

        if safe_add_column(table, column, column_type):
                success_count += 1

        print(f"Database repair completed: {success_count}/{len(repair_columns)} columns processed")
        return True

    except Exception as e:
        print(f"Database repair failed: {e}")
        return False

def update_existing_tables_sqlite():
    """ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© Ù„Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© - SQLite"""
    try:
        with app.app_context():
            # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø© Ù„Ù€ SQLite
            new_columns = [
                ('users', 'whatsapp', 'TEXT'),
                ('users', 'preferred_platform', 'TEXT'),
                ('users', 'preferred_payment', 'TEXT'),
                ('users', 'ea_email', 'TEXT'),
                ('users', 'telegram_id', 'TEXT'),
                ('users', 'telegram_username', 'TEXT'),
                ('users', 'profile_completed', 'BOOLEAN DEFAULT 0'),
                ('users', 'last_profile_update', 'TIMESTAMP'),
                ('orders', 'ea_email', 'TEXT'),
                ('orders', 'ea_password', 'TEXT'),
                ('orders', 'backup_codes', 'TEXT'),
                ('orders', 'transfer_type', 'TEXT DEFAULT "normal"'),
                ('orders', 'notes', 'TEXT'),
                ('orders', 'price', 'REAL'),
                ('orders', 'phone_number', 'TEXT'),
                ('orders', 'updated_at', 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP')
            ]

            for table, column, column_type in new_columns:
                try:
                    # Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¹Ù…ÙˆØ¯
                    alter_query = text(f'ALTER TABLE {table} ADD COLUMN {column} {column_type}')
                    db.session.execute(alter_query)
                    db.session.commit()
                    print(f"Added column {column} to {table}")
                except Exception as e:
                    db.session.rollback()
                    error_msg = str(e).lower()
                    if "already exists" in error_msg or "duplicate column" in error_msg:
                        print(f"Column {column} already exists in {table}")
                    else:
                        print(f"Error adding column {column} to {table}: {e}")

            print("SQLite tables updated successfully")

    except Exception as e:
        print(f"SQLite update error: {e}")
        db.session.rollback()

def optimize_database():
    """ØªØ­Ø³ÙŠÙ† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙÙ‡Ø§Ø±Ø³"""
    try:
        with app.app_context():
            # Ø¥Ù†Ø´Ø§Ø¡ ÙÙ‡Ø§Ø±Ø³ Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… text() Ù„ØªØ­Ø¯ÙŠØ¯ SQL ØµØ±Ø§Ø­Ø©
            db.session.execute(text('CREATE INDEX IF NOT EXISTS idx_user_email ON users(email)'))
            db.session.execute(text('CREATE INDEX IF NOT EXISTS idx_user_verified ON users(is_verified)'))
            db.session.execute(text('CREATE INDEX IF NOT EXISTS idx_order_user_id ON orders(user_id)'))
            db.session.execute(text('CREATE INDEX IF NOT EXISTS idx_order_status ON orders(status)'))
            db.session.execute(text('CREATE INDEX IF NOT EXISTS idx_order_created_at ON orders(created_at)'))
            db.session.commit()
            print("Database indexes created successfully")
    except Exception as e:
        print(f"Database optimization error: {e}")
        db.session.rollback()

def cleanup_old_verification_codes():
    """ØªÙ†Ø¸ÙŠÙ Ø±Ù…ÙˆØ² Ø§Ù„ØªÙØ¹ÙŠÙ„ Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ© Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©"""
    try:
        with app.app_context():
            # ÙØ­Øµ ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ø£ÙˆÙ„Ø§Ù‹
            if not safe_column_exists('users', 'code_expiry'):
                print("Column code_expiry does not exist, skipping cleanup")
                return

            expired_time = datetime.utcnow() - timedelta(hours=24)

            # Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø¢Ù…Ù† ÙŠØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙ‚Ø·
            try:
                expired_users = User.query.filter(
                    User.code_expiry < expired_time,
                    User.is_verified == False
                ).all()

                for user in expired_users:
                    user.verification_code = None
                    user.code_expiry = None

                db.session.commit()
                print(f"Cleaned up {len(expired_users)} expired verification codes")

            except Exception as e:
                db.session.rollback()
                # Ø¥Ø°Ø§ ÙØ´Ù„ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…ØŒ Ø§Ø³ØªØ®Ø¯Ù… SQL Ù…Ø¨Ø§Ø´Ø±
                try:
                    cleanup_query = text("""
                        UPDATE users
                        SET verification_code = NULL, code_expiry = NULL
                        WHERE code_expiry < :expired_time
                        AND is_verified = false
                    """)

                    result = db.session.execute(cleanup_query, {'expired_time': expired_time})
                    db.session.commit()
                    print(f"Cleaned up verification codes using direct SQL")

                except Exception as sql_error:
                    print(f"SQL cleanup also failed: {sql_error}")
                    db.session.rollback()

    except Exception as e:
        print(f"Cleanup error: {e}")
        db.session.rollback()

@app.before_request
def before_request():
    """Ù…Ø¹Ø§Ù„Ø¬ Ù…Ø­Ø³Ù† Ù…Ø¹ ØªØ³Ø§Ù‡Ù„ Ù„Ù„Ù…ØµØ§Ø¯Ø± Ø§Ù„Ù…ÙˆØ«ÙˆÙ‚Ø©"""
    # ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø«Ø§Ø¨ØªØ© ÙˆØ§Ù„Ù€ endpoints Ø§Ù„Ù…Ø³ØªØ«Ù†Ø§Ø©
    if (request.path.startswith('/static/') or
        any(request.path.startswith(endpoint) for endpoint in EXEMPT_ENDPOINTS)):
        return

    client_ip = get_remote_address()

    # ÙØ­Øµ Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ØµØ¯Ø± Ù…ÙˆØ«ÙˆÙ‚
    is_trusted_ip = False
    try:
        ip_obj = ipaddress.ip_address(client_ip)
        if ip_obj.is_private or ip_obj.is_loopback:
            is_trusted_ip = True
    except:
        pass

    # 1. ÙØ­Øµ Ø§Ù„Ø­Ø¸Ø± Ø§Ù„Ù…Ø¤Ù‚Øª (Ø¥Ù„Ø§ Ù„Ù„Ù…ØµØ§Ø¯Ø± Ø§Ù„Ù…ÙˆØ«ÙˆÙ‚Ø©)
    if not is_trusted_ip:
        is_blocked, remaining_time = is_session_blocked(client_ip)
        if is_blocked:
            app.logger.warning(f"Blocked request from {client_ip}, remaining time: {remaining_time}s")
            return jsonify({
                'error': 'Access temporarily restricted',
                'retry_after': remaining_time
            }), 429

    # 2. ÙØ­Øµ User-Agent Ø§Ù„Ù…Ø´Ø¨ÙˆÙ‡ (Ù…Ø®ÙÙ Ù„Ù„Ù…ØµØ§Ø¯Ø± Ø§Ù„Ù…ÙˆØ«ÙˆÙ‚Ø©)
    user_agent = request.headers.get('User-Agent', '')

    if not is_trusted_ip:
        # Ù‚Ø§Ø¦Ù…Ø© Ù…Ø®ÙÙØ© Ù…Ù† User-Agents Ø§Ù„Ù…Ø´Ø¨ÙˆÙ‡Ø©
        highly_suspicious_agents = [
            'python-requests', 'curl', 'wget', 'scrapy', 'selenium'
        ]

        if any(agent in user_agent.lower() for agent in highly_suspicious_agents):
            if not smart_limiter.is_trusted_source(request):
                track_suspicious_session(client_ip, 'suspicious_user_agent', 1)  # ØªØ®ÙÙŠÙ Ø§Ù„Ø¹Ù‚ÙˆØ¨Ø©
                app.logger.warning(f"Suspicious user agent from {client_ip}: {user_agent}")

    # 3. ÙØ­Øµ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø³Ø±ÙŠØ¹Ø© (Ù…Ø®ÙÙ)
    if not is_trusted_ip:
        session_key = f"last_request_time:{client_ip}"
        last_request_time = session.get(session_key, 0)
        current_time = time.time()

        if current_time - last_request_time < 0.1:  # Ø£Ù‚Ù„ Ù…Ù† 0.1 Ø«Ø§Ù†ÙŠØ©
            track_suspicious_session(client_ip, 'rapid_requests', 1)

        session[session_key] = current_time

    # 4. ÙØ­Øµ Ø·Ù„Ø¨Ø§Øª 404 Ø§Ù„Ù…ØªÙƒØ±Ø±Ø© (Ù„Ù„Ø¬Ù…ÙŠØ¹)
    if request.endpoint is None:  # 404 error
        if not is_trusted_ip:
            track_suspicious_session(client_ip, '404_requests', 0.5)  # ØªØ®ÙÙŠÙ Ø§Ù„Ø¹Ù‚ÙˆØ¨Ø©
        app.logger.info(f"404 request from {client_ip}: {request.path}")

@app.after_request
def after_request(response):
    """Ù…Ø¹Ø§Ù„Ø¬ Ø¨Ø¹Ø¯ ÙƒÙ„ Ø·Ù„Ø¨ Ù„ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"""
    # ØªÙ†Ø¸ÙŠÙ Ø¯ÙˆØ±ÙŠ Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© (ÙƒÙ„ 100 Ø·Ù„Ø¨ ØªÙ‚Ø±ÙŠØ¨Ø§Ù‹)
    if random.randint(1, 100) == 1:
        smart_limiter._cleanup_old_data(int(time.time()))

    return response

# Error handlers
@app.errorhandler(404)
def not_found_error(error):
    return render_template('404.html'), 404

@app.errorhandler(500)
def internal_error(error):
    db.session.rollback()
    return render_template('500.html'), 500

# Initialize database when app starts
with app.app_context():
    try:
        # ØªÙ†ÙÙŠØ° migration Ø¢Ù…Ù† Ø£ÙˆÙ„Ø§Ù‹
        safe_migration()

        # Ø«Ù… ØªÙ†ÙÙŠØ° Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
        init_database()

    except Exception as e:
        app.logger.error(f"Database initialization error: {e}")
        print(f"Database initialization error: {e}")

    # Ø¥Ø¹Ø¯Ø§Ø¯ webhook Ù„Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù… ÙÙŠ production
    if not app.debug and telegram_system.is_configured():
        try:
            webhook_setup = telegram_system.setup_webhook()
            if webhook_setup:
                app.logger.info("Telegram webhook configured successfully")
            else:
                app.logger.warning("Failed to configure Telegram webhook")
        except Exception as e:
            app.logger.error(f"Error setting up Telegram webhook: {e}")

if __name__ == '__main__':
    app.run(debug=True)

============================================================
ğŸ“„ Ù…Ù„Ù: .\init_db.py
============================================================
from app import app, db, User
from werkzeug.security import generate_password_hash

def init_database():
    """Initialize database with tables and admin user"""
    with app.app_context():
        # Drop all tables and recreate (for development only)
        db.drop_all()
        db.create_all()
        
        # Create admin user
        admin = User(
            email='tetr48740@gmail.com',
            password_hash=generate_password_hash('123456'),
            is_verified=True,
            is_admin=True
        )
        
        db.session.add(admin)
        db.session.commit()
        
        print("Database initialized successfully!")
        print("Admin user created: tetr48740@gmail.com / 123456")

if __name__ == '__main__':
    init_database()

============================================================
ğŸ“„ Ù…Ù„Ù: .\quick_fix.py
============================================================
# Ø¥Ù†Ø´Ø§Ø¡ Ù‡Ø°Ø§ Ø§Ù„Ù…Ù„Ù Ù„Ù„ØªØ¬Ø±ÙŠØ¨ Ø§Ù„Ø³Ø±ÙŠØ¹
def fix_indentation_issues():
    """ÙØ­Øµ ÙˆØ¥ØµÙ„Ø§Ø­ Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„ØªØ¨Ø§Ø¹Ø¯"""
    with open('app.py', 'r', encoding='utf-8') as f:
        lines = f.readlines()
    
    fixed_lines = []
    for i, line in enumerate(lines):
        if 'with app.app_context():' in line:
            fixed_lines.append(line)
            # ØªØ£ÙƒØ¯ Ø¥Ù† Ø§Ù„Ø³Ø·Ø± Ø§Ù„Ù„ÙŠ Ø¨Ø¹Ø¯Ù‡ Ù…Ø´ function definition
            if i + 1 < len(lines) and lines[i + 1].strip().startswith('def '):
                fixed_lines.append('        pass  # placeholder\n')
        else:
            fixed_lines.append(line)
    
    with open('app_fixed.py', 'w', encoding='utf-8') as f:
        f.writelines(fixed_lines)
    
    print("Fixed file created as app_fixed.py")

if __name__ == '__main__':
    fix_indentation_issues()

============================================================
ğŸ“„ Ù…Ù„Ù: .\quick_start.py
============================================================
import os
import subprocess
import sys


def install_requirements():
    """ØªØ«Ø¨ÙŠØª Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª"""
    requirements = [
        "black",
        "isort",
        "flake8",
        "autopep8",
        "schedule",
        "watchdog",
        "pre-commit",
    ]

    for req in requirements:
        try:
            subprocess.run(
                [sys.executable, "-m", "pip", "install", req],
                check=True,
                capture_output=True,
            )
            print(f"âœ… ØªÙ… ØªØ«Ø¨ÙŠØª {req}")
        except subprocess.CalledProcessError:
            print(f"âŒ ÙØ´Ù„ ØªØ«Ø¨ÙŠØª {req}")


def setup_git():
    """Ø¥Ø¹Ø¯Ø§Ø¯ Git"""
    try:
        subprocess.run(["git", "init"], check=True, capture_output=True)
        print("âœ… ØªÙ… Ø¥Ø¹Ø¯Ø§Ø¯ Git")
    except:
        print("âŒ ÙØ´Ù„ Ø¥Ø¹Ø¯Ø§Ø¯ Git")


def main():
    print("ğŸš€ Ø¥Ø¹Ø¯Ø§Ø¯ Ù†Ø¸Ø§Ù… Ø§Ù„Ø£ØªÙ…ØªØ© Ø§Ù„ÙƒØ§Ù…Ù„Ø©...")

    # ØªØ«Ø¨ÙŠØª Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª
    install_requirements()

    # Ø¥Ø¹Ø¯Ø§Ø¯ Git
    setup_git()

    # ØªØ´ØºÙŠÙ„ Ø§Ù„Ù†Ø¸Ø§Ù…
    print("ğŸ¯ Ø¨Ø¯Ø¡ Ù†Ø¸Ø§Ù… Ø§Ù„Ø£ØªÙ…ØªØ©...")
    subprocess.run([sys.executable, "ultimate_auto_sync.py"])


if __name__ == "__main__":
    main()

============================================================
ğŸ“„ Ù…Ù„Ù: .\service_runner.py
============================================================
import os
import subprocess
import sys
import time
from pathlib import Path


class ServiceRunner:
    def __init__(self):
        self.script_path = Path(__file__).parent / "ultimate_auto_sync.py"
        self.pid_file = Path(__file__).parent / "auto_sync.pid"

    def start_service(self):
        """Ø¨Ø¯Ø¡ Ø§Ù„Ø®Ø¯Ù…Ø©"""
        if self.is_running():
            print("âœ… Ø§Ù„Ø®Ø¯Ù…Ø© ØªØ¹Ù…Ù„ Ø¨Ø§Ù„ÙØ¹Ù„")
            return

        # ØªØ´ØºÙŠÙ„ Ø§Ù„Ø³ÙƒØ±ÙŠØ¨Øª ÙÙŠ Ø§Ù„Ø®Ù„ÙÙŠØ©
        process = subprocess.Popen(
            [sys.executable, str(self.script_path)],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )

        # Ø­ÙØ¸ PID
        with open(self.pid_file, "w") as f:
            f.write(str(process.pid))

        print("ğŸš€ ØªÙ… Ø¨Ø¯Ø¡ Ø®Ø¯Ù…Ø© Ø§Ù„Ø£ØªÙ…ØªØ© Ø§Ù„ÙƒØ§Ù…Ù„Ø©")
        print(f"ğŸ“ PID: {process.pid}")

    def stop_service(self):
        """Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø®Ø¯Ù…Ø©"""
        if not self.is_running():
            print("âŒ Ø§Ù„Ø®Ø¯Ù…Ø© ØºÙŠØ± Ù…Ø´ØºÙ„Ø©")
            return

        try:
            with open(self.pid_file, "r") as f:
                pid = int(f.read().strip())

            os.kill(pid, 9)  # Ø¥ÙŠÙ‚Ø§Ù Ù‚Ø³Ø±ÙŠ
            os.remove(self.pid_file)
            print("â¹ï¸ ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø®Ø¯Ù…Ø©")

        except Exception as e:
            print(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø®Ø¯Ù…Ø©: {e}")

    def is_running(self):
        """ÙØ­Øµ Ø­Ø§Ù„Ø© Ø§Ù„Ø®Ø¯Ù…Ø©"""
        if not self.pid_file.exists():
            return False

        try:
            with open(self.pid_file, "r") as f:
                pid = int(f.read().strip())

            os.kill(pid, 0)  # ÙØ­Øµ Ø¨Ø¯ÙˆÙ† Ø¥ÙŠÙ‚Ø§Ù
            return True
        except:
            return False

    def status(self):
        """Ø­Ø§Ù„Ø© Ø§Ù„Ø®Ø¯Ù…Ø©"""
        if self.is_running():
            print("âœ… Ø§Ù„Ø®Ø¯Ù…Ø© ØªØ¹Ù…Ù„")
        else:
            print("âŒ Ø§Ù„Ø®Ø¯Ù…Ø© Ù…ØªÙˆÙ‚ÙØ©")


if __name__ == "__main__":
    runner = ServiceRunner()

    if len(sys.argv) > 1:
        command = sys.argv[1].lower()

        if command == "start":
            runner.start_service()
        elif command == "stop":
            runner.stop_service()
        elif command == "status":
            runner.status()
        elif command == "restart":
            runner.stop_service()
            time.sleep(2)
            runner.start_service()
        else:
            print("Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…ØªØ§Ø­Ø©: start, stop, status, restart")
    else:
        print("Ø§Ø³ØªØ®Ø¯Ø§Ù…: python service_runner.py [start|stop|status|restart]")

============================================================
ğŸ“„ Ù…Ù„Ù: .\telegram_bot.py
============================================================
import os
import json
import logging
from datetime import datetime
from typing import Optional, Dict, Any
import requests
from flask import current_app

class TelegramNotificationSystem:
    """Ù†Ø¸Ø§Ù… Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…"""
    
    def __init__(self, app=None):
        self.app = app
        self.bot_token = None
        self.bot_username = None
        self.webhook_url = None
        self.base_url = None
        
        if app:
            self.init_app(app)
    
    def init_app(self, app):
        """ØªÙ‡ÙŠØ¦Ø© Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù… Ù…Ø¹ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚"""
        self.app = app
        self.bot_token = os.environ.get('TELEGRAM_BOT_TOKEN')
        self.bot_username = os.environ.get('BOT_USERNAME', 'YourBot_bot')
        self.webhook_url = os.environ.get('TELEGRAM_WEBHOOK_URL')
        
        if self.bot_token:
            self.base_url = f"https://api.telegram.org/bot{self.bot_token}"
            app.logger.info("Telegram bot initialized successfully")
        else:
            app.logger.warning("Telegram bot token not configured")
    
    def is_configured(self) -> bool:
        """ÙØ­Øµ Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø¨ÙˆØª Ù…ÙØ¹Ø¯ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­"""
        return bool(self.bot_token and self.base_url)
    
    def send_message(self, chat_id: str, message: str, parse_mode: str = 'HTML') -> bool:
        """Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø­Ø¯Ø¯"""
        if not self.is_configured():
            self.app.logger.warning("Telegram bot not configured, skipping message")
            return False
        
        try:
            url = f"{self.base_url}/sendMessage"
            payload = {
                'chat_id': chat_id,
                'text': message,
                'parse_mode': parse_mode
            }
            
            response = requests.post(url, json=payload, timeout=10)
            result = response.json()
            
            if result.get('ok'):
                self.app.logger.info(f"Message sent successfully to {chat_id}")
                return True
            else:
                self.app.logger.error(f"Failed to send message: {result}")
                return False
                
        except Exception as e:
            self.app.logger.error(f"Error sending Telegram message: {e}")
            return False
    
    def send_order_notification(self, user_telegram_id: str, order_data: Dict[str, Any]) -> bool:
        """Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ø¹Ù† Ø·Ù„Ø¨ Ø¬Ø¯ÙŠØ¯"""
        if not user_telegram_id:
            return False
        
        # ØªÙ†Ø³ÙŠÙ‚ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø·Ù„Ø¨
        message = self.format_order_message(order_data)
        return self.send_message(user_telegram_id, message)
    
    def send_status_update(self, user_telegram_id: str, order_id: int, 
                          old_status: str, new_status: str) -> bool:
        """Ø¥Ø±Ø³Ø§Ù„ ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø·Ù„Ø¨"""
        if not user_telegram_id:
            return False
        
        status_messages = {
            'pending': 'â³ Ù‚ÙŠØ¯ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±',
            'processing': 'âš™ï¸ Ù‚ÙŠØ¯ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©',
            'completed': 'âœ… Ù…ÙƒØªÙ…Ù„',
            'cancelled': 'âŒ Ù…Ù„ØºÙŠ'
        }
        
        old_status_text = status_messages.get(old_status, old_status)
        new_status_text = status_messages.get(new_status, new_status)
        
        message = f"""
ğŸ”” <b>ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø·Ù„Ø¨ #{order_id}</b>

ğŸ“Š Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©: {old_status_text}
ğŸ†• Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©: {new_status_text}

ğŸ•’ ÙˆÙ‚Øª Ø§Ù„ØªØ­Ø¯ÙŠØ«: {datetime.now().strftime('%Y-%m-%d %H:%M')}

Ø´ÙƒØ±Ø§Ù‹ Ù„Ø§Ø®ØªÙŠØ§Ø±Ùƒ Ø´Ù‡Ø¯ Ø§Ù„Ø³Ù†ÙŠÙˆØ±Ø©! ğŸ®
        """
        
        return self.send_message(user_telegram_id, message.strip())
    
    def format_order_message(self, order_data: Dict[str, Any]) -> str:
        """ØªÙ†Ø³ÙŠÙ‚ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø·Ù„Ø¨ Ø§Ù„Ø¬Ø¯ÙŠØ¯"""
        platform_icons = {
            'PS': 'ğŸ® PlayStation',
            'Xbox': 'ğŸ¯ Xbox',
            'PC': 'ğŸ’» PC'
        }
        
        platform_text = platform_icons.get(order_data.get('platform', ''), order_data.get('platform', ''))
        coins_amount = order_data.get('coins_amount', 0)
        formatted_coins = f"{coins_amount:,}" if coins_amount else "ØºÙŠØ± Ù…Ø­Ø¯Ø¯"
        
        transfer_type_text = "âš¡ ÙÙˆØ±ÙŠ" if order_data.get('transfer_type') == 'instant' else "ğŸ•’ Ø¹Ø§Ø¯ÙŠ"
        price = order_data.get('price', 0)
        formatted_price = f"{price:,.2f}" if price else "ÙŠØªÙ… Ø­Ø³Ø§Ø¨Ù‡"
        
        message = f"""
ğŸ‰ <b>Ø·Ù„Ø¨ Ø¬Ø¯ÙŠØ¯ ØªÙ… Ø¥Ø±Ø³Ø§Ù„Ù‡ Ø¨Ù†Ø¬Ø§Ø­!</b>

ğŸ“‹ <b>ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø·Ù„Ø¨:</b>
ğŸ†” Ø±Ù‚Ù… Ø§Ù„Ø·Ù„Ø¨: #{order_data.get('id', 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙˆÙ„ÙŠØ¯')}
ğŸ® Ø§Ù„Ù…Ù†ØµØ©: {platform_text}
ğŸ’° Ø§Ù„ÙƒÙ…ÙŠØ©: {formatted_coins} ÙƒÙˆÙŠÙ†
âš¡ Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„: {transfer_type_text}
ğŸ’µ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ù…ØªÙˆÙ‚Ø¹: {formatted_price} Ø¬Ù†ÙŠÙ‡

ğŸ“± Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹: {order_data.get('payment_method', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}
ğŸ“ Ø±Ù‚Ù… Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨: {order_data.get('phone_number', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}

ğŸ•’ ÙˆÙ‚Øª Ø§Ù„Ø·Ù„Ø¨: {datetime.now().strftime('%Y-%m-%d %H:%M')}

Ø³ÙŠØªÙ… Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ùƒ Ù‚Ø±ÙŠØ¨Ø§Ù‹ Ù„Ø¥ØªÙ…Ø§Ù… Ø§Ù„Ø¹Ù…Ù„ÙŠØ©! 
Ø´ÙƒØ±Ø§Ù‹ Ù„Ø§Ø®ØªÙŠØ§Ø±Ùƒ Ø´Ù‡Ø¯ Ø§Ù„Ø³Ù†ÙŠÙˆØ±Ø©! ğŸš€
        """
        
        return message.strip()
    
    def setup_webhook(self) -> bool:
        """Ø¥Ø¹Ø¯Ø§Ø¯ webhook Ù„Ù„Ø¨ÙˆØª"""
        if not self.is_configured() or not self.webhook_url:
            self.app.logger.warning("Cannot setup webhook: missing configuration")
            return False
        
        try:
            url = f"{self.base_url}/setWebhook"
            payload = {
                'url': self.webhook_url,
                'allowed_updates': ['message', 'callback_query']
            }
            
            response = requests.post(url, json=payload, timeout=10)
            result = response.json()
            
            if result.get('ok'):
                self.app.logger.info("Webhook setup successfully")
                return True
            else:
                self.app.logger.error(f"Failed to setup webhook: {result}")
                return False
                
        except Exception as e:
            self.app.logger.error(f"Error setting up webhook: {e}")
            return False
    
    def process_telegram_update(self, update_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Ù…Ø¹Ø§Ù„Ø¬Ø© ØªØ­Ø¯ÙŠØ«Ø§Øª Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù… Ø§Ù„ÙˆØ§Ø±Ø¯Ø©"""
        try:
            if 'message' in update_data:
                return self.process_message(update_data['message'])
            elif 'callback_query' in update_data:
                return self.process_callback_query(update_data['callback_query'])
            
            return None
            
        except Exception as e:
            self.app.logger.error(f"Error processing Telegram update: {e}")
            return None
    
    def process_message(self, message: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ÙˆØ§Ø±Ø¯Ø©"""
        chat_id = str(message['chat']['id'])
        user_id = str(message['from']['id'])
        username = message['from'].get('username', '')
        text = message.get('text', '').strip()
        
        # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¨ÙˆØª
        if text.startswith('/start'):
            return self.handle_start_command(chat_id, user_id, username, text)
        elif text == '/help':
            return self.handle_help_command(chat_id)
        elif text == '/status':
            return self.handle_status_command(chat_id, user_id)
        else:
            return self.handle_regular_message(chat_id, text)
    
    def handle_start_command(self, chat_id: str, user_id: str, username: str, text: str) -> Dict[str, Any]:
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ù…Ø± /start"""
        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ø§Ù„Ø±Ø§Ø¨Ø· Ø¥Ø°Ø§ ÙˆÙØ¬Ø¯
        website_user_id = None
        if ' ' in text:
            try:
                import base64
                encoded_id = text.split(' ')[1]
                website_user_id = base64.b64decode(encoded_id).decode('utf-8')
            except:
                pass
        
        welcome_message = f"""
ğŸ® <b>Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø¨ÙˆØª Ø´Ù‡Ø¯ Ø§Ù„Ø³Ù†ÙŠÙˆØ±Ø©!</b>

Ø£Ù‡Ù„Ø§Ù‹ {username or 'ØµØ¯ÙŠÙ‚ÙŠ'}! ğŸ‘‹

ğŸ”” Ø³ÙŠÙ‚ÙˆÙ… Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª Ø¨Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø±Ø§Øª ÙÙˆØ±ÙŠØ© Ø¹Ù†:
â€¢ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© 
â€¢ ØªØ­Ø¯ÙŠØ«Ø§Øª Ø­Ø§Ù„Ø© Ø§Ù„Ø·Ù„Ø¨Ø§Øª
â€¢ Ø§Ù„Ø¹Ø±ÙˆØ¶ Ø§Ù„Ø®Ø§ØµØ© ÙˆØ§Ù„ØªØ®ÙÙŠØ¶Ø§Øª

ğŸ“± <b>Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…ØªØ§Ø­Ø©:</b>
/help - Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©
/status - Ø­Ø§Ù„Ø© Ø§Ù„Ø±Ø¨Ø· Ù…Ø¹ Ø­Ø³Ø§Ø¨Ùƒ

ğŸ”— Ù„Ø±Ø¨Ø· Ø­Ø³Ø§Ø¨ÙƒØŒ Ø§Ø³ØªØ®Ø¯Ù… Ø²Ø± "Ø±Ø¨Ø· Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…" ÙÙŠ Ù…ÙˆÙ‚Ø¹Ù†Ø§.

Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø¹Ø§Ø¦Ù„Ø© Ø´Ù‡Ø¯ Ø§Ù„Ø³Ù†ÙŠÙˆØ±Ø©! ğŸš€
        """
        
        self.send_message(chat_id, welcome_message.strip())
        
        return {
            'action': 'start',
            'chat_id': chat_id,
            'user_id': user_id,
            'username': username,
            'website_user_id': website_user_id
        }
    
    def handle_help_command(self, chat_id: str) -> Dict[str, Any]:
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ù…Ø± /help"""
        help_message = """
ğŸ¤– <b>Ù…Ø³Ø§Ø¹Ø¯Ø© Ø¨ÙˆØª Ø´Ù‡Ø¯ Ø§Ù„Ø³Ù†ÙŠÙˆØ±Ø©</b>

ğŸ“‹ <b>Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…ØªØ§Ø­Ø©:</b>
/start - Ø¨Ø¯Ø¡ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª
/help - Ø¹Ø±Ø¶ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©  
/status - ÙØ­Øµ Ø­Ø§Ù„Ø© Ø§Ù„Ø±Ø¨Ø·

ğŸ”” <b>Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ©:</b>
â€¢ Ø¥Ø´Ø¹Ø§Ø± ÙÙˆØ±ÙŠ Ø¹Ù†Ø¯ Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ Ø¬Ø¯ÙŠØ¯
â€¢ ØªØ­Ø¯ÙŠØ«Ø§Øª Ø­Ø§Ù„Ø© Ø§Ù„Ø·Ù„Ø¨ (Ù‚ÙŠØ¯ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©ØŒ Ù…ÙƒØªÙ…Ù„ØŒ Ø¥Ù„Ø®)
â€¢ ØªÙ†Ø¨ÙŠÙ‡Ø§Øª Ø§Ù„Ø¹Ø±ÙˆØ¶ Ø§Ù„Ø®Ø§ØµØ©

ğŸ”— <b>ÙƒÙŠÙÙŠØ© Ø§Ù„Ø±Ø¨Ø·:</b>
1. Ø³Ø¬Ù„ Ø¯Ø®ÙˆÙ„Ùƒ ÙÙŠ Ù…ÙˆÙ‚Ø¹ Ø´Ù‡Ø¯ Ø§Ù„Ø³Ù†ÙŠÙˆØ±Ø©
2. Ø§Ø°Ù‡Ø¨ Ù„Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ  
3. Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ "Ø±Ø¨Ø· Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…"
4. Ø£Ø±Ø³Ù„ Ø£ÙŠ Ø±Ø³Ø§Ù„Ø© Ù„Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª

ğŸ’¬ Ù„Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠØŒ ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§ Ø¹Ø¨Ø± Ø§Ù„Ù…ÙˆÙ‚Ø¹.
        """
        
        self.send_message(chat_id, help_message.strip())
        
        return {
            'action': 'help',
            'chat_id': chat_id
        }
    
    def handle_status_command(self, chat_id: str, user_id: str) -> Dict[str, Any]:
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ù…Ø± /status"""
        # Ù‡Ù†Ø§ ÙŠÙ…ÙƒÙ† ÙØ­Øµ Ø­Ø§Ù„Ø© Ø§Ù„Ø±Ø¨Ø· Ù…Ø¹ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        status_message = f"""
ğŸ“Š <b>Ø­Ø§Ù„Ø© Ø­Ø³Ø§Ø¨Ùƒ</b>

ğŸ†” Ù…Ø¹Ø±Ù Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…: <code>{user_id}</code>
ğŸ’¬ Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©: <code>{chat_id}</code>

ğŸ”— Ù„Ø±Ø¨Ø· Ø­Ø³Ø§Ø¨Ùƒ Ù…Ø¹ Ø§Ù„Ù…ÙˆÙ‚Ø¹:
1. Ø§Ø°Ù‡Ø¨ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ ÙÙŠ Ø§Ù„Ù…ÙˆÙ‚Ø¹
2. Ø§Ø¶ØºØ· "Ø±Ø¨Ø· Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…"  
3. Ø£Ø±Ø³Ù„ Ø£ÙŠ Ø±Ø³Ø§Ù„Ø© Ù‡Ù†Ø§

âœ… Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ Ø·Ø¨ÙŠØ¹ÙŠ
        """
        
        self.send_message(chat_id, status_message.strip())
        
        return {
            'action': 'status',
            'chat_id': chat_id,
            'user_id': user_id
        }
    
    def handle_regular_message(self, chat_id: str, text: str) -> Dict[str, Any]:
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø¹Ø§Ø¯ÙŠØ©"""
        response_message = """
Ø´ÙƒØ±Ø§Ù‹ Ù„Ø±Ø³Ø§Ù„ØªÙƒ! ğŸ“

ğŸ”— Ø¥Ø°Ø§ Ù„Ù… ØªÙ‚Ù… Ø¨Ø±Ø¨Ø· Ø­Ø³Ø§Ø¨Ùƒ Ø¨Ø¹Ø¯:
â€¢ Ø§Ø°Ù‡Ø¨ Ù„Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ ÙÙŠ Ø§Ù„Ù…ÙˆÙ‚Ø¹
â€¢ Ø§Ø¶ØºØ· "Ø±Ø¨Ø· Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…"
â€¢ Ø³ØªØªÙ… Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹

ğŸ’¬ Ù„Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©: /help
ğŸ“Š Ù„ÙØ­Øµ Ø§Ù„Ø­Ø§Ù„Ø©: /status

Ø³Ù†ØªÙˆØ§ØµÙ„ Ù…Ø¹Ùƒ Ù‚Ø±ÙŠØ¨Ø§Ù‹! ğŸš€
        """
        
        self.send_message(chat_id, response_message.strip())
        
        return {
            'action': 'message',
            'chat_id': chat_id,
            'text': text
        }

# Ø¥Ù†Ø´Ø§Ø¡ instance Ø¹Ø§Ù…
telegram_system = TelegramNotificationSystem()

============================================================
ğŸ“„ Ù…Ù„Ù: .\test_profile.py
============================================================
# Ù…Ù„Ù Ø§Ø®ØªØ¨Ø§Ø± Ø¨Ø³ÙŠØ·
from app import app, db, User

def test_profile_system():
    with app.app_context():
        # Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³ØªØ®Ø¯Ù… ØªØ¬Ø±ÙŠØ¨ÙŠ
        test_user = User.query.filter_by(email='test@example.com').first()
        
        if not test_user:
            from werkzeug.security import generate_password_hash
            test_user = User(
                email='test@example.com',
                password_hash=generate_password_hash('test123'),
                is_verified=True
            )
            db.session.add(test_user)
            db.session.commit()
            print("Ù…Ø³ØªØ®Ø¯Ù… ØªØ¬Ø±ÙŠØ¨ÙŠ ØªÙ… Ø¥Ù†Ø´Ø§Ø¤Ù‡")
        
        # Ø§Ø®ØªØ¨Ø§Ø± ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ
        test_user.whatsapp = '+201234567890'
        test_user.preferred_platform = 'PS'
        test_user.preferred_payment = 'vodafone'
        
        from app import check_profile_completion
        test_user.profile_completed = check_profile_completion(test_user)
        
        db.session.commit()
        
        print(f"Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ: {'Ù…ÙƒØªÙ…Ù„' if test_user.profile_completed else 'ØºÙŠØ± Ù…ÙƒØªÙ…Ù„'}")
        print("Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù†Ø¸Ø§Ù… Ù…ÙƒØªÙ…Ù„ âœ…")

if __name__ == '__main__':
    test_profile_system()

============================================================
ğŸ“„ Ù…Ù„Ù: .\ultimate_auto_sync.py
============================================================
#!/usr/bin/env python3
"""
Ù†Ø¸Ø§Ù… Ø§Ù„Ø£ØªÙ…ØªØ© Ø§Ù„Ø´Ø§Ù…Ù„Ø© Ù„Ù„Ø¨Ø±Ù…Ø¬Ø©
ÙŠÙ‚ÙˆÙ… Ø¨ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ÙƒÙˆØ¯ ÙˆØ¥ØµÙ„Ø§Ø­ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ ÙˆÙ…Ø²Ø§Ù…Ù†Ø© GitHub ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
"""

import json
import logging
import os
import subprocess
import threading
import time
from datetime import datetime
from pathlib import Path

import psutil
import schedule
from watchdog.events import FileSystemEventHandler
from watchdog.observers import Observer


class UltimateAutoSync:
    def __init__(self, project_path=None):
        self.project_path = project_path or os.getcwd()
        self.setup_logging()
        self.is_syncing = False
        self.pending_changes = False
        self.last_sync = None
        self.sync_stats = {
            "total_syncs": 0,
            "successful_syncs": 0,
            "failed_syncs": 0,
            "code_formats": 0,
            "git_pushes": 0,
        }

    def setup_logging(self):
        """Ø¥Ø¹Ø¯Ø§Ø¯ Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…"""
        logging.basicConfig(
            level=logging.INFO,
            format="%(asctime)s - %(levelname)s - %(message)s",
            handlers=[
                logging.FileHandler("auto_sync.log", encoding="utf-8"),
                logging.StreamHandler(),
            ],
        )
        self.logger = logging.getLogger(__name__)

    def check_dependencies(self):
        """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©"""
        required_tools = ["git", "python"]
        python_packages = ["black", "isort", "flake8", "autopep8"]

        # ÙØ­Øµ Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
        for tool in required_tools:
            try:
                subprocess.run([tool, "--version"], capture_output=True, check=True)
                self.logger.info(f"âœ… {tool} Ù…ÙˆØ¬ÙˆØ¯")
            except (subprocess.CalledProcessError, FileNotFoundError):
                self.logger.error(f"âŒ {tool} ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ - ÙŠØ¬Ø¨ ØªØ«Ø¨ÙŠØªÙ‡")
                return False

        # ÙØ­Øµ Ø­Ø²Ù… Python
        for package in python_packages:
            try:
                subprocess.run(
                    ["python", "-m", package, "--version"],
                    capture_output=True,
                    check=True,
                )
                self.logger.info(f"âœ… {package} Ù…ÙˆØ¬ÙˆØ¯")
            except (subprocess.CalledProcessError, FileNotFoundError):
                self.logger.warning(f"âš ï¸  {package} ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ - Ø³ÙŠØªÙ… Ø§Ù„ØªØ®Ø·ÙŠ")

        return True

    def format_code(self):
        """ØªÙ†Ø³ÙŠÙ‚ ÙˆØ¥ØµÙ„Ø§Ø­ Ø§Ù„ÙƒÙˆØ¯ Ø¨Ø´ÙƒÙ„ Ù…ØªÙ‚Ø¯Ù…"""
        if self.is_syncing:
            return False

        try:
            self.logger.info("ğŸ”§ Ø¨Ø¯Ø¡ ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ÙƒÙˆØ¯...")

            # 1. Black formatter
            try:
                result = subprocess.run(
                    ["python", "-m", "black", ".", "--line-length=88"],
                    capture_output=True,
                    text=True,
                    timeout=120,
                )
                if result.returncode == 0:
                    self.logger.info("âœ… ØªÙ… ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ÙƒÙˆØ¯ Ø¨Ù€ Black")
                    self.sync_stats["code_formats"] += 1
                else:
                    self.logger.warning(f"âš ï¸  Black warning: {result.stderr}")
            except (subprocess.TimeoutExpired, FileNotFoundError):
                self.logger.warning("âš ï¸  Black ØºÙŠØ± Ù…ØªØ§Ø­")

            # 2. isort Ù„Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯Ø§Øª
            try:
                result = subprocess.run(
                    ["python", "-m", "isort", ".", "--profile=black"],
                    capture_output=True,
                    text=True,
                    timeout=60,
                )
                if result.returncode == 0:
                    self.logger.info("âœ… ØªÙ… ØªØ±ØªÙŠØ¨ Ø§Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯Ø§Øª")
            except (subprocess.TimeoutExpired, FileNotFoundError):
                self.logger.warning("âš ï¸  isort ØºÙŠØ± Ù…ØªØ§Ø­")

            # 3. autopep8 Ù„Ù„Ø¥ØµÙ„Ø§Ø­Ø§Øª
            try:
                result = subprocess.run(
                    ["python", "-m", "autopep8", "--in-place", "--recursive", "."],
                    capture_output=True,
                    text=True,
                    timeout=120,
                )
                if result.returncode == 0:
                    self.logger.info("âœ… ØªÙ… Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡")
            except (subprocess.TimeoutExpired, FileNotFoundError):
                self.logger.warning("âš ï¸  autopep8 ØºÙŠØ± Ù…ØªØ§Ø­")

            # 4. flake8 Ù„Ù„ÙØ­Øµ
            try:
                result = subprocess.run(
                    ["python", "-m", "flake8", "."],
                    capture_output=True,
                    text=True,
                    timeout=60,
                )
                if result.returncode == 0:
                    self.logger.info("âœ… Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ø®Ø·Ø§Ø¡ ÙÙŠ Ø§Ù„ÙƒÙˆØ¯")
                else:
                    self.logger.info(
                        f"ğŸ“ ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ØªØ­Ø°ÙŠØ±Ø§Øª: {len(result.stdout.splitlines())} Ù…Ø´ÙƒÙ„Ø©"
                    )
            except (subprocess.TimeoutExpired, FileNotFoundError):
                self.logger.warning("âš ï¸  flake8 ØºÙŠØ± Ù…ØªØ§Ø­")

            return True

        except Exception as e:
            self.logger.error(f"âŒ Ø®Ø·Ø£ ÙÙŠ ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ÙƒÙˆØ¯: {e}")
            return False

    def check_git_status(self):
        """ÙØ­Øµ Ø­Ø§Ù„Ø© Git"""
        try:
            result = subprocess.run(
                ["git", "status", "--porcelain"],
                capture_output=True,
                text=True,
                timeout=30,
            )
            return result.stdout.strip()
        except:
            return ""

    def get_git_info(self):
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Git"""
        try:
            # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ø³Ù… Ø§Ù„ÙØ±Ø¹
            branch = subprocess.run(
                ["git", "rev-parse", "--abbrev-ref", "HEAD"],
                capture_output=True,
                text=True,
                timeout=10,
            )
            current_branch = branch.stdout.strip() if branch.returncode == 0 else "main"

            # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Remote URL
            remote = subprocess.run(
                ["git", "config", "--get", "remote.origin.url"],
                capture_output=True,
                text=True,
                timeout=10,
            )
            remote_url = remote.stdout.strip() if remote.returncode == 0 else "ØºÙŠØ± Ù…ØªØ§Ø­"

            return current_branch, remote_url
        except:
            return "main", "ØºÙŠØ± Ù…ØªØ§Ø­"

    def git_sync(self):
        """Ù…Ø²Ø§Ù…Ù†Ø© ÙƒØ§Ù…Ù„Ø© Ù…Ø¹ Git"""
        if self.is_syncing:
            return False

        try:
            self.logger.info("ğŸ”„ Ø¨Ø¯Ø¡ Ù…Ø²Ø§Ù…Ù†Ø© Git...")
            current_branch, remote_url = self.get_git_info()

            # 1. Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª
            try:
                subprocess.run(["git", "fetch", "origin"], check=True, timeout=60)
                self.logger.info("ğŸ“¥ ØªÙ… Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª Ù…Ù† GitHub")
            except subprocess.CalledProcessError:
                self.logger.warning("âš ï¸  Ù„Ù… ÙŠØªÙ… Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª")

            # 2. Ø¯Ù…Ø¬ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…ÙˆØ¬ÙˆØ¯Ø©
            try:
                result = subprocess.run(
                    ["git", "rev-list", "--count", f"HEAD..origin/{current_branch}"],
                    capture_output=True,
                    text=True,
                    timeout=30,
                )
                if result.returncode == 0 and result.stdout.strip() != "0":
                    subprocess.run(
                        ["git", "pull", "origin", current_branch],
                        check=True,
                        timeout=60,
                    )
                    self.logger.info("ğŸ“¥ ØªÙ… Ø¯Ù…Ø¬ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª")
            except:
                pass

            # 3. Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª ÙˆØ±ÙØ¹Ù‡Ø§
            if self.check_git_status():
                subprocess.run(["git", "add", "."], check=True, timeout=30)

                # Ø¥Ù†Ø´Ø§Ø¡ Ø±Ø³Ø§Ù„Ø© commit Ø°ÙƒÙŠØ©
                timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                commit_msg = f"ğŸ¤– Auto-sync: {timestamp}"

                # Ø¥Ø¶Ø§ÙØ© Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
                stats_msg = f" | Syncs: {self.sync_stats['total_syncs']}, Formats: {self.sync_stats['code_formats']}"
                full_msg = commit_msg + stats_msg

                subprocess.run(
                    ["git", "commit", "-m", full_msg], check=True, timeout=30
                )
                subprocess.run(
                    ["git", "push", "origin", current_branch], check=True, timeout=90
                )

                self.logger.info(f"âœ… ØªÙ… Ø±ÙØ¹ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª Ø¥Ù„Ù‰ {current_branch}")
                self.sync_stats["git_pushes"] += 1
                return True
            else:
                self.logger.debug("ğŸ“ Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØºÙŠÙŠØ±Ø§Øª Ù„Ù„Ø±ÙØ¹")
                return False

        except subprocess.CalledProcessError as e:
            self.logger.error(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ù…Ø²Ø§Ù…Ù†Ø© Git: {e}")
            self.sync_stats["failed_syncs"] += 1
            return False
        except Exception as e:
            self.logger.error(f"âŒ Ø®Ø·Ø£ Ø¹Ø§Ù… ÙÙŠ Git: {e}")
            return False

    def full_sync_cycle(self):
        """Ø¯ÙˆØ±Ø© Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø©"""
        if self.is_syncing:
            self.logger.debug("â¸ï¸  Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© Ø¬Ø§Ø±ÙŠØ© Ø¨Ø§Ù„ÙØ¹Ù„")
            return

        self.is_syncing = True
        self.sync_stats["total_syncs"] += 1

        try:
            self.logger.info("ğŸš€ Ø¨Ø¯Ø¡ Ø¯ÙˆØ±Ø© Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø©")
            start_time = time.time()

            # 1. ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ÙƒÙˆØ¯
            code_formatted = self.format_code()

            # 2. Ù…Ø²Ø§Ù…Ù†Ø© Git
            git_synced = self.git_sync()

            # 3. ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
            if code_formatted or git_synced:
                self.sync_stats["successful_syncs"] += 1
                self.pending_changes = False
                self.last_sync = datetime.now()

            duration = time.time() - start_time
            self.logger.info(f"âœ¨ Ø§Ù†ØªÙ‡Øª Ø¯ÙˆØ±Ø© Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© ÙÙŠ {duration:.2f} Ø«Ø§Ù†ÙŠØ©")

        except Exception as e:
            self.logger.error(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø¯ÙˆØ±Ø© Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø©: {e}")
            self.sync_stats["failed_syncs"] += 1
        finally:
            self.is_syncing = False

    def start_file_watcher(self):
        """Ù…Ø±Ø§Ù‚Ø¨ ØªØºÙŠÙŠØ±Ø§Øª Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…"""

        class SmartFileHandler(FileSystemEventHandler):
            def __init__(self, sync_instance):
                self.sync_instance = sync_instance
                self.last_event_time = {}

            def on_modified(self, event):
                if event.is_directory:
                    return

                # ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª ØºÙŠØ± Ø§Ù„Ù…Ù‡Ù…Ø©
                ignored_extensions = [
                    ".log",
                    ".tmp",
                    ".pyc",
                    ".pyo",
                    ".pyd",
                    "__pycache__",
                ]
                if any(event.src_path.endswith(ext) for ext in ignored_extensions):
                    return

                # ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ù…ÙƒØ±Ø±Ø©
                now = time.time()
                if event.src_path in self.last_event_time:
                    if now - self.last_event_time[event.src_path] < 2:
                        return

                self.last_event_time[event.src_path] = now

                # ÙÙ‚Ø· Ù…Ù„ÙØ§Øª Python ÙˆØ§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ù‡Ù…Ø©
                if event.src_path.endswith(
                    (".py", ".md", ".txt", ".yml", ".yaml", ".json")
                ):
                    self.sync_instance.pending_changes = True
                    self.sync_instance.logger.debug(
                        f"ğŸ“ ØªÙ… ØªØ¹Ø¯ÙŠÙ„: {os.path.basename(event.src_path)}"
                    )

        event_handler = SmartFileHandler(self)
        observer = Observer()
        observer.schedule(event_handler, self.project_path, recursive=True)
        observer.start()
        self.logger.info("ğŸ‘€ ØªÙ… Ø¨Ø¯Ø¡ Ù…Ø±Ø§Ù‚Ø¨ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø°ÙƒÙŠ")
        return observer

    def print_stats(self):
        """Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª"""
        stats_text = f"""
ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø£ØªÙ…ØªØ©:
â”œâ”€â”€ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø§Øª: {self.sync_stats['total_syncs']}
â”œâ”€â”€ Ù…Ø²Ø§Ù…Ù†Ø§Øª Ù†Ø§Ø¬Ø­Ø©: {self.sync_stats['successful_syncs']}
â”œâ”€â”€ Ù…Ø²Ø§Ù…Ù†Ø§Øª ÙØ§Ø´Ù„Ø©: {self.sync_stats['failed_syncs']}
â”œâ”€â”€ ØªÙ†Ø³ÙŠÙ‚Ø§Øª Ø§Ù„ÙƒÙˆØ¯: {self.sync_stats['code_formats']}
â”œâ”€â”€ Ø±ÙØ¹ Git: {self.sync_stats['git_pushes']}
â””â”€â”€ Ø¢Ø®Ø± Ù…Ø²Ø§Ù…Ù†Ø©: {self.last_sync.strftime('%Y-%m-%d %H:%M:%S') if self.last_sync else 'Ù„Ù… ØªØ­Ø¯Ø« Ø¨Ø¹Ø¯'}
"""
        self.logger.info(stats_text)

    def start_scheduler(self):
        """Ø¨Ø¯Ø¡ Ø¬Ø¯ÙˆÙ„Ø© Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ø°ÙƒÙŠØ©"""
        # Ù…Ø²Ø§Ù…Ù†Ø© ÙƒÙ„ 45 Ø«Ø§Ù†ÙŠØ©
        schedule.every(45).seconds.do(self.full_sync_cycle)

        # Ù…Ø²Ø§Ù…Ù†Ø© Ø¹Ù†Ø¯ ÙˆØ¬ÙˆØ¯ ØªØºÙŠÙŠØ±Ø§Øª Ù…Ø¹Ù„Ù‚Ø©
        def sync_if_pending():
            if self.pending_changes and not self.is_syncing:
                self.full_sync_cycle()

        schedule.every(15).seconds.do(sync_if_pending)

        # Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ÙƒÙ„ 5 Ø¯Ù‚Ø§Ø¦Ù‚
        schedule.every(5).minutes.do(self.print_stats)

        self.logger.info("â° ØªÙ… Ø¨Ø¯Ø¡ Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø© Ø§Ù„Ø°ÙƒÙŠØ©")

    def run(self):
        """ØªØ´ØºÙŠÙ„ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„ÙƒØ§Ù…Ù„"""
        self.logger.info("ğŸš€ Ø¨Ø¯Ø¡ Ù†Ø¸Ø§Ù… Ø§Ù„Ø£ØªÙ…ØªØ© Ø§Ù„Ø´Ø§Ù…Ù„Ø©")

        # ÙØ­Øµ Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª
        if not self.check_dependencies():
            self.logger.error("âŒ Ø¨Ø¹Ø¶ Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª ØºÙŠØ± Ù…ØªÙˆÙØ±Ø©")
            return

        # Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù…
        current_branch, remote_url = self.get_git_info()
        self.logger.info(f"ğŸ“‚ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹: {os.path.basename(self.project_path)}")
        self.logger.info(f"ğŸŒ¿ Ø§Ù„ÙØ±Ø¹: {current_branch}")
        self.logger.info(f"ğŸ”— Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹: {remote_url}")

        # Ø¨Ø¯Ø¡ Ù…Ø±Ø§Ù‚Ø¨ Ø§Ù„Ù…Ù„ÙØ§Øª
        observer = self.start_file_watcher()

        # Ø¨Ø¯Ø¡ Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø©
        self.start_scheduler()

        # ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰
        self.full_sync_cycle()

        self.logger.info("ğŸ¯ Ø§Ù„Ù†Ø¸Ø§Ù… Ø¬Ø§Ù‡Ø²! Ø§Ø¶ØºØ· Ctrl+C Ù„Ù„Ø¥ÙŠÙ‚Ø§Ù")

        try:
            while True:
                schedule.run_pending()
                time.sleep(1)
        except KeyboardInterrupt:
            self.logger.info("â¹ï¸  ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù†Ø¸Ø§Ù… Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…")
            self.print_stats()
        finally:
            observer.stop()
            observer.join()
            self.logger.info("ğŸ‘‹ ÙˆØ¯Ø§Ø¹Ø§Ù‹!")


# Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
if __name__ == "__main__":
    # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Ø¸Ø§Ù… ÙˆØªØ´ØºÙŠÙ„Ù‡
    auto_sync = UltimateAutoSync()
    auto_sync.run()


Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ ÙˆØ§Ù„ØªØ­Ø°ÙŠØ±Ø§Øª:
================================================================================

==================================================
ğŸ”§ Ø£Ø®Ø·Ø§Ø¡ FLAKE8
==================================================
.\analyze.py:37:80: E501 line too long (86 > 79 characters)
.\analyze.py:70:17: F841 local variable 'command_target' is assigned to but never used
.\analyze.py:74:80: E501 line too long (85 > 79 characters)
.\analyze.py:85:80: E501 line too long (84 > 79 characters)
.\analyze.py:152:11: F541 f-string is missing placeholders
.\app.py:4166:1: E999 SyntaxError: expected 'except' or 'finally' block
.\init_db.py:4:1: E302 expected 2 blank lines, found 1
.\init_db.py:10:1: W293 blank line contains whitespace
.\init_db.py:18:1: W293 blank line contains whitespace
.\init_db.py:21:1: W293 blank line contains whitespace
.\init_db.py:25:1: E305 expected 2 blank lines after class or function definition, found 1
.\quick_fix.py:6:1: W293 blank line contains whitespace
.\quick_fix.py:16:1: W293 blank line contains whitespace
.\quick_fix.py:19:1: W293 blank line contains whitespace
.\quick_fix.py:22:1: E305 expected 2 blank lines after class or function definition, found 1
.\quick_start.py:1:1: F401 'os' imported but unused
.\quick_start.py:35:5: E722 do not use bare 'except'
.\service_runner.py:61:9: E722 do not use bare 'except'
.\telegram_bot.py:2:1: F401 'json' imported but unused
.\telegram_bot.py:3:1: F401 'logging' imported but unused
.\telegram_bot.py:7:1: F401 'flask.current_app' imported but unused
.\telegram_bot.py:9:1: E302 expected 2 blank lines, found 1
.\telegram_bot.py:11:1: W293 blank line contains whitespace
.\telegram_bot.py:18:1: W293 blank line contains whitespace
.\telegram_bot.py:21:1: W293 blank line contains whitespace
.\telegram_bot.py:28:1: W293 blank line contains whitespace
.\telegram_bot.py:34:1: W293 blank line contains whitespace
.\telegram_bot.py:38:1: W293 blank line contains whitespace
.\telegram_bot.py:39:80: E501 line too long (89 > 79 characters)
.\telegram_bot.py:42:80: E501 line too long (84 > 79 characters)
.\telegram_bot.py:44:1: W293 blank line contains whitespace
.\telegram_bot.py:52:1: W293 blank line contains whitespace
.\telegram_bot.py:55:1: W293 blank line contains whitespace
.\telegram_bot.py:62:1: W293 blank line contains whitespace
.\telegram_bot.py:66:1: W293 blank line contains whitespace
.\telegram_bot.py:67:80: E501 line too long (97 > 79 characters)
.\telegram_bot.py:71:1: W293 blank line contains whitespace
.\telegram_bot.py:75:1: W293 blank line contains whitespace
.\telegram_bot.py:76:71: W291 trailing whitespace
.\telegram_bot.py:77:27: E128 continuation line under-indented for visual indent
.\telegram_bot.py:81:1: W293 blank line contains whitespace
.\telegram_bot.py:88:1: W293 blank line contains whitespace
.\telegram_bot.py:91:1: W293 blank line contains whitespace
.\telegram_bot.py:102:1: W293 blank line contains whitespace
.\telegram_bot.py:104:1: W293 blank line contains whitespace
.\telegram_bot.py:112:1: W293 blank line contains whitespace
.\telegram_bot.py:113:80: E501 line too long (106 > 79 characters)
.\telegram_bot.py:116:1: W293 blank line contains whitespace
.\telegram_bot.py:117:80: E501 line too long (99 > 79 characters)
.\telegram_bot.py:120:1: W293 blank line contains whitespace
.\telegram_bot.py:136:40: W291 trailing whitespace
.\telegram_bot.py:139:1: W293 blank line contains whitespace
.\telegram_bot.py:141:1: W293 blank line contains whitespace
.\telegram_bot.py:145:80: E501 line too long (82 > 79 characters)
.\telegram_bot.py:147:1: W293 blank line contains whitespace
.\telegram_bot.py:154:1: W293 blank line contains whitespace
.\telegram_bot.py:157:1: W293 blank line contains whitespace
.\telegram_bot.py:164:1: W293 blank line contains whitespace
.\telegram_bot.py:168:1: W293 blank line contains whitespace
.\telegram_bot.py:169:80: E501 line too long (95 > 79 characters)
.\telegram_bot.py:175:80: E501 line too long (81 > 79 characters)
.\telegram_bot.py:176:1: W293 blank line contains whitespace
.\telegram_bot.py:178:1: W293 blank line contains whitespace
.\telegram_bot.py:182:1: W293 blank line contains whitespace
.\telegram_bot.py:183:80: E501 line too long (83 > 79 characters)
.\telegram_bot.py:189:1: W293 blank line contains whitespace
.\telegram_bot.py:199:1: W293 blank line contains whitespace
.\telegram_bot.py:200:80: E501 line too long (107 > 79 characters)
.\telegram_bot.py:209:13: E722 do not use bare 'except'
.\telegram_bot.py:211:1: W293 blank line contains whitespace
.\telegram_bot.py:218:18: W291 trailing whitespace
.\telegram_bot.py:230:1: W293 blank line contains whitespace
.\telegram_bot.py:232:1: W293 blank line contains whitespace
.\telegram_bot.py:240:1: W293 blank line contains whitespace
.\telegram_bot.py:248:25: W291 trailing whitespace
.\telegram_bot.py:258:21: W291 trailing whitespace
.\telegram_bot.py:264:1: W293 blank line contains whitespace
.\telegram_bot.py:266:1: W293 blank line contains whitespace
.\telegram_bot.py:271:1: W293 blank line contains whitespace
.\telegram_bot.py:272:80: E501 line too long (82 > 79 characters)
.\telegram_bot.py:283:24: W291 trailing whitespace
.\telegram_bot.py:288:1: W293 blank line contains whitespace
.\telegram_bot.py:290:1: W293 blank line contains whitespace
.\telegram_bot.py:296:1: W293 blank line contains whitespace
.\telegram_bot.py:297:80: E501 line too long (80 > 79 characters)
.\telegram_bot.py:312:1: W293 blank line contains whitespace
.\telegram_bot.py:314:1: W293 blank line contains whitespace
.\telegram_bot.py:322:1: E305 expected 2 blank lines after class or function definition, found 1
.\test_profile.py:4:1: E302 expected 2 blank lines, found 1
.\test_profile.py:8:1: W293 blank line contains whitespace
.\test_profile.py:19:1: W293 blank line contains whitespace
.\test_profile.py:24:1: W293 blank line contains whitespace
.\test_profile.py:27:1: W293 blank line contains whitespace
.\test_profile.py:29:1: W293 blank line contains whitespace
.\test_profile.py:30:80: E501 line too long (94 > 79 characters)
.\test_profile.py:33:1: E305 expected 2 blank lines after class or function definition, found 1
.\ultimate_auto_sync.py:7:1: F401 'json' imported but unused
.\ultimate_auto_sync.py:11:1: F401 'threading' imported but unused
.\ultimate_auto_sync.py:14:1: F401 'pathlib.Path' imported but unused
.\ultimate_auto_sync.py:16:1: F401 'psutil' imported but unused
.\ultimate_auto_sync.py:57:80: E501 line too long (84 > 79 characters)
.\ultimate_auto_sync.py:117:80: E501 line too long (83 > 79 characters)
.\ultimate_auto_sync.py:139:80: E501 line too long (91 > 79 characters)
.\ultimate_auto_sync.py:160:9: E722 do not use bare 'except'
.\ultimate_auto_sync.py:173:80: E501 line too long (88 > 79 characters)
.\ultimate_auto_sync.py:182:80: E501 line too long (88 > 79 characters)
.\ultimate_auto_sync.py:185:9: E722 do not use bare 'except'
.\ultimate_auto_sync.py:199:80: E501 line too long (82 > 79 characters)
.\ultimate_auto_sync.py:207:80: E501 line too long (85 > 79 characters)
.\ultimate_auto_sync.py:219:13: E722 do not use bare 'except'
.\ultimate_auto_sync.py:231:80: E501 line too long (117 > 79 characters)
.\ultimate_auto_sync.py:238:80: E501 line too long (85 > 79 characters)
.\ultimate_auto_sync.py:311:80: E501 line too long (83 > 79 characters)
.\ultimate_auto_sync.py:347:80: E501 line too long (99 > 79 characters)


==================================================
ğŸ”§ Ø£Ø®Ø·Ø§Ø¡ PYLINT
==================================================

STDERR:
C:\Users\pc\python.exe: No module named pylint


==================================================
ğŸ”§ Ø£Ø®Ø·Ø§Ø¡ BLACK
==================================================

STDERR:
would reformat C:\Users\pc\Downloads\senioraaa-main\test_profile.py
would reformat C:\Users\pc\Downloads\senioraaa-main\init_db.py
would reformat C:\Users\pc\Downloads\senioraaa-main\quick_fix.py
error: cannot format C:\Users\pc\Downloads\senioraaa-main\app.py: Cannot parse for target version Python 3.11: 4166:0: repair_columns = [
would reformat C:\Users\pc\Downloads\senioraaa-main\telegram_bot.py

Oh no! \U0001f4a5 \U0001f494 \U0001f4a5
4 files would be reformatted, 4 files would be left unchanged, 1 file would fail to reformat.


==================================================
ğŸ”§ Ø£Ø®Ø·Ø§Ø¡ ISORT
==================================================
Skipped 2 files

STDERR:
ERROR: C:\Users\pc\Downloads\senioraaa-main\init_db.py Imports are incorrectly sorted and/or formatted.
ERROR: C:\Users\pc\Downloads\senioraaa-main\telegram_bot.py Imports are incorrectly sorted and/or formatted.
ERROR: C:\Users\pc\Downloads\senioraaa-main\test_profile.py Imports are incorrectly sorted and/or formatted.

