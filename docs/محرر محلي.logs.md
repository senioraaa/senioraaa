(venv) PS C:\Users\pc\Downloads\senioraaa-main> python fix_flake











                                                python fix_flake8.py
ğŸ”§ ØªØ´ØºÙŠÙ„ Ø£Ø¯ÙˆØ§Øª Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ ÙˆØ§Ù„ÙØ­Øµ...
Running Black...
âŒ Black failed: reformatted C:\Users\pc\Downloads\senioraaa-main\analyze.py
error: cannot format C:\Users\pc\Downloads\senioraaa-main\telegram_bot.py: Cannot parse for target version Python 3.11: 120:56:             "\u26a1 \u0641\u0648\u0631\u064a" if order_data.get("transfer_type") = (        
error: cannot format C:\Users\pc\Downloads\senioraaa-main\ultimate_auto_sync.py: Cannot parse for target version Python 3.11: 55:31:                     True, check=True)
reformatted C:\Users\pc\Downloads\senioraaa-main\app.py

Oh no! \U0001f4a5 \U0001f494 \U0001f4a5
2 files reformatted, 7 files left unchanged, 2 files failed to reformat.

Running isort...
âœ… isort finished.
Running flake8...
âš ï¸ Flake8 found issues:
.\analyze.py:37:80: E501 line too long (81 > 79 characters)
.\analyze.py:41:80: E501 line too long (86 > 79 characters)
.\app.py:10:1: F401 'error_handlers.init_error_handlers' imported but unused
.\app.py:15:1: F401 'flask.g' imported but unused
.\app.py:33:1: F401 'models.AppSetting' imported but unused
.\app.py:124:80: E501 line too long (84 > 79 characters)
.\app.py:172:80: E501 line too long (82 > 79 characters)
.\app.py:222:80: E501 line too long (87 > 79 characters)
.\app.py:223:80: E501 line too long (87 > 79 characters)
.\app.py:259:80: E501 line too long (85 > 79 characters)
.\app.py:283:80: E501 line too long (88 > 79 characters)
.\app.py:303:80: E501 line too long (84 > 79 characters)
.\app.py:350:80: E501 line too long (84 > 79 characters)
.\app.py:365:80: E501 line too long (108 > 79 characters)
.\app.py:405:80: E501 line too long (81 > 79 characters)
.\app.py:426:80: E501 line too long (84 > 79 characters)
.\app.py:498:80: E501 line too long (108 > 79 characters)
.\app.py:504:80: E501 line too long (87 > 79 characters)
.\app.py:508:80: E501 line too long (82 > 79 characters)
.\app.py:525:80: E501 line too long (87 > 79 characters)
.\app.py:562:80: E501 line too long (85 > 79 characters)
.\app.py:582:80: E501 line too long (80 > 79 characters)
.\app.py:596:80: E501 line too long (84 > 79 characters)
.\app.py:643:80: E501 line too long (82 > 79 characters)
.\app.py:665:80: E501 line too long (80 > 79 characters)
.\quick_start.py:34:5: F841 local variable 'e' is assigned to but never used
.\service_runner.py:61:9: F841 local variable 'e' is assigned to but never used
.\telegram_bot.py:120:14: E999 SyntaxError: expected 'else' after 'if' expression
.\test_profile.py:34:80: E501 line too long (91 > 79 characters)
.\ultimate_auto_sync.py:55:28: E999 SyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='? 
.\ultimate_flake8_fixer.py:11:1: F401 'pathlib.Path' imported but unused
.\ultimate_flake8_fixer.py:25:80: E501 line too long (85 > 79 characters)
.\ultimate_flake8_fixer.py:28:9: E722 do not use bare 'except'
.\ultimate_flake8_fixer.py:33:80: E501 line too long (85 > 79 characters)
.\ultimate_flake8_fixer.py:36:9: E722 do not use bare 'except'
.\ultimate_flake8_fixer.py:81:80: E501 line too long (226 > 79 characters)
.\ultimate_flake8_fixer.py:82:80: E501 line too long (223 > 79 characters)
.\ultimate_flake8_fixer.py:83:80: E501 line too long (201 > 79 characters)
.\ultimate_flake8_fixer.py:102:80: E501 line too long (184 > 79 characters)
.\ultimate_flake8_fixer.py:105:80: E501 line too long (80 > 79 characters)
.\ultimate_flake8_fixer.py:109:80: E501 line too long (141 > 79 characters)
.\ultimate_flake8_fixer.py:162:80: E501 line too long (85 > 79 characters)
.\ultimate_flake8_fixer.py:178:80: E501 line too long (87 > 79 characters)
.\ultimate_flake8_fixer.py:180:80: E501 line too long (82 > 79 characters)
.\ultimate_flake8_fixer.py:206:80: E501 line too long (82 > 79 characters)
.\ultimate_flake8_fixer.py:212:80: E501 line too long (83 > 79 characters)
.\ultimate_flake8_fixer.py:217:80: E501 line too long (86 > 79 characters)
.\ultimate_flake8_fixer.py:232:80: E501 line too long (82 > 79 characters)
.\ultimate_flake8_fixer.py:234:80: E501 line too long (81 > 79 characters)

(venv) PS C:\Users\pc\Downloads\senioraaa-main> 

(venv) PS C:\Users\pc\Downloads\senioraaa-main> python ultimate_flake8_fixer











                                                python ultimate_flake8_fixer.py 
ğŸš€ Ø¨Ø¯Ø¡ Ø§Ù„Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ø´Ø§Ù…Ù„ Ù„Ø¬Ù…ÙŠØ¹ Ø£Ø®Ø·Ø§Ø¡ flake8...
============================================================
ğŸ”§ ØªØ´ØºÙŠÙ„ Black Ùˆ isort...
âŒ Black ÙØ´Ù„ - Ø§Ø³ØªÙƒÙ…Ø§Ù„ Ø¨Ø¯ÙˆÙ†Ù‡
âœ… isort ØªÙ… Ø¨Ù†Ø¬Ø§Ø­
ğŸ”§ Ø¥ØµÙ„Ø§Ø­ app.py...
âœ… ØªÙ… Ø¥ØµÙ„Ø§Ø­ app.py
ğŸ”§ Ø¥ØµÙ„Ø§Ø­ telegram_bot.py...
âœ… ØªÙ… Ø¥ØµÙ„Ø§Ø­ telegram_bot.py
ğŸ”§ Ø¥ØµÙ„Ø§Ø­ analyze.py...
âœ… ØªÙ… Ø¥ØµÙ„Ø§Ø­ analyze.py
ğŸ”§ Ø¥ØµÙ„Ø§Ø­ ultimate_auto_sync.py...
ğŸ”§ Ø¥ØµÙ„Ø§Ø­ quick_start.py...
ğŸ”§ Ø¥ØµÙ„Ø§Ø­ service_runner.py...
ğŸ”§ Ø¥ØµÙ„Ø§Ø­ fix_flake8.py...
ğŸ”§ Ø¥ØµÙ„Ø§Ø­ test_profile.py...

ğŸ” ÙØ­Øµ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ù…Ø¹ flake8...
âš ï¸ Ù„Ø§ ØªØ²Ø§Ù„ Ù‡Ù†Ø§Ùƒ Ù…Ø´Ø§ÙƒÙ„:
.\analyze.py:44:80: E501 line too long (80 > 79 characters)
.\app.py:10:1: F401 'error_handlers.init_error_handlers' imported but unused
.\app.py:15:1: F401 'flask.g' imported but unused
.\app.py:33:1: F401 'models.AppSetting' imported but unused
.\app.py:124:80: E501 line too long (84 > 79 characters)
.\app.py:172:80: E501 line too long (82 > 79 characters)
.\app.py:222:80: E501 line too long (87 > 79 characters)
.\app.py:223:80: E501 line too long (87 > 79 characters)
.\app.py:286:80: E501 line too long (88 > 79 characters)
.\app.py:356:80: E501 line too long (84 > 79 characters)
.\app.py:371:80: E501 line too long (108 > 79 characters)
.\app.py:510:80: E501 line too long (108 > 79 characters)
.\app.py:516:80: E501 line too long (87 > 79 characters)
.\app.py:520:80: E501 line too long (82 > 79 characters)
.\app.py:537:80: E501 line too long (87 > 79 characters)
.\app.py:597:80: E501 line too long (80 > 79 characters)
.\app.py:611:80: E501 line too long (84 > 79 characters)
.\app.py:658:80: E501 line too long (82 > 79 characters)
.\app.py:680:80: E501 line too long (80 > 79 characters)
.\quick_start.py:34:5: F841 local variable 'e' is assigned to but never used
.\service_runner.py:61:9: F841 local variable 'e' is assigned to but never used
.\telegram_bot.py:120:14: E999 SyntaxError: expected 'else' after 'if' expression
.\test_profile.py:34:80: E501 line too long (91 > 79 characters)
.\ultimate_auto_sync.py:55:28: E999 SyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='? 
.\ultimate_flake8_fixer.py:11:1: F401 'pathlib.Path' imported but unused
.\ultimate_flake8_fixer.py:25:80: E501 line too long (85 > 79 characters)
.\ultimate_flake8_fixer.py:28:9: E722 do not use bare 'except'
.\ultimate_flake8_fixer.py:33:80: E501 line too long (85 > 79 characters)
.\ultimate_flake8_fixer.py:36:9: E722 do not use bare 'except'
.\ultimate_flake8_fixer.py:81:80: E501 line too long (226 > 79 characters)
.\ultimate_flake8_fixer.py:82:80: E501 line too long (223 > 79 characters)
.\ultimate_flake8_fixer.py:83:80: E501 line too long (201 > 79 characters)
.\ultimate_flake8_fixer.py:102:80: E501 line too long (184 > 79 characters)
.\ultimate_flake8_fixer.py:105:80: E501 line too long (80 > 79 characters)
.\ultimate_flake8_fixer.py:109:80: E501 line too long (141 > 79 characters)
.\ultimate_flake8_fixer.py:162:80: E501 line too long (85 > 79 characters)
.\ultimate_flake8_fixer.py:178:80: E501 line too long (87 > 79 characters)
.\ultimate_flake8_fixer.py:180:80: E501 line too long (82 > 79 characters)
.\ultimate_flake8_fixer.py:206:80: E501 line too long (82 > 79 characters)
.\ultimate_flake8_fixer.py:212:80: E501 line too long (83 > 79 characters)
.\ultimate_flake8_fixer.py:217:80: E501 line too long (86 > 79 characters)
.\ultimate_flake8_fixer.py:232:80: E501 line too long (82 > 79 characters)
.\ultimate_flake8_fixer.py:234:80: E501 line too long (81 > 79 characters)


============================================================
ğŸ“Š ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ø¥ØµÙ„Ø§Ø­:
âœ… ØªÙ… Ø¥ØµÙ„Ø§Ø­ 3 Ù…Ù„Ù
ğŸ“ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…ÙØµÙ„Ø­Ø©:
   - app.py
   - telegram_bot.py
   - analyze.py

âš ï¸ Ù‚Ø¯ ØªØ­ØªØ§Ø¬ Ù„Ø¥ØµÙ„Ø§Ø­Ø§Øª ÙŠØ¯ÙˆÙŠØ© Ø¥Ø¶Ø§ÙÙŠØ©
(venv) PS C:\Users\pc\Downloads\senioraaa-main> 




import os
from datetime import datetime
from typing import Any, Dict, Optional

import requests


class TelegramNotificationSystem:
    """Ù†Ø¸Ø§Ù… Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…"""

    def __init__(self, app=None):
        self.app = app
        self.bot_token = None
        self.bot_username = None
        self.webhook_url = None
        self.base_url = None

        if app:
            self.init_app(app)

    def init_app(self, app):
        """ØªÙ‡ÙŠØ¦Ø© Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù… Ù…Ø¹ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚"""
        self.app = app
        self.bot_token = os.environ.get("TELEGRAM_BOT_TOKEN")
        self.bot_username = os.environ.get("BOT_USERNAME", "YourBot_bot")
        self.webhook_url = os.environ.get("TELEGRAM_WEBHOOK_URL")

        if self.bot_token:
            self.base_url = f"https://api.telegram.org/bot{self.bot_token}"
            app.logger.info("Telegram bot initialized successfully")
        else:
            app.logger.warning("Telegram bot token not configured")

    def is_configured(self) -> bool:
        """ÙØ­Øµ Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø¨ÙˆØª Ù…ÙØ¹Ø¯ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­"""
        return bool(self.bot_token and self.base_url)

    def send_message(
        self, chat_id: str, message: str, parse_mode: str = "HTML"
    ) -> bool:
        """Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø­Ø¯Ø¯"""
        if not self.is_configured():
            self.app.logger.warning("Telegram bot not configured, skipping message")
            return False

        try:
            url = f"{self.base_url}/sendMessage"
            payload = (
                {"chat_id": chat_id, "text": message, "parse_mode": parse_mode}
            )

            response = requests.post(url, json=payload, timeout=10)
            result = response.json()

            if result.get("ok"):
                self.app.logger.info(f"Message sent successfully to {chat_id}")
                return True
            else:
                self.app.logger.error(f"Failed to send message: {result}")
                return False

        except Exception as e:
            self.app.logger.error(f"Error sending Telegram message: {e}")
            return False

    def send_order_notification(
        self, user_telegram_id: str, order_data: Dict[str, Any]
    ) -> bool:
        """Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ø¹Ù† Ø·Ù„Ø¨ Ø¬Ø¯ÙŠØ¯"""
        if not user_telegram_id:
            return False

        # ØªÙ†Ø³ÙŠÙ‚ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø·Ù„Ø¨
        message = self.format_order_message(order_data)
        return self.send_message(user_telegram_id, message)

    def send_status_update(
        self, user_telegram_id: str, order_id: int, old_status: str, new_status: str
    ) -> bool:
        """Ø¥Ø±Ø³Ø§Ù„ ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø·Ù„Ø¨"""
        if not user_telegram_id:
            return False

        status_messages = {
            "pending": "â³ Ù‚ÙŠØ¯ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±",
            "processing": "âš™ï¸ Ù‚ÙŠØ¯ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©",
            "completed": "âœ… Ù…ÙƒØªÙ…Ù„",
            "cancelled": "âŒ Ù…Ù„ØºÙŠ",
        }

        old_status_text = status_messages.get(old_status, old_status)
        new_status_text = status_messages.get(new_status, new_status)

        message = f"""
ğŸ”” <b>ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø·Ù„Ø¨ #{order_id}</b>

ğŸ“Š Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©: {old_status_text}
ğŸ†• Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©: {new_status_text}

ğŸ•’ ÙˆÙ‚Øª Ø§Ù„ØªØ­Ø¯ÙŠØ«: {datetime.now().strftime('%Y-%m-%d %H:%M')}

Ø´ÙƒØ±Ø§Ù‹ Ù„Ø§Ø®ØªÙŠØ§Ø±Ùƒ Ø´Ù‡Ø¯ Ø§Ù„Ø³Ù†ÙŠÙˆØ±Ø©! ğŸ®
        """

        return self.send_message(user_telegram_id, message.strip())

    def format_order_message(self, order_data: Dict[str, Any]) -> str:
        """ØªÙ†Ø³ÙŠÙ‚ Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø·Ù„Ø¨ Ø§Ù„Ø¬Ø¯ÙŠØ¯"""
        platform_icons = (
            {"PS": "ğŸ® PlayStation", "Xbox": "ğŸ¯ Xbox", "PC": "ğŸ’» PC"}
        )

        platform_text = platform_icons.get(
            order_data.get("platform", ""), order_data.get("platform", "")
        )
        coins_amount = order_data.get("coins_amount", 0)
        formatted_coins = f"{coins_amount:,}" if coins_amount else "ØºÙŠØ± Ù…Ø­Ø¯Ø¯"

        transfer_type_text = (
            "âš¡ ÙÙˆØ±ÙŠ" if order_data.get("transfer_type") = (
                = "instant" else "ğŸ•’ Ø¹Ø§Ø¯ÙŠ"
            )
        )
        price = order_data.get("price", 0)
        formatted_price = f"{price:,.2f}" if price else "ÙŠØªÙ… Ø­Ø³Ø§Ø¨Ù‡"

        message = f"""
ğŸ‰ <b>Ø·Ù„Ø¨ Ø¬Ø¯ÙŠØ¯ ØªÙ… Ø¥Ø±Ø³Ø§Ù„Ù‡ Ø¨Ù†Ø¬Ø§Ø­!</b>

ğŸ“‹ <b>ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø·Ù„Ø¨:</b>
ğŸ†” Ø±Ù‚Ù… Ø§Ù„Ø·Ù„Ø¨: #{order_data.get('id', 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙˆÙ„ÙŠØ¯')}
ğŸ® Ø§Ù„Ù…Ù†ØµØ©: {platform_text}
ğŸ’° Ø§Ù„ÙƒÙ…ÙŠØ©: {formatted_coins} ÙƒÙˆÙŠÙ†
âš¡ Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„: {transfer_type_text}
ğŸ’µ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ù…ØªÙˆÙ‚Ø¹: {formatted_price} Ø¬Ù†ÙŠÙ‡

ğŸ“± Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹: {order_data.get('payment_method', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}
ğŸ“ Ø±Ù‚Ù… Ø§Ù„ÙˆØ§ØªØ³Ø§Ø¨: {order_data.get('phone_number', 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')}

ğŸ•’ ÙˆÙ‚Øª Ø§Ù„Ø·Ù„Ø¨: {datetime.now().strftime('%Y-%m-%d %H:%M')}

Ø³ÙŠØªÙ… Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ùƒ Ù‚Ø±ÙŠØ¨Ø§Ù‹ Ù„Ø¥ØªÙ…Ø§Ù… Ø§Ù„Ø¹Ù…Ù„ÙŠØ©!
Ø´ÙƒØ±Ø§Ù‹ Ù„Ø§Ø®ØªÙŠØ§Ø±Ùƒ Ø´Ù‡Ø¯ Ø§Ù„Ø³Ù†ÙŠÙˆØ±Ø©! ğŸš€
        """

        return message.strip()

    def setup_webhook(self) -> bool:
        """Ø¥Ø¹Ø¯Ø§Ø¯ webhook Ù„Ù„Ø¨ÙˆØª"""
        if not self.is_configured() or not self.webhook_url:
            self.app.logger.warning("Cannot setup webhook: missing configuration")
            return False

        try:
            url = f"{self.base_url}/setWebhook"
            payload = {
                "url": self.webhook_url,
                "allowed_updates": ["message", "callback_query"],
            }

            response = requests.post(url, json=payload, timeout=10)
            result = response.json()

            if result.get("ok"):
                self.app.logger.info("Webhook setup successfully")
                return True
            else:
                self.app.logger.error(f"Failed to setup webhook: {result}")
                return False

        except Exception as e:
            self.app.logger.error(f"Error setting up webhook: {e}")
            return False

    def process_telegram_update(
        self, update_data: Dict[str, Any]
    ) -> Optional[Dict[str, Any]]:
        """Ù…Ø¹Ø§Ù„Ø¬Ø© ØªØ­Ø¯ÙŠØ«Ø§Øª Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù… Ø§Ù„ÙˆØ§Ø±Ø¯Ø©"""
        try:
            if "message" in update_data:
                return self.process_message(update_data["message"])
            elif "callback_query" in update_data:
                return self.process_callback_query(update_data["callback_query"])

            return None

        except Exception as e:
            self.app.logger.error(f"Error processing Telegram update: {e}")
            return None

    def process_message(self, message: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ÙˆØ§Ø±Ø¯Ø©"""
        chat_id = str(message["chat"]["id"])
        user_id = str(message["from"]["id"])
        username = message["from"].get("username", "")
        text = message.get("text", "").strip()

        # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¨ÙˆØª
        if text.startswith("/start"):
            return self.handle_start_command(chat_id, user_id, username, text)
        elif text == "/help":
            return self.handle_help_command(chat_id)
        elif text == "/status":
            return self.handle_status_command(chat_id, user_id)
        else:
            return self.handle_regular_message(chat_id, text)

    def handle_start_command(
        self, chat_id: str, user_id: str, username: str, text: str
    ) -> Dict[str, Any]:
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ù…Ø± /start"""
        # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù† Ø§Ù„Ø±Ø§Ø¨Ø· Ø¥Ø°Ø§ ÙˆÙØ¬Ø¯
        website_user_id = None
        if " " in text:
            try:
                import base64

                encoded_id = text.split(" ")[1]
                website_user_id = base64.b64decode(encoded_id).decode("utf-8")
            except Exception as e:
                pass

        welcome_message = f"""
ğŸ® <b>Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø¨ÙˆØª Ø´Ù‡Ø¯ Ø§Ù„Ø³Ù†ÙŠÙˆØ±Ø©!</b>

Ø£Ù‡Ù„Ø§Ù‹ {username or 'ØµØ¯ÙŠÙ‚ÙŠ'}! ğŸ‘‹

ğŸ”” Ø³ÙŠÙ‚ÙˆÙ… Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª Ø¨Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø±Ø§Øª ÙÙˆØ±ÙŠØ© Ø¹Ù†:
â€¢ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
â€¢ ØªØ­Ø¯ÙŠØ«Ø§Øª Ø­Ø§Ù„Ø© Ø§Ù„Ø·Ù„Ø¨Ø§Øª
â€¢ Ø§Ù„Ø¹Ø±ÙˆØ¶ Ø§Ù„Ø®Ø§ØµØ© ÙˆØ§Ù„ØªØ®ÙÙŠØ¶Ø§Øª

ğŸ“± <b>Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…ØªØ§Ø­Ø©:</b>
/help - Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©
/status - Ø­Ø§Ù„Ø© Ø§Ù„Ø±Ø¨Ø· Ù…Ø¹ Ø­Ø³Ø§Ø¨Ùƒ

ğŸ”— Ù„Ø±Ø¨Ø· Ø­Ø³Ø§Ø¨ÙƒØŒ Ø§Ø³ØªØ®Ø¯Ù… Ø²Ø± "Ø±Ø¨Ø· Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…" ÙÙŠ Ù…ÙˆÙ‚Ø¹Ù†Ø§.

Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø¹Ø§Ø¦Ù„Ø© Ø´Ù‡Ø¯ Ø§Ù„Ø³Ù†ÙŠÙˆØ±Ø©! ğŸš€
        """

        self.send_message(chat_id, welcome_message.strip())

        return {
            "action": "start",
            "chat_id": chat_id,
            "user_id": user_id,
            "username": username,
            "website_user_id": website_user_id,
        }

    def handle_help_command(self, chat_id: str) -> Dict[str, Any]:
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ù…Ø± /help"""
        help_message = """
ğŸ¤– <b>Ù…Ø³Ø§Ø¹Ø¯Ø© Ø¨ÙˆØª Ø´Ù‡Ø¯ Ø§Ù„Ø³Ù†ÙŠÙˆØ±Ø©</b>

ğŸ“‹ <b>Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…ØªØ§Ø­Ø©:</b>
/start - Ø¨Ø¯Ø¡ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª
/help - Ø¹Ø±Ø¶ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©
/status - ÙØ­Øµ Ø­Ø§Ù„Ø© Ø§Ù„Ø±Ø¨Ø·

ğŸ”” <b>Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ©:</b>
â€¢ Ø¥Ø´Ø¹Ø§Ø± ÙÙˆØ±ÙŠ Ø¹Ù†Ø¯ Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨ Ø¬Ø¯ÙŠØ¯
â€¢ ØªØ­Ø¯ÙŠØ«Ø§Øª Ø­Ø§Ù„Ø© Ø§Ù„Ø·Ù„Ø¨ (Ù‚ÙŠØ¯ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©ØŒ Ù…ÙƒØªÙ…Ù„ØŒ Ø¥Ù„Ø®)
â€¢ ØªÙ†Ø¨ÙŠÙ‡Ø§Øª Ø§Ù„Ø¹Ø±ÙˆØ¶ Ø§Ù„Ø®Ø§ØµØ©

ğŸ”— <b>ÙƒÙŠÙÙŠØ© Ø§Ù„Ø±Ø¨Ø·:</b>
1. Ø³Ø¬Ù„ Ø¯Ø®ÙˆÙ„Ùƒ ÙÙŠ Ù…ÙˆÙ‚Ø¹ Ø´Ù‡Ø¯ Ø§Ù„Ø³Ù†ÙŠÙˆØ±Ø©
2. Ø§Ø°Ù‡Ø¨ Ù„Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ
3. Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ "Ø±Ø¨Ø· Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…"
4. Ø£Ø±Ø³Ù„ Ø£ÙŠ Ø±Ø³Ø§Ù„Ø© Ù„Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª

ğŸ’¬ Ù„Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠØŒ ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§ Ø¹Ø¨Ø± Ø§Ù„Ù…ÙˆÙ‚Ø¹.
        """

        self.send_message(chat_id, help_message.strip())

        return {"action": "help", "chat_id": chat_id}

    def handle_status_command(self, chat_id: str, user_id: str) -> Dict[str, Any]:
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ù…Ø± /status"""
        # Ù‡Ù†Ø§ ÙŠÙ…ÙƒÙ† ÙØ­Øµ Ø­Ø§Ù„Ø© Ø§Ù„Ø±Ø¨Ø· Ù…Ø¹ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        status_message = f"""
ğŸ“Š <b>Ø­Ø§Ù„Ø© Ø­Ø³Ø§Ø¨Ùƒ</b>

ğŸ†” Ù…Ø¹Ø±Ù Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…: <code>{user_id}</code>
ğŸ’¬ Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©: <code>{chat_id}</code>

ğŸ”— Ù„Ø±Ø¨Ø· Ø­Ø³Ø§Ø¨Ùƒ Ù…Ø¹ Ø§Ù„Ù…ÙˆÙ‚Ø¹:
1. Ø§Ø°Ù‡Ø¨ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ ÙÙŠ Ø§Ù„Ù…ÙˆÙ‚Ø¹
2. Ø§Ø¶ØºØ· "Ø±Ø¨Ø· Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…"
3. Ø£Ø±Ø³Ù„ Ø£ÙŠ Ø±Ø³Ø§Ù„Ø© Ù‡Ù†Ø§

âœ… Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ Ø·Ø¨ÙŠØ¹ÙŠ
        """

        self.send_message(chat_id, status_message.strip())

        return {"action": "status", "chat_id": chat_id, "user_id": user_id}

    def handle_regular_message(self, chat_id: str, text: str) -> Dict[str, Any]:
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø¹Ø§Ø¯ÙŠØ©"""
        response_message = """
Ø´ÙƒØ±Ø§Ù‹ Ù„Ø±Ø³Ø§Ù„ØªÙƒ! ğŸ“

ğŸ”— Ø¥Ø°Ø§ Ù„Ù… ØªÙ‚Ù… Ø¨Ø±Ø¨Ø· Ø­Ø³Ø§Ø¨Ùƒ Ø¨Ø¹Ø¯:
â€¢ Ø§Ø°Ù‡Ø¨ Ù„Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ ÙÙŠ Ø§Ù„Ù…ÙˆÙ‚Ø¹
â€¢ Ø§Ø¶ØºØ· "Ø±Ø¨Ø· Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…"
â€¢ Ø³ØªØªÙ… Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹

ğŸ’¬ Ù„Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©: /help
ğŸ“Š Ù„ÙØ­Øµ Ø§Ù„Ø­Ø§Ù„Ø©: /status

Ø³Ù†ØªÙˆØ§ØµÙ„ Ù…Ø¹Ùƒ Ù‚Ø±ÙŠØ¨Ø§Ù‹! ğŸš€
        """

        self.send_message(chat_id, response_message.strip())

        return {"action": "message", "chat_id": chat_id, "text": text}


# Ø¥Ù†Ø´Ø§Ø¡ instance Ø¹Ø§Ù…
telegram_system = TelegramNotificationSystem()



#!/usr/bin/env python3
"""
Ù†Ø¸Ø§Ù… Ø§Ù„Ø£ØªÙ…ØªØ© Ø§Ù„Ø´Ø§Ù…Ù„Ø© Ù„Ù„Ø¨Ø±Ù…Ø¬Ø©
ÙŠÙ‚ÙˆÙ… Ø¨ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ÙƒÙˆØ¯ ÙˆØ¥ØµÙ„Ø§Ø­ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ ÙˆÙ…Ø²Ø§Ù…Ù†Ø© GitHub ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
"""

import logging
import os
import subprocess
import time
from datetime import datetime
from pathlib import Path

import schedule
from watchdog.events import FileSystemEventHandler
from watchdog.observers import Observer


class UltimateAutoSync:
    def __init__(self, project_path=None):
        self.project_path = project_path or os.getcwd()
        self.setup_logging()
        self.is_syncing = False
        self.pending_changes = False
        self.last_sync = None
        self.sync_stats = {
            "total_syncs": 0,
            "successful_syncs": 0,
            "failed_syncs": 0,
            "code_formats": 0,
            "git_pushes": 0,
        }

    def setup_logging(self):
        """Ø¥Ø¹Ø¯Ø§Ø¯ Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…"""
        logging.basicConfig(
            level=logging.INFO,
            format="%(asctime)s - %(levelname)s - %(message)s",
            handlers=[
                logging.FileHandler("auto_sync.log", encoding="utf-8"),
                logging.StreamHandler(),
            ],
        )
        self.logger = logging.getLogger(__name__)

    def check_dependencies(self):
        """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©"""
        required_tools = ["git", "python"]
        python_packages = ["black", "isort", "flake8", "autopep8"]

        # ÙØ­Øµ Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
        for tool in required_tools:
            try:
                subprocess.run([tool, "--version"], capture_output = (
                    True, check=True)
                )
                self.logger.info(f"âœ… {tool} Ù…ÙˆØ¬ÙˆØ¯")
            except (subprocess.CalledProcessError, FileNotFoundError):
                self.logger.error(f"âŒ {tool} ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ - ÙŠØ¬Ø¨ ØªØ«Ø¨ÙŠØªÙ‡")
                return False

        # ÙØ­Øµ Ø­Ø²Ù… Python
        for package in python_packages:
            try:
                subprocess.run(
                    ["python", "-m", package, "--version"],
                    capture_output=True,
                    check=True,
                )
                self.logger.info(f"âœ… {package} Ù…ÙˆØ¬ÙˆØ¯")
            except (subprocess.CalledProcessError, FileNotFoundError):
                self.logger.warning(f"âš ï¸  {package} ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ - Ø³ÙŠØªÙ… Ø§Ù„ØªØ®Ø·ÙŠ")

        return True

    def format_code(self):
        """ØªÙ†Ø³ÙŠÙ‚ ÙˆØ¥ØµÙ„Ø§Ø­ Ø§Ù„ÙƒÙˆØ¯ Ø¨Ø´ÙƒÙ„ Ù…ØªÙ‚Ø¯Ù…"""
        if self.is_syncing:
            return False

        try:
            self.logger.info("ğŸ”§ Ø¨Ø¯Ø¡ ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ÙƒÙˆØ¯...")

            # 1. Black formatter
            try:
                result = subprocess.run(
                    ["python", "-m", "black", ".", "--line-length=88"],
                    capture_output=True,
                    text=True,
                    timeout=120,
                )
                if result.returncode == 0:
                    self.logger.info("âœ… ØªÙ… ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ÙƒÙˆØ¯ Ø¨Ù€ Black")
                    self.sync_stats["code_formats"] += 1
                else:
                    self.logger.warning(f"âš ï¸  Black warning: {result.stderr}")
            except (subprocess.TimeoutExpired, FileNotFoundError):
                self.logger.warning("âš ï¸  Black ØºÙŠØ± Ù…ØªØ§Ø­")

            # 2. isort Ù„Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯Ø§Øª
            try:
                result = subprocess.run(
                    ["python", "-m", "isort", ".", "--profile=black"],
                    capture_output=True,
                    text=True,
                    timeout=60,
                )
                if result.returncode == 0:
                    self.logger.info("âœ… ØªÙ… ØªØ±ØªÙŠØ¨ Ø§Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯Ø§Øª")
            except (subprocess.TimeoutExpired, FileNotFoundError):
                self.logger.warning("âš ï¸  isort ØºÙŠØ± Ù…ØªØ§Ø­")

            # 3. autopep8 Ù„Ù„Ø¥ØµÙ„Ø§Ø­Ø§Øª
            try:
                result = subprocess.run(
                    ["python", "-m", "autopep8", "--in-place", "--recursive", "."],
                    capture_output=True,
                    text=True,
                    timeout=120,
                )
                if result.returncode == 0:
                    self.logger.info("âœ… ØªÙ… Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡")
            except (subprocess.TimeoutExpired, FileNotFoundError):
                self.logger.warning("âš ï¸  autopep8 ØºÙŠØ± Ù…ØªØ§Ø­")

            # 4. flake8 Ù„Ù„ÙØ­Øµ
            try:
                result = subprocess.run(
                    ["python", "-m", "flake8", "."],
                    capture_output=True,
                    text=True,
                    timeout=60,
                )
                if result.returncode == 0:
                    self.logger.info("âœ… Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ø®Ø·Ø§Ø¡ ÙÙŠ Ø§Ù„ÙƒÙˆØ¯")
                else:
                    self.logger.info(
                        f"ğŸ“ ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ØªØ­Ø°ÙŠØ±Ø§Øª: {len(result.stdout.splitlines())} Ù…Ø´ÙƒÙ„Ø©"
                    )
            except (subprocess.TimeoutExpired, FileNotFoundError):
                self.logger.warning("âš ï¸  flake8 ØºÙŠØ± Ù…ØªØ§Ø­")

            return True

        except Exception as e:
            self.logger.error(f"âŒ Ø®Ø·Ø£ ÙÙŠ ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ÙƒÙˆØ¯: {e}")
            return False

    def check_git_status(self):
        """ÙØ­Øµ Ø­Ø§Ù„Ø© Git"""
        try:
            result = subprocess.run(
                ["git", "status", "--porcelain"],
                capture_output=True,
                text=True,
                timeout=30,
            )
            return result.stdout.strip()
        except Exception as e:
            return ""

    def get_git_info(self):
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Git"""
        try:
            # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ø³Ù… Ø§Ù„ÙØ±Ø¹
            branch = subprocess.run(
                ["git", "rev-parse", "--abbrev-ref", "HEAD"],
                capture_output=True,
                text=True,
                timeout=10,
            )
            current_branch = (
                branch.stdout.strip() if branch.returncode == 0 else "main"
            )

            # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Remote URL
            remote = subprocess.run(
                ["git", "config", "--get", "remote.origin.url"],
                capture_output=True,
                text=True,
                timeout=10,
            )
            remote_url = (
                remote.stdout.strip() if remote.returncode == 0 else "ØºÙŠØ± Ù…ØªØ§Ø­"
            )

            return current_branch, remote_url
        except Exception as e:
            return "main", "ØºÙŠØ± Ù…ØªØ§Ø­"

    def git_sync(self):
        """Ù…Ø²Ø§Ù…Ù†Ø© ÙƒØ§Ù…Ù„Ø© Ù…Ø¹ Git"""
        if self.is_syncing:
            return False

        try:
            self.logger.info("ğŸ”„ Ø¨Ø¯Ø¡ Ù…Ø²Ø§Ù…Ù†Ø© Git...")
            current_branch, remote_url = self.get_git_info()

            # 1. Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª
            try:
                subprocess.run(["git", "fetch", "origin"], check = (
                    True, timeout=60)
                )
                self.logger.info("ğŸ“¥ ØªÙ… Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª Ù…Ù† GitHub")
            except subprocess.CalledProcessError:
                self.logger.warning("âš ï¸  Ù„Ù… ÙŠØªÙ… Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª")

            # 2. Ø¯Ù…Ø¬ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…ÙˆØ¬ÙˆØ¯Ø©
            try:
                result = subprocess.run(
                    ["git", "rev-list", "--count", f"HEAD..origin/{current_branch}"],
                    capture_output=True,
                    text=True,
                    timeout=30,
                )
                if result.returncode == 0 and result.stdout.strip() != "0":
                    subprocess.run(
                        ["git", "pull", "origin", current_branch],
                        check=True,
                        timeout=60,
                    )
                    self.logger.info("ğŸ“¥ ØªÙ… Ø¯Ù…Ø¬ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª")
            except Exception as e:
                pass

            # 3. Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª ÙˆØ±ÙØ¹Ù‡Ø§
            if self.check_git_status():
                subprocess.run(["git", "add", "."], check=True, timeout=30)

                # Ø¥Ù†Ø´Ø§Ø¡ Ø±Ø³Ø§Ù„Ø© commit Ø°ÙƒÙŠØ©
                timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                commit_msg = f"ğŸ¤– Auto-sync: {timestamp}"

                # Ø¥Ø¶Ø§ÙØ© Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
                stats_msg = (
                    f" | Syncs: {self.sync_stats['total_syncs']}, Formats: {self.sync_stats['code_formats']}"
                )
                full_msg = commit_msg + stats_msg

                subprocess.run(
                    ["git", "commit", "-m", full_msg], check=True, timeout=30
                )
                subprocess.run(
                    ["git", "push", "origin", current_branch], check = (
                        True, timeout=90
                    )
                )

                self.logger.info(f"âœ… ØªÙ… Ø±ÙØ¹ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª Ø¥Ù„Ù‰ {current_branch}")
                self.sync_stats["git_pushes"] += 1
                return True
            else:
                self.logger.debug("ğŸ“ Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØºÙŠÙŠØ±Ø§Øª Ù„Ù„Ø±ÙØ¹")
                return False

        except subprocess.CalledProcessError as e:
            self.logger.error(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ù…Ø²Ø§Ù…Ù†Ø© Git: {e}")
            self.sync_stats["failed_syncs"] += 1
            return False
        except Exception as e:
            self.logger.error(f"âŒ Ø®Ø·Ø£ Ø¹Ø§Ù… ÙÙŠ Git: {e}")
            return False

    def full_sync_cycle(self):
        """Ø¯ÙˆØ±Ø© Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø©"""
        if self.is_syncing:
            self.logger.debug("â¸ï¸  Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© Ø¬Ø§Ø±ÙŠØ© Ø¨Ø§Ù„ÙØ¹Ù„")
            return

        self.is_syncing = True
        self.sync_stats["total_syncs"] += 1

        try:
            self.logger.info("ğŸš€ Ø¨Ø¯Ø¡ Ø¯ÙˆØ±Ø© Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø©")
            start_time = time.time()

            # 1. ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ÙƒÙˆØ¯
            code_formatted = self.format_code()

            # 2. Ù…Ø²Ø§Ù…Ù†Ø© Git
            git_synced = self.git_sync()

            # 3. ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
            if code_formatted or git_synced:
                self.sync_stats["successful_syncs"] += 1
                self.pending_changes = False
                self.last_sync = datetime.now()

            duration = time.time() - start_time
            self.logger.info(f"âœ¨ Ø§Ù†ØªÙ‡Øª Ø¯ÙˆØ±Ø© Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© ÙÙŠ {duration:.2f} Ø«Ø§Ù†ÙŠØ©")

        except Exception as e:
            self.logger.error(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø¯ÙˆØ±Ø© Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø©: {e}")
            self.sync_stats["failed_syncs"] += 1
        finally:
            self.is_syncing = False

    def start_file_watcher(self):
        """Ù…Ø±Ø§Ù‚Ø¨ ØªØºÙŠÙŠØ±Ø§Øª Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…"""

        class SmartFileHandler(FileSystemEventHandler):
            def __init__(self, sync_instance):
                self.sync_instance = sync_instance
                self.last_event_time = {}

            def on_modified(self, event):
                if event.is_directory:
                    return

                # ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª ØºÙŠØ± Ø§Ù„Ù…Ù‡Ù…Ø©
                ignored_extensions = [
                    ".log",
                    ".tmp",
                    ".pyc",
                    ".pyo",
                    ".pyd",
                    "__pycache__",
                ]
                if any(event.src_path.endswith(ext) for ext in ignored_extensions):
                    return

                # ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ù…ÙƒØ±Ø±Ø©
                now = time.time()
                if event.src_path in self.last_event_time:
                    if now - self.last_event_time[event.src_path] < 2:
                        return

                self.last_event_time[event.src_path] = now

                # ÙÙ‚Ø· Ù…Ù„ÙØ§Øª Python ÙˆØ§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ù‡Ù…Ø©
                if event.src_path.endswith(
                    (".py", ".md", ".txt", ".yml", ".yaml", ".json")
                ):
                    self.sync_instance.pending_changes = True
                    self.sync_instance.logger.debug(
                        f"ğŸ“ ØªÙ… ØªØ¹Ø¯ÙŠÙ„: {os.path.basename(event.src_path)}"
                    )

        event_handler = SmartFileHandler(self)
        observer = Observer()
        observer.schedule(event_handler, self.project_path, recursive=True)
        observer.start()
        self.logger.info("ğŸ‘€ ØªÙ… Ø¨Ø¯Ø¡ Ù…Ø±Ø§Ù‚Ø¨ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø°ÙƒÙŠ")
        return observer

    def print_stats(self):
        """Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª"""
        stats_text = f"""
ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø£ØªÙ…ØªØ©:
â”œâ”€â”€ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø§Øª: {self.sync_stats['total_syncs']}
â”œâ”€â”€ Ù…Ø²Ø§Ù…Ù†Ø§Øª Ù†Ø§Ø¬Ø­Ø©: {self.sync_stats['successful_syncs']}
â”œâ”€â”€ Ù…Ø²Ø§Ù…Ù†Ø§Øª ÙØ§Ø´Ù„Ø©: {self.sync_stats['failed_syncs']}
â”œâ”€â”€ ØªÙ†Ø³ÙŠÙ‚Ø§Øª Ø§Ù„ÙƒÙˆØ¯: {self.sync_stats['code_formats']}
â”œâ”€â”€ Ø±ÙØ¹ Git: {self.sync_stats['git_pushes']}
â””â”€â”€ Ø¢Ø®Ø± Ù…Ø²Ø§Ù…Ù†Ø©: {self.last_sync.strftime('%Y-%m-%d %H:%M:%S') if self.last_sync else 'Ù„Ù… ØªØ­Ø¯Ø« Ø¨Ø¹Ø¯'}
"""
        self.logger.info(stats_text)

    def start_scheduler(self):
        """Ø¨Ø¯Ø¡ Ø¬Ø¯ÙˆÙ„Ø© Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ø°ÙƒÙŠØ©"""
        # Ù…Ø²Ø§Ù…Ù†Ø© ÙƒÙ„ 45 Ø«Ø§Ù†ÙŠØ©
        schedule.every(45).seconds.do(self.full_sync_cycle)

        # Ù…Ø²Ø§Ù…Ù†Ø© Ø¹Ù†Ø¯ ÙˆØ¬ÙˆØ¯ ØªØºÙŠÙŠØ±Ø§Øª Ù…Ø¹Ù„Ù‚Ø©
        def sync_if_pending():
            if self.pending_changes and not self.is_syncing:
                self.full_sync_cycle()

        schedule.every(15).seconds.do(sync_if_pending)

        # Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ÙƒÙ„ 5 Ø¯Ù‚Ø§Ø¦Ù‚
        schedule.every(5).minutes.do(self.print_stats)

        self.logger.info("â° ØªÙ… Ø¨Ø¯Ø¡ Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø© Ø§Ù„Ø°ÙƒÙŠØ©")

    def run(self):
        """ØªØ´ØºÙŠÙ„ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„ÙƒØ§Ù…Ù„"""
        self.logger.info("ğŸš€ Ø¨Ø¯Ø¡ Ù†Ø¸Ø§Ù… Ø§Ù„Ø£ØªÙ…ØªØ© Ø§Ù„Ø´Ø§Ù…Ù„Ø©")

        # ÙØ­Øµ Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª
        if not self.check_dependencies():
            self.logger.error("âŒ Ø¨Ø¹Ø¶ Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª ØºÙŠØ± Ù…ØªÙˆÙØ±Ø©")
            return

        # Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù…
        current_branch, remote_url = self.get_git_info()
        self.logger.info(f"ğŸ“‚ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹: {os.path.basename(self.project_path)}")
        self.logger.info(f"ğŸŒ¿ Ø§Ù„ÙØ±Ø¹: {current_branch}")
        self.logger.info(f"ğŸ”— Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹: {remote_url}")

        # Ø¨Ø¯Ø¡ Ù…Ø±Ø§Ù‚Ø¨ Ø§Ù„Ù…Ù„ÙØ§Øª
        observer = self.start_file_watcher()

        # Ø¨Ø¯Ø¡ Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø©
        self.start_scheduler()

        # ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰
        self.full_sync_cycle()

        self.logger.info("ğŸ¯ Ø§Ù„Ù†Ø¸Ø§Ù… Ø¬Ø§Ù‡Ø²! Ø§Ø¶ØºØ· Ctrl+C Ù„Ù„Ø¥ÙŠÙ‚Ø§Ù")

        try:
            while True:
                schedule.run_pending()
                time.sleep(1)
        except KeyboardInterrupt:
            self.logger.info("â¹ï¸  ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù†Ø¸Ø§Ù… Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…")
            self.print_stats()
        finally:
            observer.stop()
            observer.join()
            self.logger.info("ğŸ‘‹ ÙˆØ¯Ø§Ø¹Ø§Ù‹!")



import subprocess
import sys


def run_formatter_and_linter():
    print("ğŸ”§ ØªØ´ØºÙŠÙ„ Ø£Ø¯ÙˆØ§Øª Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ ÙˆØ§Ù„ÙØ­Øµ...")

    # Run Black
    try:
        print("Running Black...")
        subprocess.run(
            [sys.executable, "-m", "black", "."],
            check=True,
            capture_output=True,
            text=True,
        )
        print("âœ… Black finished.")
    except subprocess.CalledProcessError as e:
        print(f"âŒ Black failed: {e.stderr}")
    except FileNotFoundError:
        print("âš ï¸ Black not found. Please install it: pip install black")

    # Run isort
    try:
        print("Running isort...")
        subprocess.run(
            [sys.executable, "-m", "isort", "."],
            check=True,
            capture_output=True,
            text=True,
        )
        print("âœ… isort finished.")
    except subprocess.CalledProcessError as e:
        print(f"âŒ isort failed: {e.stderr}")
    except FileNotFoundError:
        print("âš ï¸ isort not found. Please install it: pip install isort")

    # Run flake8
    try:
        print("Running flake8...")
        result = subprocess.run(
            [
                "python",
                "-m",
                "flake8",
                ".",
                "--exclude=venv,docs,tests,venv/Lib/site-packages",
            ],  # ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ù†Ø§
            capture_output=True,
            text=True,
        )
        if result.stdout:
            print("âš ï¸ Flake8 found issues:")
            print(result.stdout)
        else:
            print("âœ… Flake8 found no issues.")
    except FileNotFoundError:
        print("âš ï¸ flake8 not found. Please install it: pip install flake8")


if __name__ == "__main__":
    run_formatter_and_linter()



#!/usr/bin/env python3
"""
Ø§Ù„Ø­Ù„ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ ÙˆØ§Ù„Ø´Ø§Ù…Ù„ Ù„Ø¬Ù…ÙŠØ¹ Ø£Ø®Ø·Ø§Ø¡ flake8
ÙŠØµÙ„Ø­ ÙƒÙ„ Ø´ÙŠØ¡ ÙÙŠ Ø¯Ù‚Ø§Ø¦Ù‚!
"""

import os
import re
import subprocess
import sys
from pathlib import Path


class FlakeFixer:
    def __init__(self):
        self.fixed_files = []
        self.errors_fixed = 0

    def run_black_and_isort(self):
        """ØªØ´ØºÙŠÙ„ Black Ùˆ isort Ø£ÙˆÙ„Ø§Ù‹"""
        print("ğŸ”§ ØªØ´ØºÙŠÙ„ Black Ùˆ isort...")

        try:
            subprocess.run(
                [sys.executable, "-m", "black", "."], check=True, capture_output=True
            )
            print("âœ… Black ØªÙ… Ø¨Ù†Ø¬Ø§Ø­")
        except:
            print("âŒ Black ÙØ´Ù„ - Ø§Ø³ØªÙƒÙ…Ø§Ù„ Ø¨Ø¯ÙˆÙ†Ù‡")

        try:
            subprocess.run(
                [sys.executable, "-m", "isort", "."], check=True, capture_output=True
            )
            print("âœ… isort ØªÙ… Ø¨Ù†Ø¬Ø§Ø­")
        except:
            print("âŒ isort ÙØ´Ù„ - Ø§Ø³ØªÙƒÙ…Ø§Ù„ Ø¨Ø¯ÙˆÙ†Ù‡")

    def fix_app_py(self):
        """Ø¥ØµÙ„Ø§Ø­ Ø´Ø§Ù…Ù„ Ù„Ù…Ù„Ù app.py"""
        file_path = "app.py"
        if not os.path.exists(file_path):
            return

        print(f"ğŸ”§ Ø¥ØµÙ„Ø§Ø­ {file_path}...")

        with open(file_path, "r", encoding="utf-8") as f:
            content = f.read()

        original_content = content

        # 1. Ø­Ø°Ù imports ØºÙŠØ± Ù…Ø³ØªØ®Ø¯Ù…Ø©
        imports_to_remove = [
            r"^from flask import.*g.*\n",
            r"^from models import.*AppSetting.*\n",
            r"^from werkzeug\.security import check_password_hash\n",
            r"^from werkzeug\.utils import secure_filename\n",
        ]

        for pattern in imports_to_remove:
            content = re.sub(pattern, "", content, flags=re.MULTILINE)

        # 2. Ø¥ØµÙ„Ø§Ø­ error_handler ØºÙŠØ± Ù…Ø³ØªØ®Ø¯Ù…
        content = re.sub(
            r"\s*error_handler = init_error_handlers\(app\)",
            "    init_error_handlers(app)",
            content,
        )

        # 3. Ø¥ØµÙ„Ø§Ø­ Ù…Ù‚Ø§Ø±Ù†Ø§Øª False
        content = content.replace(
            "if not user.is_verified == False:", "if user.is_verified:"
        )
        content = content.replace(
            "Message.is_deleted == False", "Message.is_deleted is False"
        )

        # 4. Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„Ø·ÙˆÙŠÙ„Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
        long_lines_fixes = {
            # Flash messages
            r'flash\("ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø±Ù…Ø² Ø§Ù„ØªÙØ¹ÙŠÙ„ Ø¥Ù„Ù‰ Ø¨Ø±ÙŠØ¯Ùƒ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ\. ÙŠØ±Ø¬Ù‰ ÙØ­Øµ ØµÙ†Ø¯ÙˆÙ‚ Ø§Ù„ÙˆØ§Ø±Ø¯\."[^\n]*\)': 'flash(\n            "ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø±Ù…Ø² Ø§Ù„ØªÙØ¹ÙŠÙ„ Ø¥Ù„Ù‰ Ø¨Ø±ÙŠØ¯Ùƒ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ. "\n            "ÙŠØ±Ø¬Ù‰ ÙØ­Øµ ØµÙ†Ø¯ÙˆÙ‚ Ø§Ù„ÙˆØ§Ø±Ø¯.", "info"\n        )',
            r'flash\("Ø±Ù…Ø² Ø§Ù„ØªÙØ¹ÙŠÙ„ ØºÙŠØ± ØµØ­ÙŠØ­ Ø£Ùˆ Ù…Ù†ØªÙ‡ÙŠ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©\. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰\."[^\n]*\)': 'flash(\n            "Ø±Ù…Ø² Ø§Ù„ØªÙØ¹ÙŠÙ„ ØºÙŠØ± ØµØ­ÙŠØ­ Ø£Ùˆ Ù…Ù†ØªÙ‡ÙŠ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©. "\n            "ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.", "error"\n        )',
            r'flash\("Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©\. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰\."[^\n]*\)': 'flash(\n            "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©. "\n            "ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.", "error"\n        )',
        }

        for pattern, replacement in long_lines_fixes.items():
            content = re.sub(pattern, replacement, content)

        # 5. ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø£Ø³Ø·Ø± Ø§Ù„Ø·ÙˆÙŠÙ„Ø© Ø§Ù„Ø¹Ø§Ù…Ø©
        lines = content.split("\n")
        fixed_lines = []

        for line in lines:
            if len(line) > 79 and ('"' in line or "'" in line):
                # ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø£Ø³Ø·Ø± Ø§Ù„Ø·ÙˆÙŠÙ„Ø©
                if "flash(" in line and len(line) > 79:
                    # Ø¥ØµÙ„Ø§Ø­ Ø®Ø§Øµ Ù„Ù€ flash
                    indent = len(line) - len(line.lstrip())
                    if '"' in line:
                        parts = line.split('"')
                        if len(parts) >= 3:
                            fixed_line = f"{' ' * indent}flash(\n{' ' * (indent + 4)}\"{parts[1]}\",\n{' ' * (indent + 4)}\"{parts[3] if len(parts) > 3 else 'info'}\"\n{' ' * indent})"
                            fixed_lines.append(fixed_line)
                            continue
                elif "user.code_expiry = datetime.utcnow() + timedelta" in line:
                    # Ø¥ØµÙ„Ø§Ø­ Ø®Ø§Øµ Ù„Ù„ØªØ§Ø±ÙŠØ®
                    indent = len(line) - len(line.lstrip())
                    fixed_lines.append(
                        f"{' ' * indent}user.code_expiry = (\n{' ' * (indent + 4)}datetime.utcnow() + timedelta(minutes=15)\n{' ' * indent})"
                    )
                    continue

            fixed_lines.append(line)

        content = "\n".join(fixed_lines)

        if content != original_content:
            with open(file_path, "w", encoding="utf-8") as f:
                f.write(content)
            self.fixed_files.append(file_path)
            print(f"âœ… ØªÙ… Ø¥ØµÙ„Ø§Ø­ {file_path}")

    def fix_telegram_bot_py(self):
        """Ø¥ØµÙ„Ø§Ø­ Ù…Ù„Ù telegram_bot.py"""
        file_path = "telegram_bot.py"
        if not os.path.exists(file_path):
            return

        print(f"ğŸ”§ Ø¥ØµÙ„Ø§Ø­ {file_path}...")

        with open(file_path, "r", encoding="utf-8") as f:
            content = f.read()

        # Ø­Ø°Ù imports ØºÙŠØ± Ù…Ø³ØªØ®Ø¯Ù…Ø©
        imports_to_remove = [
            r"^import json\n",
            r"^import logging\n",
            r"^from flask import current_app\n",
        ]

        for pattern in imports_to_remove:
            content = re.sub(pattern, "", content, flags=re.MULTILINE)

        # Ø¥ØµÙ„Ø§Ø­ except Ø¹Ø§Ø±ÙŠØ©
        content = re.sub(r"except:\s*\n", "except Exception as e:\n", content)

        # Ø­Ø°Ù trailing whitespace
        content = re.sub(r"[ \t]+$", "", content, flags=re.MULTILINE)

        # ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø£Ø³Ø·Ø± Ø§Ù„Ø·ÙˆÙŠÙ„Ø©
        lines = content.split("\n")
        fixed_lines = []

        for line in lines:
            if len(line) > 79:
                # ØªÙ‚Ø³ÙŠÙ… Ø¨Ø³ÙŠØ· Ù„Ù„Ø£Ø³Ø·Ø± Ø§Ù„Ø·ÙˆÙŠÙ„Ø©
                if '"' in line and "=" in line:
                    parts = line.split("=", 1)
                    if len(parts) == 2:
                        indent = len(parts[0]) - len(parts[0].lstrip())
                        fixed_lines.append(f"{parts[0].rstrip()} = (")
                        fixed_lines.append(f"{' ' * (indent + 4)}{parts[1].strip()}")
                        fixed_lines.append(f"{' ' * indent})")
                        continue

            fixed_lines.append(line)

        content = "\n".join(fixed_lines)

        with open(file_path, "w", encoding="utf-8") as f:
            f.write(content)
        self.fixed_files.append(file_path)
        print(f"âœ… ØªÙ… Ø¥ØµÙ„Ø§Ø­ {file_path}")

    def fix_other_files(self):
        """Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø£Ø®Ø±Ù‰"""
        files_to_fix = {
            "analyze.py": {"remove_vars": ['command_target = "."'], "fix_lines": True},
            "ultimate_auto_sync.py": {
                "remove_imports": ["json", "threading", "pathlib.Path", "psutil"],
                "fix_except": True,
                "fix_lines": True,
            },
            "quick_start.py": {"remove_imports": ["os"], "fix_except": True},
            "service_runner.py": {"fix_except": True},
            "fix_flake8.py": {"remove_imports": ["os"]},
            "test_profile.py": {"fix_lines": True},
        }

        for filename, fixes in files_to_fix.items():
            if not os.path.exists(filename):
                continue

            print(f"ğŸ”§ Ø¥ØµÙ„Ø§Ø­ {filename}...")

            with open(filename, "r", encoding="utf-8") as f:
                content = f.read()

            original_content = content

            # Ø­Ø°Ù imports
            if "remove_imports" in fixes:
                for imp in fixes["remove_imports"]:
                    patterns = [f"^import {imp}\n", f"^from {imp} import.*\n"]
                    for pattern in patterns:
                        content = re.sub(pattern, "", content, flags=re.MULTILINE)

            # Ø­Ø°Ù Ù…ØªØºÙŠØ±Ø§Øª
            if "remove_vars" in fixes:
                for var in fixes["remove_vars"]:
                    content = re.sub(
                        f"^.*{re.escape(var)}.*\n", "", content, flags=re.MULTILINE
                    )

            # Ø¥ØµÙ„Ø§Ø­ except
            if fixes.get("fix_except"):
                content = re.sub(r"except:\s*\n", "except Exception as e:\n", content)

            # Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ø£Ø³Ø·Ø± Ø§Ù„Ø·ÙˆÙŠÙ„Ø©
            if fixes.get("fix_lines"):
                lines = content.split("\n")
                fixed_lines = []

                for line in lines:
                    if len(line) > 79:
                        # ØªÙ‚Ø³ÙŠÙ… Ø¨Ø³ÙŠØ·
                        if "=" in line and ('"' in line or "'" in line):
                            indent = len(line) - len(line.lstrip())
                            if indent < 60:  # ØªØ¬Ù†Ø¨ Ø§Ù„ØªØ¯Ø§Ø®Ù„ Ø§Ù„Ù…ÙØ±Ø·
                                parts = line.split("=", 1)
                                if len(parts) == 2:
                                    fixed_lines.append(f"{parts[0].rstrip()} = (")
                                    fixed_lines.append(
                                        f"{' ' * (indent + 4)}{parts[1].strip()}"
                                    )
                                    fixed_lines.append(f"{' ' * indent})")
                                    continue

                    fixed_lines.append(line)

                content = "\n".join(fixed_lines)

            if content != original_content:
                with open(filename, "w", encoding="utf-8") as f:
                    f.write(content)
                self.fixed_files.append(filename)
                print(f"âœ… ØªÙ… Ø¥ØµÙ„Ø§Ø­ {filename}")

    def check_flake8(self):
        """ÙØ­Øµ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ù…Ø¹ flake8"""
        print("\nğŸ” ÙØ­Øµ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ù…Ø¹ flake8...")

        try:
            result = subprocess.run(
                [
                    "python",
                    "-m",
                    "flake8",
                    ".",
                    "--exclude=venv,docs,tests,node_modules,dist",
                ],
                capture_output=True,
                text=True,
            )

            if result.stdout.strip():
                print("âš ï¸ Ù„Ø§ ØªØ²Ø§Ù„ Ù‡Ù†Ø§Ùƒ Ù…Ø´Ø§ÙƒÙ„:")
                print(result.stdout)
                return False
            else:
                print("âœ… ØªÙ… Ø¥ØµÙ„Ø§Ø­ Ø¬Ù…ÙŠØ¹ Ù…Ø´Ø§ÙƒÙ„ flake8!")
                return True

        except FileNotFoundError:
            print("âŒ flake8 ØºÙŠØ± Ù…Ø«Ø¨Øª")
            return False

    def run_fix(self):
        """ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¥ØµÙ„Ø§Ø­ Ø§Ù„ÙƒØ§Ù…Ù„"""
        print("ğŸš€ Ø¨Ø¯Ø¡ Ø§Ù„Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ø´Ø§Ù…Ù„ Ù„Ø¬Ù…ÙŠØ¹ Ø£Ø®Ø·Ø§Ø¡ flake8...")
        print("=" * 60)

        # 1. ØªØ´ØºÙŠÙ„ Black Ùˆ isort
        self.run_black_and_isort()

        # 2. Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
        self.fix_app_py()
        self.fix_telegram_bot_py()
        self.fix_other_files()

        # 3. ÙØ­Øµ Ø§Ù„Ù†ØªØ§Ø¦Ø¬
        success = self.check_flake8()

        # 4. ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ù†ØªØ§Ø¦Ø¬
        print("\n" + "=" * 60)
        print("ğŸ“Š ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ø¥ØµÙ„Ø§Ø­:")
        print(f"âœ… ØªÙ… Ø¥ØµÙ„Ø§Ø­ {len(self.fixed_files)} Ù…Ù„Ù")

        if self.fixed_files:
            print("ğŸ“ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…ÙØµÙ„Ø­Ø©:")
            for file in self.fixed_files:
                print(f"   - {file}")

        if success:
            print("\nğŸ‰ ØªÙ… Ø¥ØµÙ„Ø§Ø­ Ø¬Ù…ÙŠØ¹ Ù…Ø´Ø§ÙƒÙ„ flake8 Ø¨Ù†Ø¬Ø§Ø­!")
            print("\nğŸ“ Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©:")
            print("1. git add .")
            print("2. git commit -m 'Fix all flake8 issues'")
            print("3. git push origin main")
        else:
            print("\nâš ï¸ Ù‚Ø¯ ØªØ­ØªØ§Ø¬ Ù„Ø¥ØµÙ„Ø§Ø­Ø§Øª ÙŠØ¯ÙˆÙŠØ© Ø¥Ø¶Ø§ÙÙŠØ©")

        return success


if __name__ == "__main__":
    fixer = FlakeFixer()
    fixer.run_fix()



# Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
if __name__ == "__main__":
    # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Ø¸Ø§Ù… ÙˆØªØ´ØºÙŠÙ„Ù‡
    auto_sync = UltimateAutoSync()
    auto_sync.run()
