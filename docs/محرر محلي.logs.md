(venv) PS C:\Users\pc\Downloads\senioraaa-main> python fix_flake











                                                python fix_flake8.py
🔧 تشغيل أدوات التنسيق والفحص...
Running Black...
❌ Black failed: reformatted C:\Users\pc\Downloads\senioraaa-main\analyze.py
error: cannot format C:\Users\pc\Downloads\senioraaa-main\telegram_bot.py: Cannot parse for target version Python 3.11: 120:56:             "\u26a1 \u0641\u0648\u0631\u064a" if order_data.get("transfer_type") = (        
error: cannot format C:\Users\pc\Downloads\senioraaa-main\ultimate_auto_sync.py: Cannot parse for target version Python 3.11: 55:31:                     True, check=True)
reformatted C:\Users\pc\Downloads\senioraaa-main\app.py

Oh no! \U0001f4a5 \U0001f494 \U0001f4a5
2 files reformatted, 7 files left unchanged, 2 files failed to reformat.

Running isort...
✅ isort finished.
Running flake8...
⚠️ Flake8 found issues:
.\analyze.py:37:80: E501 line too long (81 > 79 characters)
.\analyze.py:41:80: E501 line too long (86 > 79 characters)
.\app.py:10:1: F401 'error_handlers.init_error_handlers' imported but unused
.\app.py:15:1: F401 'flask.g' imported but unused
.\app.py:33:1: F401 'models.AppSetting' imported but unused
.\app.py:124:80: E501 line too long (84 > 79 characters)
.\app.py:172:80: E501 line too long (82 > 79 characters)
.\app.py:222:80: E501 line too long (87 > 79 characters)
.\app.py:223:80: E501 line too long (87 > 79 characters)
.\app.py:259:80: E501 line too long (85 > 79 characters)
.\app.py:283:80: E501 line too long (88 > 79 characters)
.\app.py:303:80: E501 line too long (84 > 79 characters)
.\app.py:350:80: E501 line too long (84 > 79 characters)
.\app.py:365:80: E501 line too long (108 > 79 characters)
.\app.py:405:80: E501 line too long (81 > 79 characters)
.\app.py:426:80: E501 line too long (84 > 79 characters)
.\app.py:498:80: E501 line too long (108 > 79 characters)
.\app.py:504:80: E501 line too long (87 > 79 characters)
.\app.py:508:80: E501 line too long (82 > 79 characters)
.\app.py:525:80: E501 line too long (87 > 79 characters)
.\app.py:562:80: E501 line too long (85 > 79 characters)
.\app.py:582:80: E501 line too long (80 > 79 characters)
.\app.py:596:80: E501 line too long (84 > 79 characters)
.\app.py:643:80: E501 line too long (82 > 79 characters)
.\app.py:665:80: E501 line too long (80 > 79 characters)
.\quick_start.py:34:5: F841 local variable 'e' is assigned to but never used
.\service_runner.py:61:9: F841 local variable 'e' is assigned to but never used
.\telegram_bot.py:120:14: E999 SyntaxError: expected 'else' after 'if' expression
.\test_profile.py:34:80: E501 line too long (91 > 79 characters)
.\ultimate_auto_sync.py:55:28: E999 SyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='? 
.\ultimate_flake8_fixer.py:11:1: F401 'pathlib.Path' imported but unused
.\ultimate_flake8_fixer.py:25:80: E501 line too long (85 > 79 characters)
.\ultimate_flake8_fixer.py:28:9: E722 do not use bare 'except'
.\ultimate_flake8_fixer.py:33:80: E501 line too long (85 > 79 characters)
.\ultimate_flake8_fixer.py:36:9: E722 do not use bare 'except'
.\ultimate_flake8_fixer.py:81:80: E501 line too long (226 > 79 characters)
.\ultimate_flake8_fixer.py:82:80: E501 line too long (223 > 79 characters)
.\ultimate_flake8_fixer.py:83:80: E501 line too long (201 > 79 characters)
.\ultimate_flake8_fixer.py:102:80: E501 line too long (184 > 79 characters)
.\ultimate_flake8_fixer.py:105:80: E501 line too long (80 > 79 characters)
.\ultimate_flake8_fixer.py:109:80: E501 line too long (141 > 79 characters)
.\ultimate_flake8_fixer.py:162:80: E501 line too long (85 > 79 characters)
.\ultimate_flake8_fixer.py:178:80: E501 line too long (87 > 79 characters)
.\ultimate_flake8_fixer.py:180:80: E501 line too long (82 > 79 characters)
.\ultimate_flake8_fixer.py:206:80: E501 line too long (82 > 79 characters)
.\ultimate_flake8_fixer.py:212:80: E501 line too long (83 > 79 characters)
.\ultimate_flake8_fixer.py:217:80: E501 line too long (86 > 79 characters)
.\ultimate_flake8_fixer.py:232:80: E501 line too long (82 > 79 characters)
.\ultimate_flake8_fixer.py:234:80: E501 line too long (81 > 79 characters)

(venv) PS C:\Users\pc\Downloads\senioraaa-main> 

(venv) PS C:\Users\pc\Downloads\senioraaa-main> python ultimate_flake8_fixer











                                                python ultimate_flake8_fixer.py 
🚀 بدء الإصلاح الشامل لجميع أخطاء flake8...
============================================================
🔧 تشغيل Black و isort...
❌ Black فشل - استكمال بدونه
✅ isort تم بنجاح
🔧 إصلاح app.py...
✅ تم إصلاح app.py
🔧 إصلاح telegram_bot.py...
✅ تم إصلاح telegram_bot.py
🔧 إصلاح analyze.py...
✅ تم إصلاح analyze.py
🔧 إصلاح ultimate_auto_sync.py...
🔧 إصلاح quick_start.py...
🔧 إصلاح service_runner.py...
🔧 إصلاح fix_flake8.py...
🔧 إصلاح test_profile.py...

🔍 فحص النتائج مع flake8...
⚠️ لا تزال هناك مشاكل:
.\analyze.py:44:80: E501 line too long (80 > 79 characters)
.\app.py:10:1: F401 'error_handlers.init_error_handlers' imported but unused
.\app.py:15:1: F401 'flask.g' imported but unused
.\app.py:33:1: F401 'models.AppSetting' imported but unused
.\app.py:124:80: E501 line too long (84 > 79 characters)
.\app.py:172:80: E501 line too long (82 > 79 characters)
.\app.py:222:80: E501 line too long (87 > 79 characters)
.\app.py:223:80: E501 line too long (87 > 79 characters)
.\app.py:286:80: E501 line too long (88 > 79 characters)
.\app.py:356:80: E501 line too long (84 > 79 characters)
.\app.py:371:80: E501 line too long (108 > 79 characters)
.\app.py:510:80: E501 line too long (108 > 79 characters)
.\app.py:516:80: E501 line too long (87 > 79 characters)
.\app.py:520:80: E501 line too long (82 > 79 characters)
.\app.py:537:80: E501 line too long (87 > 79 characters)
.\app.py:597:80: E501 line too long (80 > 79 characters)
.\app.py:611:80: E501 line too long (84 > 79 characters)
.\app.py:658:80: E501 line too long (82 > 79 characters)
.\app.py:680:80: E501 line too long (80 > 79 characters)
.\quick_start.py:34:5: F841 local variable 'e' is assigned to but never used
.\service_runner.py:61:9: F841 local variable 'e' is assigned to but never used
.\telegram_bot.py:120:14: E999 SyntaxError: expected 'else' after 'if' expression
.\test_profile.py:34:80: E501 line too long (91 > 79 characters)
.\ultimate_auto_sync.py:55:28: E999 SyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='? 
.\ultimate_flake8_fixer.py:11:1: F401 'pathlib.Path' imported but unused
.\ultimate_flake8_fixer.py:25:80: E501 line too long (85 > 79 characters)
.\ultimate_flake8_fixer.py:28:9: E722 do not use bare 'except'
.\ultimate_flake8_fixer.py:33:80: E501 line too long (85 > 79 characters)
.\ultimate_flake8_fixer.py:36:9: E722 do not use bare 'except'
.\ultimate_flake8_fixer.py:81:80: E501 line too long (226 > 79 characters)
.\ultimate_flake8_fixer.py:82:80: E501 line too long (223 > 79 characters)
.\ultimate_flake8_fixer.py:83:80: E501 line too long (201 > 79 characters)
.\ultimate_flake8_fixer.py:102:80: E501 line too long (184 > 79 characters)
.\ultimate_flake8_fixer.py:105:80: E501 line too long (80 > 79 characters)
.\ultimate_flake8_fixer.py:109:80: E501 line too long (141 > 79 characters)
.\ultimate_flake8_fixer.py:162:80: E501 line too long (85 > 79 characters)
.\ultimate_flake8_fixer.py:178:80: E501 line too long (87 > 79 characters)
.\ultimate_flake8_fixer.py:180:80: E501 line too long (82 > 79 characters)
.\ultimate_flake8_fixer.py:206:80: E501 line too long (82 > 79 characters)
.\ultimate_flake8_fixer.py:212:80: E501 line too long (83 > 79 characters)
.\ultimate_flake8_fixer.py:217:80: E501 line too long (86 > 79 characters)
.\ultimate_flake8_fixer.py:232:80: E501 line too long (82 > 79 characters)
.\ultimate_flake8_fixer.py:234:80: E501 line too long (81 > 79 characters)


============================================================
📊 تقرير الإصلاح:
✅ تم إصلاح 3 ملف
📁 الملفات المُصلحة:
   - app.py
   - telegram_bot.py
   - analyze.py

⚠️ قد تحتاج لإصلاحات يدوية إضافية
(venv) PS C:\Users\pc\Downloads\senioraaa-main> 




import os
from datetime import datetime
from typing import Any, Dict, Optional

import requests


class TelegramNotificationSystem:
    """نظام إشعارات التليجرام المتقدم"""

    def __init__(self, app=None):
        self.app = app
        self.bot_token = None
        self.bot_username = None
        self.webhook_url = None
        self.base_url = None

        if app:
            self.init_app(app)

    def init_app(self, app):
        """تهيئة نظام التليجرام مع التطبيق"""
        self.app = app
        self.bot_token = os.environ.get("TELEGRAM_BOT_TOKEN")
        self.bot_username = os.environ.get("BOT_USERNAME", "YourBot_bot")
        self.webhook_url = os.environ.get("TELEGRAM_WEBHOOK_URL")

        if self.bot_token:
            self.base_url = f"https://api.telegram.org/bot{self.bot_token}"
            app.logger.info("Telegram bot initialized successfully")
        else:
            app.logger.warning("Telegram bot token not configured")

    def is_configured(self) -> bool:
        """فحص ما إذا كان البوت مُعد بشكل صحيح"""
        return bool(self.bot_token and self.base_url)

    def send_message(
        self, chat_id: str, message: str, parse_mode: str = "HTML"
    ) -> bool:
        """إرسال رسالة إلى مستخدم محدد"""
        if not self.is_configured():
            self.app.logger.warning("Telegram bot not configured, skipping message")
            return False

        try:
            url = f"{self.base_url}/sendMessage"
            payload = (
                {"chat_id": chat_id, "text": message, "parse_mode": parse_mode}
            )

            response = requests.post(url, json=payload, timeout=10)
            result = response.json()

            if result.get("ok"):
                self.app.logger.info(f"Message sent successfully to {chat_id}")
                return True
            else:
                self.app.logger.error(f"Failed to send message: {result}")
                return False

        except Exception as e:
            self.app.logger.error(f"Error sending Telegram message: {e}")
            return False

    def send_order_notification(
        self, user_telegram_id: str, order_data: Dict[str, Any]
    ) -> bool:
        """إرسال إشعار عن طلب جديد"""
        if not user_telegram_id:
            return False

        # تنسيق رسالة الطلب
        message = self.format_order_message(order_data)
        return self.send_message(user_telegram_id, message)

    def send_status_update(
        self, user_telegram_id: str, order_id: int, old_status: str, new_status: str
    ) -> bool:
        """إرسال تحديث حالة الطلب"""
        if not user_telegram_id:
            return False

        status_messages = {
            "pending": "⏳ قيد الانتظار",
            "processing": "⚙️ قيد المعالجة",
            "completed": "✅ مكتمل",
            "cancelled": "❌ ملغي",
        }

        old_status_text = status_messages.get(old_status, old_status)
        new_status_text = status_messages.get(new_status, new_status)

        message = f"""
🔔 <b>تحديث حالة الطلب #{order_id}</b>

📊 الحالة السابقة: {old_status_text}
🆕 الحالة الجديدة: {new_status_text}

🕒 وقت التحديث: {datetime.now().strftime('%Y-%m-%d %H:%M')}

شكراً لاختيارك شهد السنيورة! 🎮
        """

        return self.send_message(user_telegram_id, message.strip())

    def format_order_message(self, order_data: Dict[str, Any]) -> str:
        """تنسيق رسالة الطلب الجديد"""
        platform_icons = (
            {"PS": "🎮 PlayStation", "Xbox": "🎯 Xbox", "PC": "💻 PC"}
        )

        platform_text = platform_icons.get(
            order_data.get("platform", ""), order_data.get("platform", "")
        )
        coins_amount = order_data.get("coins_amount", 0)
        formatted_coins = f"{coins_amount:,}" if coins_amount else "غير محدد"

        transfer_type_text = (
            "⚡ فوري" if order_data.get("transfer_type") = (
                = "instant" else "🕒 عادي"
            )
        )
        price = order_data.get("price", 0)
        formatted_price = f"{price:,.2f}" if price else "يتم حسابه"

        message = f"""
🎉 <b>طلب جديد تم إرساله بنجاح!</b>

📋 <b>تفاصيل الطلب:</b>
🆔 رقم الطلب: #{order_data.get('id', 'جاري التوليد')}
🎮 المنصة: {platform_text}
💰 الكمية: {formatted_coins} كوين
⚡ نوع التحويل: {transfer_type_text}
💵 السعر المتوقع: {formatted_price} جنيه

📱 طريقة الدفع: {order_data.get('payment_method', 'غير محدد')}
📞 رقم الواتساب: {order_data.get('phone_number', 'غير محدد')}

🕒 وقت الطلب: {datetime.now().strftime('%Y-%m-%d %H:%M')}

سيتم التواصل معك قريباً لإتمام العملية!
شكراً لاختيارك شهد السنيورة! 🚀
        """

        return message.strip()

    def setup_webhook(self) -> bool:
        """إعداد webhook للبوت"""
        if not self.is_configured() or not self.webhook_url:
            self.app.logger.warning("Cannot setup webhook: missing configuration")
            return False

        try:
            url = f"{self.base_url}/setWebhook"
            payload = {
                "url": self.webhook_url,
                "allowed_updates": ["message", "callback_query"],
            }

            response = requests.post(url, json=payload, timeout=10)
            result = response.json()

            if result.get("ok"):
                self.app.logger.info("Webhook setup successfully")
                return True
            else:
                self.app.logger.error(f"Failed to setup webhook: {result}")
                return False

        except Exception as e:
            self.app.logger.error(f"Error setting up webhook: {e}")
            return False

    def process_telegram_update(
        self, update_data: Dict[str, Any]
    ) -> Optional[Dict[str, Any]]:
        """معالجة تحديثات التليجرام الواردة"""
        try:
            if "message" in update_data:
                return self.process_message(update_data["message"])
            elif "callback_query" in update_data:
                return self.process_callback_query(update_data["callback_query"])

            return None

        except Exception as e:
            self.app.logger.error(f"Error processing Telegram update: {e}")
            return None

    def process_message(self, message: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """معالجة الرسائل الواردة"""
        chat_id = str(message["chat"]["id"])
        user_id = str(message["from"]["id"])
        username = message["from"].get("username", "")
        text = message.get("text", "").strip()

        # معالجة أوامر البوت
        if text.startswith("/start"):
            return self.handle_start_command(chat_id, user_id, username, text)
        elif text == "/help":
            return self.handle_help_command(chat_id)
        elif text == "/status":
            return self.handle_status_command(chat_id, user_id)
        else:
            return self.handle_regular_message(chat_id, text)

    def handle_start_command(
        self, chat_id: str, user_id: str, username: str, text: str
    ) -> Dict[str, Any]:
        """معالجة أمر /start"""
        # استخراج معرف المستخدم من الرابط إذا وُجد
        website_user_id = None
        if " " in text:
            try:
                import base64

                encoded_id = text.split(" ")[1]
                website_user_id = base64.b64decode(encoded_id).decode("utf-8")
            except Exception as e:
                pass

        welcome_message = f"""
🎮 <b>مرحباً بك في بوت شهد السنيورة!</b>

أهلاً {username or 'صديقي'}! 👋

🔔 سيقوم هذا البوت بإرسال إشعارات فورية عن:
• الطلبات الجديدة
• تحديثات حالة الطلبات
• العروض الخاصة والتخفيضات

📱 <b>الأوامر المتاحة:</b>
/help - عرض المساعدة
/status - حالة الربط مع حسابك

🔗 لربط حسابك، استخدم زر "ربط التليجرام" في موقعنا.

مرحباً بك في عائلة شهد السنيورة! 🚀
        """

        self.send_message(chat_id, welcome_message.strip())

        return {
            "action": "start",
            "chat_id": chat_id,
            "user_id": user_id,
            "username": username,
            "website_user_id": website_user_id,
        }

    def handle_help_command(self, chat_id: str) -> Dict[str, Any]:
        """معالجة أمر /help"""
        help_message = """
🤖 <b>مساعدة بوت شهد السنيورة</b>

📋 <b>الأوامر المتاحة:</b>
/start - بدء استخدام البوت
/help - عرض هذه المساعدة
/status - فحص حالة الربط

🔔 <b>الإشعارات التلقائية:</b>
• إشعار فوري عند إرسال طلب جديد
• تحديثات حالة الطلب (قيد المعالجة، مكتمل، إلخ)
• تنبيهات العروض الخاصة

🔗 <b>كيفية الربط:</b>
1. سجل دخولك في موقع شهد السنيورة
2. اذهب للملف الشخصي
3. اضغط على "ربط التليجرام"
4. أرسل أي رسالة لهذا البوت

💬 للدعم الفني، تواصل معنا عبر الموقع.
        """

        self.send_message(chat_id, help_message.strip())

        return {"action": "help", "chat_id": chat_id}

    def handle_status_command(self, chat_id: str, user_id: str) -> Dict[str, Any]:
        """معالجة أمر /status"""
        # هنا يمكن فحص حالة الربط مع قاعدة البيانات
        status_message = f"""
📊 <b>حالة حسابك</b>

🆔 معرف التليجرام: <code>{user_id}</code>
💬 معرف المحادثة: <code>{chat_id}</code>

🔗 لربط حسابك مع الموقع:
1. اذهب إلى الملف الشخصي في الموقع
2. اضغط "ربط التليجرام"
3. أرسل أي رسالة هنا

✅ البوت يعمل بشكل طبيعي
        """

        self.send_message(chat_id, status_message.strip())

        return {"action": "status", "chat_id": chat_id, "user_id": user_id}

    def handle_regular_message(self, chat_id: str, text: str) -> Dict[str, Any]:
        """معالجة الرسائل العادية"""
        response_message = """
شكراً لرسالتك! 📝

🔗 إذا لم تقم بربط حسابك بعد:
• اذهب للملف الشخصي في الموقع
• اضغط "ربط التليجرام"
• ستتم المزامنة تلقائياً

💬 للمساعدة: /help
📊 لفحص الحالة: /status

سنتواصل معك قريباً! 🚀
        """

        self.send_message(chat_id, response_message.strip())

        return {"action": "message", "chat_id": chat_id, "text": text}


# إنشاء instance عام
telegram_system = TelegramNotificationSystem()



#!/usr/bin/env python3
"""
نظام الأتمتة الشاملة للبرمجة
يقوم بتنسيق الكود وإصلاح الأخطاء ومزامنة GitHub تلقائياً
"""

import logging
import os
import subprocess
import time
from datetime import datetime
from pathlib import Path

import schedule
from watchdog.events import FileSystemEventHandler
from watchdog.observers import Observer


class UltimateAutoSync:
    def __init__(self, project_path=None):
        self.project_path = project_path or os.getcwd()
        self.setup_logging()
        self.is_syncing = False
        self.pending_changes = False
        self.last_sync = None
        self.sync_stats = {
            "total_syncs": 0,
            "successful_syncs": 0,
            "failed_syncs": 0,
            "code_formats": 0,
            "git_pushes": 0,
        }

    def setup_logging(self):
        """إعداد نظام التسجيل المتقدم"""
        logging.basicConfig(
            level=logging.INFO,
            format="%(asctime)s - %(levelname)s - %(message)s",
            handlers=[
                logging.FileHandler("auto_sync.log", encoding="utf-8"),
                logging.StreamHandler(),
            ],
        )
        self.logger = logging.getLogger(__name__)

    def check_dependencies(self):
        """التحقق من الأدوات المطلوبة"""
        required_tools = ["git", "python"]
        python_packages = ["black", "isort", "flake8", "autopep8"]

        # فحص الأدوات الأساسية
        for tool in required_tools:
            try:
                subprocess.run([tool, "--version"], capture_output = (
                    True, check=True)
                )
                self.logger.info(f"✅ {tool} موجود")
            except (subprocess.CalledProcessError, FileNotFoundError):
                self.logger.error(f"❌ {tool} غير موجود - يجب تثبيته")
                return False

        # فحص حزم Python
        for package in python_packages:
            try:
                subprocess.run(
                    ["python", "-m", package, "--version"],
                    capture_output=True,
                    check=True,
                )
                self.logger.info(f"✅ {package} موجود")
            except (subprocess.CalledProcessError, FileNotFoundError):
                self.logger.warning(f"⚠️  {package} غير موجود - سيتم التخطي")

        return True

    def format_code(self):
        """تنسيق وإصلاح الكود بشكل متقدم"""
        if self.is_syncing:
            return False

        try:
            self.logger.info("🔧 بدء تنسيق الكود...")

            # 1. Black formatter
            try:
                result = subprocess.run(
                    ["python", "-m", "black", ".", "--line-length=88"],
                    capture_output=True,
                    text=True,
                    timeout=120,
                )
                if result.returncode == 0:
                    self.logger.info("✅ تم تنسيق الكود بـ Black")
                    self.sync_stats["code_formats"] += 1
                else:
                    self.logger.warning(f"⚠️  Black warning: {result.stderr}")
            except (subprocess.TimeoutExpired, FileNotFoundError):
                self.logger.warning("⚠️  Black غير متاح")

            # 2. isort للاستيرادات
            try:
                result = subprocess.run(
                    ["python", "-m", "isort", ".", "--profile=black"],
                    capture_output=True,
                    text=True,
                    timeout=60,
                )
                if result.returncode == 0:
                    self.logger.info("✅ تم ترتيب الاستيرادات")
            except (subprocess.TimeoutExpired, FileNotFoundError):
                self.logger.warning("⚠️  isort غير متاح")

            # 3. autopep8 للإصلاحات
            try:
                result = subprocess.run(
                    ["python", "-m", "autopep8", "--in-place", "--recursive", "."],
                    capture_output=True,
                    text=True,
                    timeout=120,
                )
                if result.returncode == 0:
                    self.logger.info("✅ تم إصلاح الأخطاء")
            except (subprocess.TimeoutExpired, FileNotFoundError):
                self.logger.warning("⚠️  autopep8 غير متاح")

            # 4. flake8 للفحص
            try:
                result = subprocess.run(
                    ["python", "-m", "flake8", "."],
                    capture_output=True,
                    text=True,
                    timeout=60,
                )
                if result.returncode == 0:
                    self.logger.info("✅ لا توجد أخطاء في الكود")
                else:
                    self.logger.info(
                        f"📝 تم العثور على تحذيرات: {len(result.stdout.splitlines())} مشكلة"
                    )
            except (subprocess.TimeoutExpired, FileNotFoundError):
                self.logger.warning("⚠️  flake8 غير متاح")

            return True

        except Exception as e:
            self.logger.error(f"❌ خطأ في تنسيق الكود: {e}")
            return False

    def check_git_status(self):
        """فحص حالة Git"""
        try:
            result = subprocess.run(
                ["git", "status", "--porcelain"],
                capture_output=True,
                text=True,
                timeout=30,
            )
            return result.stdout.strip()
        except Exception as e:
            return ""

    def get_git_info(self):
        """الحصول على معلومات Git"""
        try:
            # الحصول على اسم الفرع
            branch = subprocess.run(
                ["git", "rev-parse", "--abbrev-ref", "HEAD"],
                capture_output=True,
                text=True,
                timeout=10,
            )
            current_branch = (
                branch.stdout.strip() if branch.returncode == 0 else "main"
            )

            # الحصول على Remote URL
            remote = subprocess.run(
                ["git", "config", "--get", "remote.origin.url"],
                capture_output=True,
                text=True,
                timeout=10,
            )
            remote_url = (
                remote.stdout.strip() if remote.returncode == 0 else "غير متاح"
            )

            return current_branch, remote_url
        except Exception as e:
            return "main", "غير متاح"

    def git_sync(self):
        """مزامنة كاملة مع Git"""
        if self.is_syncing:
            return False

        try:
            self.logger.info("🔄 بدء مزامنة Git...")
            current_branch, remote_url = self.get_git_info()

            # 1. جلب التحديثات
            try:
                subprocess.run(["git", "fetch", "origin"], check = (
                    True, timeout=60)
                )
                self.logger.info("📥 تم جلب التحديثات من GitHub")
            except subprocess.CalledProcessError:
                self.logger.warning("⚠️  لم يتم جلب التحديثات")

            # 2. دمج التحديثات إذا كانت موجودة
            try:
                result = subprocess.run(
                    ["git", "rev-list", "--count", f"HEAD..origin/{current_branch}"],
                    capture_output=True,
                    text=True,
                    timeout=30,
                )
                if result.returncode == 0 and result.stdout.strip() != "0":
                    subprocess.run(
                        ["git", "pull", "origin", current_branch],
                        check=True,
                        timeout=60,
                    )
                    self.logger.info("📥 تم دمج التحديثات")
            except Exception as e:
                pass

            # 3. إضافة التغييرات ورفعها
            if self.check_git_status():
                subprocess.run(["git", "add", "."], check=True, timeout=30)

                # إنشاء رسالة commit ذكية
                timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                commit_msg = f"🤖 Auto-sync: {timestamp}"

                # إضافة إحصائيات
                stats_msg = (
                    f" | Syncs: {self.sync_stats['total_syncs']}, Formats: {self.sync_stats['code_formats']}"
                )
                full_msg = commit_msg + stats_msg

                subprocess.run(
                    ["git", "commit", "-m", full_msg], check=True, timeout=30
                )
                subprocess.run(
                    ["git", "push", "origin", current_branch], check = (
                        True, timeout=90
                    )
                )

                self.logger.info(f"✅ تم رفع التحديثات إلى {current_branch}")
                self.sync_stats["git_pushes"] += 1
                return True
            else:
                self.logger.debug("📝 لا توجد تغييرات للرفع")
                return False

        except subprocess.CalledProcessError as e:
            self.logger.error(f"❌ خطأ في مزامنة Git: {e}")
            self.sync_stats["failed_syncs"] += 1
            return False
        except Exception as e:
            self.logger.error(f"❌ خطأ عام في Git: {e}")
            return False

    def full_sync_cycle(self):
        """دورة المزامنة الكاملة"""
        if self.is_syncing:
            self.logger.debug("⏸️  المزامنة جارية بالفعل")
            return

        self.is_syncing = True
        self.sync_stats["total_syncs"] += 1

        try:
            self.logger.info("🚀 بدء دورة المزامنة الكاملة")
            start_time = time.time()

            # 1. تنسيق الكود
            code_formatted = self.format_code()

            # 2. مزامنة Git
            git_synced = self.git_sync()

            # 3. تحديث الإحصائيات
            if code_formatted or git_synced:
                self.sync_stats["successful_syncs"] += 1
                self.pending_changes = False
                self.last_sync = datetime.now()

            duration = time.time() - start_time
            self.logger.info(f"✨ انتهت دورة المزامنة في {duration:.2f} ثانية")

        except Exception as e:
            self.logger.error(f"❌ خطأ في دورة المزامنة: {e}")
            self.sync_stats["failed_syncs"] += 1
        finally:
            self.is_syncing = False

    def start_file_watcher(self):
        """مراقب تغييرات الملفات المتقدم"""

        class SmartFileHandler(FileSystemEventHandler):
            def __init__(self, sync_instance):
                self.sync_instance = sync_instance
                self.last_event_time = {}

            def on_modified(self, event):
                if event.is_directory:
                    return

                # تجاهل الملفات غير المهمة
                ignored_extensions = [
                    ".log",
                    ".tmp",
                    ".pyc",
                    ".pyo",
                    ".pyd",
                    "__pycache__",
                ]
                if any(event.src_path.endswith(ext) for ext in ignored_extensions):
                    return

                # تجاهل الأحداث المكررة
                now = time.time()
                if event.src_path in self.last_event_time:
                    if now - self.last_event_time[event.src_path] < 2:
                        return

                self.last_event_time[event.src_path] = now

                # فقط ملفات Python والملفات المهمة
                if event.src_path.endswith(
                    (".py", ".md", ".txt", ".yml", ".yaml", ".json")
                ):
                    self.sync_instance.pending_changes = True
                    self.sync_instance.logger.debug(
                        f"📝 تم تعديل: {os.path.basename(event.src_path)}"
                    )

        event_handler = SmartFileHandler(self)
        observer = Observer()
        observer.schedule(event_handler, self.project_path, recursive=True)
        observer.start()
        self.logger.info("👀 تم بدء مراقب الملفات الذكي")
        return observer

    def print_stats(self):
        """طباعة الإحصائيات"""
        stats_text = f"""
📊 إحصائيات الأتمتة:
├── إجمالي المزامنات: {self.sync_stats['total_syncs']}
├── مزامنات ناجحة: {self.sync_stats['successful_syncs']}
├── مزامنات فاشلة: {self.sync_stats['failed_syncs']}
├── تنسيقات الكود: {self.sync_stats['code_formats']}
├── رفع Git: {self.sync_stats['git_pushes']}
└── آخر مزامنة: {self.last_sync.strftime('%Y-%m-%d %H:%M:%S') if self.last_sync else 'لم تحدث بعد'}
"""
        self.logger.info(stats_text)

    def start_scheduler(self):
        """بدء جدولة المهام الذكية"""
        # مزامنة كل 45 ثانية
        schedule.every(45).seconds.do(self.full_sync_cycle)

        # مزامنة عند وجود تغييرات معلقة
        def sync_if_pending():
            if self.pending_changes and not self.is_syncing:
                self.full_sync_cycle()

        schedule.every(15).seconds.do(sync_if_pending)

        # طباعة الإحصائيات كل 5 دقائق
        schedule.every(5).minutes.do(self.print_stats)

        self.logger.info("⏰ تم بدء الجدولة الذكية")

    def run(self):
        """تشغيل النظام الكامل"""
        self.logger.info("🚀 بدء نظام الأتمتة الشاملة")

        # فحص المتطلبات
        if not self.check_dependencies():
            self.logger.error("❌ بعض المتطلبات غير متوفرة")
            return

        # معلومات النظام
        current_branch, remote_url = self.get_git_info()
        self.logger.info(f"📂 المشروع: {os.path.basename(self.project_path)}")
        self.logger.info(f"🌿 الفرع: {current_branch}")
        self.logger.info(f"🔗 المستودع: {remote_url}")

        # بدء مراقب الملفات
        observer = self.start_file_watcher()

        # بدء الجدولة
        self.start_scheduler()

        # تشغيل المزامنة الأولى
        self.full_sync_cycle()

        self.logger.info("🎯 النظام جاهز! اضغط Ctrl+C للإيقاف")

        try:
            while True:
                schedule.run_pending()
                time.sleep(1)
        except KeyboardInterrupt:
            self.logger.info("⏹️  تم إيقاف النظام بواسطة المستخدم")
            self.print_stats()
        finally:
            observer.stop()
            observer.join()
            self.logger.info("👋 وداعاً!")



import subprocess
import sys


def run_formatter_and_linter():
    print("🔧 تشغيل أدوات التنسيق والفحص...")

    # Run Black
    try:
        print("Running Black...")
        subprocess.run(
            [sys.executable, "-m", "black", "."],
            check=True,
            capture_output=True,
            text=True,
        )
        print("✅ Black finished.")
    except subprocess.CalledProcessError as e:
        print(f"❌ Black failed: {e.stderr}")
    except FileNotFoundError:
        print("⚠️ Black not found. Please install it: pip install black")

    # Run isort
    try:
        print("Running isort...")
        subprocess.run(
            [sys.executable, "-m", "isort", "."],
            check=True,
            capture_output=True,
            text=True,
        )
        print("✅ isort finished.")
    except subprocess.CalledProcessError as e:
        print(f"❌ isort failed: {e.stderr}")
    except FileNotFoundError:
        print("⚠️ isort not found. Please install it: pip install isort")

    # Run flake8
    try:
        print("Running flake8...")
        result = subprocess.run(
            [
                "python",
                "-m",
                "flake8",
                ".",
                "--exclude=venv,docs,tests,venv/Lib/site-packages",
            ],  # تم التعديل هنا
            capture_output=True,
            text=True,
        )
        if result.stdout:
            print("⚠️ Flake8 found issues:")
            print(result.stdout)
        else:
            print("✅ Flake8 found no issues.")
    except FileNotFoundError:
        print("⚠️ flake8 not found. Please install it: pip install flake8")


if __name__ == "__main__":
    run_formatter_and_linter()



#!/usr/bin/env python3
"""
الحل النهائي والشامل لجميع أخطاء flake8
يصلح كل شيء في دقائق!
"""

import os
import re
import subprocess
import sys
from pathlib import Path


class FlakeFixer:
    def __init__(self):
        self.fixed_files = []
        self.errors_fixed = 0

    def run_black_and_isort(self):
        """تشغيل Black و isort أولاً"""
        print("🔧 تشغيل Black و isort...")

        try:
            subprocess.run(
                [sys.executable, "-m", "black", "."], check=True, capture_output=True
            )
            print("✅ Black تم بنجاح")
        except:
            print("❌ Black فشل - استكمال بدونه")

        try:
            subprocess.run(
                [sys.executable, "-m", "isort", "."], check=True, capture_output=True
            )
            print("✅ isort تم بنجاح")
        except:
            print("❌ isort فشل - استكمال بدونه")

    def fix_app_py(self):
        """إصلاح شامل لملف app.py"""
        file_path = "app.py"
        if not os.path.exists(file_path):
            return

        print(f"🔧 إصلاح {file_path}...")

        with open(file_path, "r", encoding="utf-8") as f:
            content = f.read()

        original_content = content

        # 1. حذف imports غير مستخدمة
        imports_to_remove = [
            r"^from flask import.*g.*\n",
            r"^from models import.*AppSetting.*\n",
            r"^from werkzeug\.security import check_password_hash\n",
            r"^from werkzeug\.utils import secure_filename\n",
        ]

        for pattern in imports_to_remove:
            content = re.sub(pattern, "", content, flags=re.MULTILINE)

        # 2. إصلاح error_handler غير مستخدم
        content = re.sub(
            r"\s*error_handler = init_error_handlers\(app\)",
            "    init_error_handlers(app)",
            content,
        )

        # 3. إصلاح مقارنات False
        content = content.replace(
            "if not user.is_verified == False:", "if user.is_verified:"
        )
        content = content.replace(
            "Message.is_deleted == False", "Message.is_deleted is False"
        )

        # 4. إصلاح الخطوط الطويلة الأساسية
        long_lines_fixes = {
            # Flash messages
            r'flash\("تم إرسال رمز التفعيل إلى بريدك الإلكتروني\. يرجى فحص صندوق الوارد\."[^\n]*\)': 'flash(\n            "تم إرسال رمز التفعيل إلى بريدك الإلكتروني. "\n            "يرجى فحص صندوق الوارد.", "info"\n        )',
            r'flash\("رمز التفعيل غير صحيح أو منتهي الصلاحية\. يرجى المحاولة مرة أخرى\."[^\n]*\)': 'flash(\n            "رمز التفعيل غير صحيح أو منتهي الصلاحية. "\n            "يرجى المحاولة مرة أخرى.", "error"\n        )',
            r'flash\("حدث خطأ أثناء إرسال الرسالة\. يرجى المحاولة مرة أخرى\."[^\n]*\)': 'flash(\n            "حدث خطأ أثناء إرسال الرسالة. "\n            "يرجى المحاولة مرة أخرى.", "error"\n        )',
        }

        for pattern, replacement in long_lines_fixes.items():
            content = re.sub(pattern, replacement, content)

        # 5. تقسيم الأسطر الطويلة العامة
        lines = content.split("\n")
        fixed_lines = []

        for line in lines:
            if len(line) > 79 and ('"' in line or "'" in line):
                # تقسيم الأسطر الطويلة
                if "flash(" in line and len(line) > 79:
                    # إصلاح خاص لـ flash
                    indent = len(line) - len(line.lstrip())
                    if '"' in line:
                        parts = line.split('"')
                        if len(parts) >= 3:
                            fixed_line = f"{' ' * indent}flash(\n{' ' * (indent + 4)}\"{parts[1]}\",\n{' ' * (indent + 4)}\"{parts[3] if len(parts) > 3 else 'info'}\"\n{' ' * indent})"
                            fixed_lines.append(fixed_line)
                            continue
                elif "user.code_expiry = datetime.utcnow() + timedelta" in line:
                    # إصلاح خاص للتاريخ
                    indent = len(line) - len(line.lstrip())
                    fixed_lines.append(
                        f"{' ' * indent}user.code_expiry = (\n{' ' * (indent + 4)}datetime.utcnow() + timedelta(minutes=15)\n{' ' * indent})"
                    )
                    continue

            fixed_lines.append(line)

        content = "\n".join(fixed_lines)

        if content != original_content:
            with open(file_path, "w", encoding="utf-8") as f:
                f.write(content)
            self.fixed_files.append(file_path)
            print(f"✅ تم إصلاح {file_path}")

    def fix_telegram_bot_py(self):
        """إصلاح ملف telegram_bot.py"""
        file_path = "telegram_bot.py"
        if not os.path.exists(file_path):
            return

        print(f"🔧 إصلاح {file_path}...")

        with open(file_path, "r", encoding="utf-8") as f:
            content = f.read()

        # حذف imports غير مستخدمة
        imports_to_remove = [
            r"^import json\n",
            r"^import logging\n",
            r"^from flask import current_app\n",
        ]

        for pattern in imports_to_remove:
            content = re.sub(pattern, "", content, flags=re.MULTILINE)

        # إصلاح except عارية
        content = re.sub(r"except:\s*\n", "except Exception as e:\n", content)

        # حذف trailing whitespace
        content = re.sub(r"[ \t]+$", "", content, flags=re.MULTILINE)

        # تقسيم الأسطر الطويلة
        lines = content.split("\n")
        fixed_lines = []

        for line in lines:
            if len(line) > 79:
                # تقسيم بسيط للأسطر الطويلة
                if '"' in line and "=" in line:
                    parts = line.split("=", 1)
                    if len(parts) == 2:
                        indent = len(parts[0]) - len(parts[0].lstrip())
                        fixed_lines.append(f"{parts[0].rstrip()} = (")
                        fixed_lines.append(f"{' ' * (indent + 4)}{parts[1].strip()}")
                        fixed_lines.append(f"{' ' * indent})")
                        continue

            fixed_lines.append(line)

        content = "\n".join(fixed_lines)

        with open(file_path, "w", encoding="utf-8") as f:
            f.write(content)
        self.fixed_files.append(file_path)
        print(f"✅ تم إصلاح {file_path}")

    def fix_other_files(self):
        """إصلاح الملفات الأخرى"""
        files_to_fix = {
            "analyze.py": {"remove_vars": ['command_target = "."'], "fix_lines": True},
            "ultimate_auto_sync.py": {
                "remove_imports": ["json", "threading", "pathlib.Path", "psutil"],
                "fix_except": True,
                "fix_lines": True,
            },
            "quick_start.py": {"remove_imports": ["os"], "fix_except": True},
            "service_runner.py": {"fix_except": True},
            "fix_flake8.py": {"remove_imports": ["os"]},
            "test_profile.py": {"fix_lines": True},
        }

        for filename, fixes in files_to_fix.items():
            if not os.path.exists(filename):
                continue

            print(f"🔧 إصلاح {filename}...")

            with open(filename, "r", encoding="utf-8") as f:
                content = f.read()

            original_content = content

            # حذف imports
            if "remove_imports" in fixes:
                for imp in fixes["remove_imports"]:
                    patterns = [f"^import {imp}\n", f"^from {imp} import.*\n"]
                    for pattern in patterns:
                        content = re.sub(pattern, "", content, flags=re.MULTILINE)

            # حذف متغيرات
            if "remove_vars" in fixes:
                for var in fixes["remove_vars"]:
                    content = re.sub(
                        f"^.*{re.escape(var)}.*\n", "", content, flags=re.MULTILINE
                    )

            # إصلاح except
            if fixes.get("fix_except"):
                content = re.sub(r"except:\s*\n", "except Exception as e:\n", content)

            # إصلاح الأسطر الطويلة
            if fixes.get("fix_lines"):
                lines = content.split("\n")
                fixed_lines = []

                for line in lines:
                    if len(line) > 79:
                        # تقسيم بسيط
                        if "=" in line and ('"' in line or "'" in line):
                            indent = len(line) - len(line.lstrip())
                            if indent < 60:  # تجنب التداخل المفرط
                                parts = line.split("=", 1)
                                if len(parts) == 2:
                                    fixed_lines.append(f"{parts[0].rstrip()} = (")
                                    fixed_lines.append(
                                        f"{' ' * (indent + 4)}{parts[1].strip()}"
                                    )
                                    fixed_lines.append(f"{' ' * indent})")
                                    continue

                    fixed_lines.append(line)

                content = "\n".join(fixed_lines)

            if content != original_content:
                with open(filename, "w", encoding="utf-8") as f:
                    f.write(content)
                self.fixed_files.append(filename)
                print(f"✅ تم إصلاح {filename}")

    def check_flake8(self):
        """فحص النتائج مع flake8"""
        print("\n🔍 فحص النتائج مع flake8...")

        try:
            result = subprocess.run(
                [
                    "python",
                    "-m",
                    "flake8",
                    ".",
                    "--exclude=venv,docs,tests,node_modules,dist",
                ],
                capture_output=True,
                text=True,
            )

            if result.stdout.strip():
                print("⚠️ لا تزال هناك مشاكل:")
                print(result.stdout)
                return False
            else:
                print("✅ تم إصلاح جميع مشاكل flake8!")
                return True

        except FileNotFoundError:
            print("❌ flake8 غير مثبت")
            return False

    def run_fix(self):
        """تشغيل الإصلاح الكامل"""
        print("🚀 بدء الإصلاح الشامل لجميع أخطاء flake8...")
        print("=" * 60)

        # 1. تشغيل Black و isort
        self.run_black_and_isort()

        # 2. إصلاح الملفات الرئيسية
        self.fix_app_py()
        self.fix_telegram_bot_py()
        self.fix_other_files()

        # 3. فحص النتائج
        success = self.check_flake8()

        # 4. تقرير النتائج
        print("\n" + "=" * 60)
        print("📊 تقرير الإصلاح:")
        print(f"✅ تم إصلاح {len(self.fixed_files)} ملف")

        if self.fixed_files:
            print("📁 الملفات المُصلحة:")
            for file in self.fixed_files:
                print(f"   - {file}")

        if success:
            print("\n🎉 تم إصلاح جميع مشاكل flake8 بنجاح!")
            print("\n📝 الخطوات التالية:")
            print("1. git add .")
            print("2. git commit -m 'Fix all flake8 issues'")
            print("3. git push origin main")
        else:
            print("\n⚠️ قد تحتاج لإصلاحات يدوية إضافية")

        return success


if __name__ == "__main__":
    fixer = FlakeFixer()
    fixer.run_fix()



# التشغيل الرئيسي
if __name__ == "__main__":
    # إنشاء النظام وتشغيله
    auto_sync = UltimateAutoSync()
    auto_sync.run()
