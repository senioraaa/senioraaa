(venv) PS C:\Users\pc\Downloads\senioraaa-main> python -m flake8 . --exclude=venv,docs,tests,venv/Lib/site-pac










                                                python -m flake8 . --exclude=venv,docs,tests,venv/Lib/site-packages
.\app.py:10:1: F401 'error_handlers.init_error_handlers' imported but unused
.\app.py:15:1: F401 'flask.g' imported but unused
.\app.py:33:1: F401 'models.AppSetting' imported but unused
.\app.py:383:80: E501 line too long (108 > 79 characters)
.\app.py:521:80: E501 line too long (108 > 79 characters)
.\app.py:614:80: E501 line too long (80 > 79 characters)
.\fix_all_issues.py:23:80: E501 line too long (91 > 79 characters)
.\fix_all_issues.py:143:5: E722 do not use bare 'except'
.\fix_all_issues.py:152:5: E722 do not use bare 'except'
.\quick_start.py:34:5: F841 local variable 'e' is assigned to but never used
.\service_runner.py:61:9: F841 local variable 'e' is assigned to but never used
.\telegram_bot.py:235:13: F841 local variable 'e' is assigned to but never used
.\test_profile.py:34:80: E501 line too long (91 > 79 characters)
.\ultimate_auto_sync.py:54:1: E999 IndentationError: expected an indented block after 'try' statement on line 53
.\ultimate_flake8_fixer.py:11:1: F401 'pathlib.Path' imported but unused
.\ultimate_flake8_fixer.py:30:9: E722 do not use bare 'except'
.\ultimate_flake8_fixer.py:40:9: E722 do not use bare 'except'
.\ultimate_flake8_fixer.py:85:80: E501 line too long (226 > 79 characters)
.\ultimate_flake8_fixer.py:86:80: E501 line too long (223 > 79 characters)
.\ultimate_flake8_fixer.py:87:80: E501 line too long (201 > 79 characters)
.\ultimate_flake8_fixer.py:106:80: E501 line too long (184 > 79 characters)
.\ultimate_flake8_fixer.py:115:80: E501 line too long (141 > 79 characters)
.\ultimate_flake8_fixer.py:259:80: E501 line too long (81 > 79 characters)
(venv) PS C:\Users\pc\Downloads\senioraaa-main> 


#!/usr/bin/env python3
"""
Ù†Ø¸Ø§Ù… Ø§Ù„Ø£ØªÙ…ØªØ© Ø§Ù„Ø´Ø§Ù…Ù„Ø© Ù„Ù„Ø¨Ø±Ù…Ø¬Ø©
ÙŠÙ‚ÙˆÙ… Ø¨ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ÙƒÙˆØ¯ ÙˆØ¥ØµÙ„Ø§Ø­ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ ÙˆÙ…Ø²Ø§Ù…Ù†Ø© GitHub ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
"""

import logging
import os
import subprocess
import time
from datetime import datetime
from pathlib import Path

import schedule
from watchdog.events import FileSystemEventHandler
from watchdog.observers import Observer


class UltimateAutoSync:
    def __init__(self, project_path=None):
        self.project_path = project_path or os.getcwd()
        self.setup_logging()
        self.is_syncing = False
        self.pending_changes = False
        self.last_sync = None
        self.sync_stats = {
            "total_syncs": 0,
            "successful_syncs": 0,
            "failed_syncs": 0,
            "code_formats": 0,
            "git_pushes": 0,
        }

    def setup_logging(self):
        """Ø¥Ø¹Ø¯Ø§Ø¯ Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…"""
        logging.basicConfig(
            level=logging.INFO,
            format="%(asctime)s - %(levelname)s - %(message)s",
            handlers=[
                logging.FileHandler("auto_sync.log", encoding="utf-8"),
                logging.StreamHandler(),
            ],
        )
        self.logger = logging.getLogger(__name__)

    def check_dependencies(self):
        """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©"""
        required_tools = ["git", "python"]
        python_packages = ["black", "isort", "flake8", "autopep8"]

        # ÙØ­Øµ Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
        for tool in required_tools:
            try:
subprocess.run([tool, "--version"], capture_output=capture_output, check=True) # type: ignoreself.logger.info(f"âœ… {tool} Ù…ÙˆØ¬ÙˆØ¯")
            except (subprocess.CalledProcessError, FileNotFoundError):
                self.logger.error(f"âŒ {tool} ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ - ÙŠØ¬Ø¨ ØªØ«Ø¨ÙŠØªÙ‡")
                return False

        # ÙØ­Øµ Ø­Ø²Ù… Python
        for package in python_packages:
            try:
                subprocess.run(
                    ["python", "-m", package, "--version"],
                    capture_output=True,
                    check=True,
                )
                self.logger.info(f"âœ… {package} Ù…ÙˆØ¬ÙˆØ¯")
            except (subprocess.CalledProcessError, FileNotFoundError):
                self.logger.warning(f"âš ï¸  {package} ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ - Ø³ÙŠØªÙ… Ø§Ù„ØªØ®Ø·ÙŠ")

        return True

    def format_code(self):
        """ØªÙ†Ø³ÙŠÙ‚ ÙˆØ¥ØµÙ„Ø§Ø­ Ø§Ù„ÙƒÙˆØ¯ Ø¨Ø´ÙƒÙ„ Ù…ØªÙ‚Ø¯Ù…"""
        if self.is_syncing:
            return False

        try:
            self.logger.info("ğŸ”§ Ø¨Ø¯Ø¡ ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ÙƒÙˆØ¯...")

            # 1. Black formatter
            try:
                result = subprocess.run(
                    ["python", "-m", "black", ".", "--line-length=88"],
                    capture_output=True,
                    text=True,
                    timeout=120,
                )
                if result.returncode == 0:
                    self.logger.info("âœ… ØªÙ… ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ÙƒÙˆØ¯ Ø¨Ù€ Black")
                    self.sync_stats["code_formats"] += 1
                else:
                    self.logger.warning(f"âš ï¸  Black warning: {result.stderr}")
            except (subprocess.TimeoutExpired, FileNotFoundError):
                self.logger.warning("âš ï¸  Black ØºÙŠØ± Ù…ØªØ§Ø­")

            # 2. isort Ù„Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯Ø§Øª
            try:
                result = subprocess.run(
                    ["python", "-m", "isort", ".", "--profile=black"],
                    capture_output=True,
                    text=True,
                    timeout=60,
                )
                if result.returncode == 0:
                    self.logger.info("âœ… ØªÙ… ØªØ±ØªÙŠØ¨ Ø§Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯Ø§Øª")
            except (subprocess.TimeoutExpired, FileNotFoundError):
                self.logger.warning("âš ï¸  isort ØºÙŠØ± Ù…ØªØ§Ø­")

            # 3. autopep8 Ù„Ù„Ø¥ØµÙ„Ø§Ø­Ø§Øª
            try:
                result = subprocess.run(
                    ["python", "-m", "autopep8", "--in-place", "--recursive", "."],
                    capture_output=True,
                    text=True,
                    timeout=120,
                )
                if result.returncode == 0:
                    self.logger.info("âœ… ØªÙ… Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡")
            except (subprocess.TimeoutExpired, FileNotFoundError):
                self.logger.warning("âš ï¸  autopep8 ØºÙŠØ± Ù…ØªØ§Ø­")

            # 4. flake8 Ù„Ù„ÙØ­Øµ
            try:
                result = subprocess.run(
                    ["python", "-m", "flake8", "."],
                    capture_output=True,
                    text=True,
                    timeout=60,
                )
                if result.returncode == 0:
                    self.logger.info("âœ… Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ø®Ø·Ø§Ø¡ ÙÙŠ Ø§Ù„ÙƒÙˆØ¯")
                else:
                    self.logger.info(
                        f"ğŸ“ ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ØªØ­Ø°ÙŠØ±Ø§Øª: {len(result.stdout.splitlines())} Ù…Ø´ÙƒÙ„Ø©"
                    )
            except (subprocess.TimeoutExpired, FileNotFoundError):
                self.logger.warning("âš ï¸  flake8 ØºÙŠØ± Ù…ØªØ§Ø­")

            return True

        except Exception as e:
            self.logger.error(f"âŒ Ø®Ø·Ø£ ÙÙŠ ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ÙƒÙˆØ¯: {e}")
            return False

    def check_git_status(self):
        """ÙØ­Øµ Ø­Ø§Ù„Ø© Git"""
        try:
            result = subprocess.run(
                ["git", "status", "--porcelain"],
                capture_output=True,
                text=True,
                timeout=30,
            )
            return result.stdout.strip()
        except Exception:  # ØªÙ… Ø¥Ø²Ø§Ù„Ø© 'as e' Ù„Ø£Ù† Ø§Ù„Ù…ØªØºÙŠØ± Ù„Ù… ÙŠØ³ØªØ®Ø¯Ù…
            return ""

    def get_git_info(self):
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Git"""
        try:
            # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ø³Ù… Ø§Ù„ÙØ±Ø¹
            branch = subprocess.run(
                ["git", "rev-parse", "--abbrev-ref", "HEAD"],
                capture_output=True,
                text=True,
                timeout=10,
            )
            current_branch = branch.stdout.strip() if branch.returncode == 0 else "main"

            # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Remote URL
            remote = subprocess.run(
                ["git", "config", "--get", "remote.origin.url"],
                capture_output=True,
                text=True,
                timeout=10,
            )
            remote_url = remote.stdout.strip() if remote.returncode == 0 else "ØºÙŠØ± Ù…ØªØ§Ø­"

            return current_branch, remote_url
        except Exception:  # ØªÙ… Ø¥Ø²Ø§Ù„Ø© 'as e' Ù„Ø£Ù† Ø§Ù„Ù…ØªØºÙŠØ± Ù„Ù… ÙŠØ³ØªØ®Ø¯Ù…
            return "main", "ØºÙŠØ± Ù…ØªØ§Ø­"

    def git_sync(self):
        """Ù…Ø²Ø§Ù…Ù†Ø© ÙƒØ§Ù…Ù„Ø© Ù…Ø¹ Git"""
        if self.is_syncing:
            return False

        try:
            self.logger.info("ğŸ”„ Ø¨Ø¯Ø¡ Ù…Ø²Ø§Ù…Ù†Ø© Git...")
            current_branch, remote_url = self.get_git_info()

            # 1. Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª
            try:
                subprocess.run(
                    ["git", "fetch", "origin"], check=True, timeout=60
                )  # ØªÙ… Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ù‚ÙˆØ³ Ø§Ù„Ø²Ø§Ø¦Ø¯
                self.logger.info("ğŸ“¥ ØªÙ… Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª Ù…Ù† GitHub")
            except subprocess.CalledProcessError:
                self.logger.warning("âš ï¸  Ù„Ù… ÙŠØªÙ… Ø¬Ù„Ø¨ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª")

            # 2. Ø¯Ù…Ø¬ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…ÙˆØ¬ÙˆØ¯Ø©
            try:
                result = subprocess.run(
                    ["git", "rev-list", "--count", f"HEAD..origin/{current_branch}"],
                    capture_output=True,
                    text=True,
                    timeout=30,
                )
                if result.returncode == 0 and result.stdout.strip() != "0":
                    subprocess.run(
                        ["git", "pull", "origin", current_branch],
                        check=True,
                        timeout=60,
                    )
                    self.logger.info("ğŸ“¥ ØªÙ… Ø¯Ù…Ø¬ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª")
            except Exception:  # ØªÙ… Ø¥Ø²Ø§Ù„Ø© 'as e' Ù„Ø£Ù† Ø§Ù„Ù…ØªØºÙŠØ± Ù„Ù… ÙŠØ³ØªØ®Ø¯Ù…
                pass

            # 3. Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª ÙˆØ±ÙØ¹Ù‡Ø§
            if self.check_git_status():
                subprocess.run(["git", "add", "."], check=True, timeout=30)

                # Ø¥Ù†Ø´Ø§Ø¡ Ø±Ø³Ø§Ù„Ø© commit Ø°ÙƒÙŠØ©
                timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                commit_msg = f"ğŸ¤– Auto-sync: {timestamp}"

                # Ø¥Ø¶Ø§ÙØ© Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
                stats_msg = f" | Syncs: {self.sync_stats['total_syncs']}, Formats: {self.sync_stats['code_formats']}"
                full_msg = commit_msg + stats_msg

                subprocess.run(
                    ["git", "commit", "-m", full_msg], check=True, timeout=30
                )
                subprocess.run(
                    ["git", "push", "origin", current_branch], check=True, timeout=90
                )  # ØªÙ… Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ù‚ÙˆØ³ Ø§Ù„Ø²Ø§Ø¦Ø¯

                self.logger.info(f"âœ… ØªÙ… Ø±ÙØ¹ Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª Ø¥Ù„Ù‰ {current_branch}")
                self.sync_stats["git_pushes"] += 1
                return True
            else:
                self.logger.debug("ğŸ“ Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØºÙŠÙŠØ±Ø§Øª Ù„Ù„Ø±ÙØ¹")
                return False

        except subprocess.CalledProcessError as e:
            self.logger.error(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ù…Ø²Ø§Ù…Ù†Ø© Git: {e}")
            self.sync_stats["failed_syncs"] += 1
            return False
        except Exception as e:
            self.logger.error(f"âŒ Ø®Ø·Ø£ Ø¹Ø§Ù… ÙÙŠ Git: {e}")
            return False

    def full_sync_cycle(self):
        """Ø¯ÙˆØ±Ø© Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø©"""
        if self.is_syncing:
            self.logger.debug("â¸ï¸  Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© Ø¬Ø§Ø±ÙŠØ© Ø¨Ø§Ù„ÙØ¹Ù„")
            return

        self.is_syncing = True
        self.sync_stats["total_syncs"] += 1

        try:
            self.logger.info("ğŸš€ Ø¨Ø¯Ø¡ Ø¯ÙˆØ±Ø© Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø©")
            start_time = time.time()

            # 1. ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ÙƒÙˆØ¯
            code_formatted = self.format_code()

            # 2. Ù…Ø²Ø§Ù…Ù†Ø© Git
            git_synced = self.git_sync()

            # 3. ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
            if code_formatted or git_synced:
                self.sync_stats["successful_syncs"] += 1
                self.pending_changes = False
                self.last_sync = datetime.now()

            duration = time.time() - start_time
            self.logger.info(f"âœ¨ Ø§Ù†ØªÙ‡Øª Ø¯ÙˆØ±Ø© Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© ÙÙŠ {duration:.2f} Ø«Ø§Ù†ÙŠØ©")

        except Exception as e:
            self.logger.error(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø¯ÙˆØ±Ø© Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø©: {e}")
            self.sync_stats["failed_syncs"] += 1
        finally:
            self.is_syncing = False

    def start_file_watcher(self):
        """Ù…Ø±Ø§Ù‚Ø¨ ØªØºÙŠÙŠØ±Ø§Øª Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…"""

        class SmartFileHandler(FileSystemEventHandler):
            def __init__(self, sync_instance):
                self.sync_instance = sync_instance
                self.last_event_time = {}

            def on_modified(self, event):
                if event.is_directory:
                    return

                # ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª ØºÙŠØ± Ø§Ù„Ù…Ù‡Ù…Ø©
                ignored_extensions = [
                    ".log",
                    ".tmp",
                    ".pyc",
                    ".pyo",
                    ".pyd",
                    "__pycache__",
                ]
                if any(event.src_path.endswith(ext) for ext in ignored_extensions):
                    return

                # ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ù…ÙƒØ±Ø±Ø©
                now = time.time()
                if event.src_path in self.last_event_time:
                    if now - self.last_event_time[event.src_path] < 2:
                        return

                self.last_event_time[event.src_path] = now

                # ÙÙ‚Ø· Ù…Ù„ÙØ§Øª Python ÙˆØ§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ù‡Ù…Ø©
                if event.src_path.endswith(
                    (".py", ".md", ".txt", ".yml", ".yaml", ".json")
                ):
                    self.sync_instance.pending_changes = True
                    self.sync_instance.logger.debug(
                        f"ğŸ“ ØªÙ… ØªØ¹Ø¯ÙŠÙ„: {os.path.basename(event.src_path)}"
                    )

        event_handler = SmartFileHandler(self)
        observer = Observer()
        observer.schedule(event_handler, self.project_path, recursive=True)
        observer.start()
        self.logger.info("ğŸ‘€ ØªÙ… Ø¨Ø¯Ø¡ Ù…Ø±Ø§Ù‚Ø¨ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø°ÙƒÙŠ")
        return observer

    def print_stats(self):
        """Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª"""
        stats_text = f"""
ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø£ØªÙ…ØªØ©:
â”œâ”€â”€ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø§Øª: {self.sync_stats['total_syncs']}
â”œâ”€â”€ Ù…Ø²Ø§Ù…Ù†Ø§Øª Ù†Ø§Ø¬Ø­Ø©: {self.sync_stats['successful_syncs']}
â”œâ”€â”€ Ù…Ø²Ø§Ù…Ù†Ø§Øª ÙØ§Ø´Ù„Ø©: {self.sync_stats['failed_syncs']}
â”œâ”€â”€ ØªÙ†Ø³ÙŠÙ‚Ø§Øª Ø§Ù„ÙƒÙˆØ¯: {self.sync_stats['code_formats']}
â”œâ”€â”€ Ø±ÙØ¹ Git: {self.sync_stats['git_pushes']}
â””â”€â”€ Ø¢Ø®Ø± Ù…Ø²Ø§Ù…Ù†Ø©: {self.last_sync.strftime('%Y-%m-%d %H:%M:%S') if self.last_sync else 'Ù„Ù… ØªØ­Ø¯Ø« Ø¨Ø¹Ø¯'}
"""
        self.logger.info(stats_text)

    def start_scheduler(self):
        """Ø¨Ø¯Ø¡ Ø¬Ø¯ÙˆÙ„Ø© Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ø°ÙƒÙŠØ©"""
        # Ù…Ø²Ø§Ù…Ù†Ø© ÙƒÙ„ 45 Ø«Ø§Ù†ÙŠØ©
        schedule.every(45).seconds.do(self.full_sync_cycle)

        # Ù…Ø²Ø§Ù…Ù†Ø© Ø¹Ù†Ø¯ ÙˆØ¬ÙˆØ¯ ØªØºÙŠÙŠØ±Ø§Øª Ù…Ø¹Ù„Ù‚Ø©
        def sync_if_pending():
            if self.pending_changes and not self.is_syncing:
                self.full_sync_cycle()

        schedule.every(15).seconds.do(sync_if_pending)

        # Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ÙƒÙ„ 5 Ø¯Ù‚Ø§Ø¦Ù‚
        schedule.every(5).minutes.do(self.print_stats)

        self.logger.info("â° ØªÙ… Ø¨Ø¯Ø¡ Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø© Ø§Ù„Ø°ÙƒÙŠØ©")

    def run(self):
        """ØªØ´ØºÙŠÙ„ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„ÙƒØ§Ù…Ù„"""
        self.logger.info("ğŸš€ Ø¨Ø¯Ø¡ Ù†Ø¸Ø§Ù… Ø§Ù„Ø£ØªÙ…ØªØ© Ø§Ù„Ø´Ø§Ù…Ù„Ø©")

        # ÙØ­Øµ Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª
        if not self.check_dependencies():
            self.logger.error("âŒ Ø¨Ø¹Ø¶ Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª ØºÙŠØ± Ù…ØªÙˆÙØ±Ø©")
            return

        # Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù…
        current_branch, remote_url = self.get_git_info()
        self.logger.info(f"ğŸ“‚ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹: {os.path.basename(self.project_path)}")
        self.logger.info(f"ğŸŒ¿ Ø§Ù„ÙØ±Ø¹: {current_branch}")
        self.logger.info(f"ğŸ”— Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹: {remote_url}")

        # Ø¨Ø¯Ø¡ Ù…Ø±Ø§Ù‚Ø¨ Ø§Ù„Ù…Ù„ÙØ§Øª
        observer = self.start_file_watcher()

        # Ø¨Ø¯Ø¡ Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø©
        self.start_scheduler()

        # ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰
        self.full_sync_cycle()

        self.logger.info("ğŸ¯ Ø§Ù„Ù†Ø¸Ø§Ù… Ø¬Ø§Ù‡Ø²! Ø§Ø¶ØºØ· Ctrl+C Ù„Ù„Ø¥ÙŠÙ‚Ø§Ù")

        try:
            while True:
                schedule.run_pending()
                time.sleep(1)
        except KeyboardInterrupt:
            self.logger.info("â¹ï¸  ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù†Ø¸Ø§Ù… Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…")
            self.print_stats()
        finally:
            observer.stop()
            observer.join()
            self.logger.info("ğŸ‘‹ ÙˆØ¯Ø§Ø¹Ø§Ù‹!")


# Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
if __name__ == "__main__":
    # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Ø¸Ø§Ù… ÙˆØªØ´ØºÙŠÙ„Ù‡
    auto_sync = UltimateAutoSync()
    auto_sync.run()
